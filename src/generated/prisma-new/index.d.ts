
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 *
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model PasswordResetAttempt
 *
 */
export type PasswordResetAttempt = $Result.DefaultSelection<Prisma.$PasswordResetAttemptPayload>
/**
 * Model SecurityAuditLog
 *
 */
export type SecurityAuditLog = $Result.DefaultSelection<Prisma.$SecurityAuditLogPayload>
/**
 * Model Team
 *
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 *
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model AssuranceCase
 *
 */
export type AssuranceCase = $Result.DefaultSelection<Prisma.$AssuranceCasePayload>
/**
 * Model CasePermission
 *
 */
export type CasePermission = $Result.DefaultSelection<Prisma.$CasePermissionPayload>
/**
 * Model CaseTeamPermission
 *
 */
export type CaseTeamPermission = $Result.DefaultSelection<Prisma.$CaseTeamPermissionPayload>
/**
 * Model CaseInvite
 *
 */
export type CaseInvite = $Result.DefaultSelection<Prisma.$CaseInvitePayload>
/**
 * Model AssuranceElement
 *
 */
export type AssuranceElement = $Result.DefaultSelection<Prisma.$AssuranceElementPayload>
/**
 * Model EvidenceLink
 *
 */
export type EvidenceLink = $Result.DefaultSelection<Prisma.$EvidenceLinkPayload>
/**
 * Model ArgumentPattern
 *
 */
export type ArgumentPattern = $Result.DefaultSelection<Prisma.$ArgumentPatternPayload>
/**
 * Model PatternElement
 *
 */
export type PatternElement = $Result.DefaultSelection<Prisma.$PatternElementPayload>
/**
 * Model PatternPermission
 *
 */
export type PatternPermission = $Result.DefaultSelection<Prisma.$PatternPermissionPayload>
/**
 * Model PatternTeamPermission
 *
 */
export type PatternTeamPermission = $Result.DefaultSelection<Prisma.$PatternTeamPermissionPayload>
/**
 * Model Release
 *
 */
export type Release = $Result.DefaultSelection<Prisma.$ReleasePayload>
/**
 * Model ReleaseSnapshot
 *
 */
export type ReleaseSnapshot = $Result.DefaultSelection<Prisma.$ReleaseSnapshotPayload>
/**
 * Model ReleaseComment
 *
 */
export type ReleaseComment = $Result.DefaultSelection<Prisma.$ReleaseCommentPayload>
/**
 * Model ReleaseImage
 *
 */
export type ReleaseImage = $Result.DefaultSelection<Prisma.$ReleaseImagePayload>
/**
 * Model Comment
 *
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CaseImage
 *
 */
export type CaseImage = $Result.DefaultSelection<Prisma.$CaseImagePayload>
/**
 * Model CaseType
 *
 */
export type CaseType = $Result.DefaultSelection<Prisma.$CaseTypePayload>
/**
 * Model CaseTypeAssignment
 *
 */
export type CaseTypeAssignment = $Result.DefaultSelection<Prisma.$CaseTypeAssignmentPayload>
/**
 * Model GitHubRepository
 *
 */
export type GitHubRepository = $Result.DefaultSelection<Prisma.$GitHubRepositoryPayload>
/**
 * Model CaseStudy
 *
 */
export type CaseStudy = $Result.DefaultSelection<Prisma.$CaseStudyPayload>
/**
 * Model CaseStudyPublishedCase
 *
 */
export type CaseStudyPublishedCase = $Result.DefaultSelection<Prisma.$CaseStudyPublishedCasePayload>
/**
 * Model CaseStudyImage
 *
 */
export type CaseStudyImage = $Result.DefaultSelection<Prisma.$CaseStudyImagePayload>
/**
 * Model PublishedAssuranceCase
 *
 */
export type PublishedAssuranceCase = $Result.DefaultSelection<Prisma.$PublishedAssuranceCasePayload>
/**
 * Model LegacyMapping
 *
 */
export type LegacyMapping = $Result.DefaultSelection<Prisma.$LegacyMappingPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const AuthProvider: {
  LOCAL: 'LOCAL',
  GITHUB: 'GITHUB',
  SYSTEM: 'SYSTEM'
};

export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider]


export const CaseMode: {
  STANDARD: 'STANDARD',
  ADVANCED: 'ADVANCED'
};

export type CaseMode = (typeof CaseMode)[keyof typeof CaseMode]


export const PublishStatus: {
  DRAFT: 'DRAFT',
  READY_TO_PUBLISH: 'READY_TO_PUBLISH',
  PUBLISHED: 'PUBLISHED'
};

export type PublishStatus = (typeof PublishStatus)[keyof typeof PublishStatus]


export const TeamRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MEMBER: 'MEMBER'
};

export type TeamRole = (typeof TeamRole)[keyof typeof TeamRole]


export const PermissionLevel: {
  VIEW: 'VIEW',
  COMMENT: 'COMMENT',
  EDIT: 'EDIT',
  ADMIN: 'ADMIN'
};

export type PermissionLevel = (typeof PermissionLevel)[keyof typeof PermissionLevel]


export const ElementType: {
  GOAL: 'GOAL',
  CONTEXT: 'CONTEXT',
  STRATEGY: 'STRATEGY',
  PROPERTY_CLAIM: 'PROPERTY_CLAIM',
  EVIDENCE: 'EVIDENCE',
  JUSTIFICATION: 'JUSTIFICATION',
  ASSUMPTION: 'ASSUMPTION',
  MODULE: 'MODULE',
  AWAY_GOAL: 'AWAY_GOAL',
  CONTRACT: 'CONTRACT'
};

export type ElementType = (typeof ElementType)[keyof typeof ElementType]


export const ElementRole: {
  TOP_LEVEL: 'TOP_LEVEL',
  SUPPORTING: 'SUPPORTING'
};

export type ElementRole = (typeof ElementRole)[keyof typeof ElementRole]


export const ModuleEmbedType: {
  COPY: 'COPY',
  REFERENCE: 'REFERENCE'
};

export type ModuleEmbedType = (typeof ModuleEmbedType)[keyof typeof ModuleEmbedType]


export const ReleaseStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type ReleaseStatus = (typeof ReleaseStatus)[keyof typeof ReleaseStatus]


export const SnapshotReason: {
  INITIAL_PUBLISH: 'INITIAL_PUBLISH',
  UPDATE: 'UPDATE',
  ARCHIVE: 'ARCHIVE'
};

export type SnapshotReason = (typeof SnapshotReason)[keyof typeof SnapshotReason]


export const CommentStatus: {
  VISIBLE: 'VISIBLE',
  HIDDEN: 'HIDDEN',
  DELETED: 'DELETED'
};

export type CommentStatus = (typeof CommentStatus)[keyof typeof CommentStatus]


export const CaseTypeCategory: {
  DOMAIN: 'DOMAIN',
  TECHNIQUE: 'TECHNIQUE',
  STANDARD: 'STANDARD'
};

export type CaseTypeCategory = (typeof CaseTypeCategory)[keyof typeof CaseTypeCategory]

}

export type AuthProvider = $Enums.AuthProvider

export const AuthProvider: typeof $Enums.AuthProvider

export type CaseMode = $Enums.CaseMode

export const CaseMode: typeof $Enums.CaseMode

export type PublishStatus = $Enums.PublishStatus

export const PublishStatus: typeof $Enums.PublishStatus

export type TeamRole = $Enums.TeamRole

export const TeamRole: typeof $Enums.TeamRole

export type PermissionLevel = $Enums.PermissionLevel

export const PermissionLevel: typeof $Enums.PermissionLevel

export type ElementType = $Enums.ElementType

export const ElementType: typeof $Enums.ElementType

export type ElementRole = $Enums.ElementRole

export const ElementRole: typeof $Enums.ElementRole

export type ModuleEmbedType = $Enums.ModuleEmbedType

export const ModuleEmbedType: typeof $Enums.ModuleEmbedType

export type ReleaseStatus = $Enums.ReleaseStatus

export const ReleaseStatus: typeof $Enums.ReleaseStatus

export type SnapshotReason = $Enums.SnapshotReason

export const SnapshotReason: typeof $Enums.SnapshotReason

export type CommentStatus = $Enums.CommentStatus

export const CommentStatus: typeof $Enums.CommentStatus

export type CaseTypeCategory = $Enums.CaseTypeCategory

export const CaseTypeCategory: typeof $Enums.CaseTypeCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetAttempt`: Exposes CRUD operations for the **PasswordResetAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetAttempts
    * const passwordResetAttempts = await prisma.passwordResetAttempt.findMany()
    * ```
    */
  get passwordResetAttempt(): Prisma.PasswordResetAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.securityAuditLog`: Exposes CRUD operations for the **SecurityAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SecurityAuditLogs
    * const securityAuditLogs = await prisma.securityAuditLog.findMany()
    * ```
    */
  get securityAuditLog(): Prisma.SecurityAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assuranceCase`: Exposes CRUD operations for the **AssuranceCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssuranceCases
    * const assuranceCases = await prisma.assuranceCase.findMany()
    * ```
    */
  get assuranceCase(): Prisma.AssuranceCaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.casePermission`: Exposes CRUD operations for the **CasePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CasePermissions
    * const casePermissions = await prisma.casePermission.findMany()
    * ```
    */
  get casePermission(): Prisma.CasePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseTeamPermission`: Exposes CRUD operations for the **CaseTeamPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseTeamPermissions
    * const caseTeamPermissions = await prisma.caseTeamPermission.findMany()
    * ```
    */
  get caseTeamPermission(): Prisma.CaseTeamPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseInvite`: Exposes CRUD operations for the **CaseInvite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseInvites
    * const caseInvites = await prisma.caseInvite.findMany()
    * ```
    */
  get caseInvite(): Prisma.CaseInviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assuranceElement`: Exposes CRUD operations for the **AssuranceElement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AssuranceElements
    * const assuranceElements = await prisma.assuranceElement.findMany()
    * ```
    */
  get assuranceElement(): Prisma.AssuranceElementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evidenceLink`: Exposes CRUD operations for the **EvidenceLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EvidenceLinks
    * const evidenceLinks = await prisma.evidenceLink.findMany()
    * ```
    */
  get evidenceLink(): Prisma.EvidenceLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.argumentPattern`: Exposes CRUD operations for the **ArgumentPattern** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArgumentPatterns
    * const argumentPatterns = await prisma.argumentPattern.findMany()
    * ```
    */
  get argumentPattern(): Prisma.ArgumentPatternDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patternElement`: Exposes CRUD operations for the **PatternElement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatternElements
    * const patternElements = await prisma.patternElement.findMany()
    * ```
    */
  get patternElement(): Prisma.PatternElementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patternPermission`: Exposes CRUD operations for the **PatternPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatternPermissions
    * const patternPermissions = await prisma.patternPermission.findMany()
    * ```
    */
  get patternPermission(): Prisma.PatternPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patternTeamPermission`: Exposes CRUD operations for the **PatternTeamPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatternTeamPermissions
    * const patternTeamPermissions = await prisma.patternTeamPermission.findMany()
    * ```
    */
  get patternTeamPermission(): Prisma.PatternTeamPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.release`: Exposes CRUD operations for the **Release** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Releases
    * const releases = await prisma.release.findMany()
    * ```
    */
  get release(): Prisma.ReleaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.releaseSnapshot`: Exposes CRUD operations for the **ReleaseSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReleaseSnapshots
    * const releaseSnapshots = await prisma.releaseSnapshot.findMany()
    * ```
    */
  get releaseSnapshot(): Prisma.ReleaseSnapshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.releaseComment`: Exposes CRUD operations for the **ReleaseComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReleaseComments
    * const releaseComments = await prisma.releaseComment.findMany()
    * ```
    */
  get releaseComment(): Prisma.ReleaseCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.releaseImage`: Exposes CRUD operations for the **ReleaseImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReleaseImages
    * const releaseImages = await prisma.releaseImage.findMany()
    * ```
    */
  get releaseImage(): Prisma.ReleaseImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseImage`: Exposes CRUD operations for the **CaseImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseImages
    * const caseImages = await prisma.caseImage.findMany()
    * ```
    */
  get caseImage(): Prisma.CaseImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseType`: Exposes CRUD operations for the **CaseType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseTypes
    * const caseTypes = await prisma.caseType.findMany()
    * ```
    */
  get caseType(): Prisma.CaseTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseTypeAssignment`: Exposes CRUD operations for the **CaseTypeAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseTypeAssignments
    * const caseTypeAssignments = await prisma.caseTypeAssignment.findMany()
    * ```
    */
  get caseTypeAssignment(): Prisma.CaseTypeAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gitHubRepository`: Exposes CRUD operations for the **GitHubRepository** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GitHubRepositories
    * const gitHubRepositories = await prisma.gitHubRepository.findMany()
    * ```
    */
  get gitHubRepository(): Prisma.GitHubRepositoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseStudy`: Exposes CRUD operations for the **CaseStudy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseStudies
    * const caseStudies = await prisma.caseStudy.findMany()
    * ```
    */
  get caseStudy(): Prisma.CaseStudyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseStudyPublishedCase`: Exposes CRUD operations for the **CaseStudyPublishedCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseStudyPublishedCases
    * const caseStudyPublishedCases = await prisma.caseStudyPublishedCase.findMany()
    * ```
    */
  get caseStudyPublishedCase(): Prisma.CaseStudyPublishedCaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.caseStudyImage`: Exposes CRUD operations for the **CaseStudyImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CaseStudyImages
    * const caseStudyImages = await prisma.caseStudyImage.findMany()
    * ```
    */
  get caseStudyImage(): Prisma.CaseStudyImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publishedAssuranceCase`: Exposes CRUD operations for the **PublishedAssuranceCase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PublishedAssuranceCases
    * const publishedAssuranceCases = await prisma.publishedAssuranceCase.findMany()
    * ```
    */
  get publishedAssuranceCase(): Prisma.PublishedAssuranceCaseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.legacyMapping`: Exposes CRUD operations for the **LegacyMapping** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LegacyMappings
    * const legacyMappings = await prisma.legacyMapping.findMany()
    * ```
    */
  get legacyMapping(): Prisma.LegacyMappingDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.0
   * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    RefreshToken: 'RefreshToken',
    PasswordResetAttempt: 'PasswordResetAttempt',
    SecurityAuditLog: 'SecurityAuditLog',
    Team: 'Team',
    TeamMember: 'TeamMember',
    AssuranceCase: 'AssuranceCase',
    CasePermission: 'CasePermission',
    CaseTeamPermission: 'CaseTeamPermission',
    CaseInvite: 'CaseInvite',
    AssuranceElement: 'AssuranceElement',
    EvidenceLink: 'EvidenceLink',
    ArgumentPattern: 'ArgumentPattern',
    PatternElement: 'PatternElement',
    PatternPermission: 'PatternPermission',
    PatternTeamPermission: 'PatternTeamPermission',
    Release: 'Release',
    ReleaseSnapshot: 'ReleaseSnapshot',
    ReleaseComment: 'ReleaseComment',
    ReleaseImage: 'ReleaseImage',
    Comment: 'Comment',
    CaseImage: 'CaseImage',
    CaseType: 'CaseType',
    CaseTypeAssignment: 'CaseTypeAssignment',
    GitHubRepository: 'GitHubRepository',
    CaseStudy: 'CaseStudy',
    CaseStudyPublishedCase: 'CaseStudyPublishedCase',
    CaseStudyImage: 'CaseStudyImage',
    PublishedAssuranceCase: 'PublishedAssuranceCase',
    LegacyMapping: 'LegacyMapping'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "refreshToken" | "passwordResetAttempt" | "securityAuditLog" | "team" | "teamMember" | "assuranceCase" | "casePermission" | "caseTeamPermission" | "caseInvite" | "assuranceElement" | "evidenceLink" | "argumentPattern" | "patternElement" | "patternPermission" | "patternTeamPermission" | "release" | "releaseSnapshot" | "releaseComment" | "releaseImage" | "comment" | "caseImage" | "caseType" | "caseTypeAssignment" | "gitHubRepository" | "caseStudy" | "caseStudyPublishedCase" | "caseStudyImage" | "publishedAssuranceCase" | "legacyMapping"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetAttempt: {
        payload: Prisma.$PasswordResetAttemptPayload<ExtArgs>
        fields: Prisma.PasswordResetAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload>
          }
          findMany: {
            args: Prisma.PasswordResetAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload>[]
          }
          create: {
            args: Prisma.PasswordResetAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload>
          }
          createMany: {
            args: Prisma.PasswordResetAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload>
          }
          update: {
            args: Prisma.PasswordResetAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetAttemptPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetAttempt>
          }
          groupBy: {
            args: Prisma.PasswordResetAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetAttemptCountAggregateOutputType> | number
          }
        }
      }
      SecurityAuditLog: {
        payload: Prisma.$SecurityAuditLogPayload<ExtArgs>
        fields: Prisma.SecurityAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SecurityAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SecurityAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          findFirst: {
            args: Prisma.SecurityAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SecurityAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          findMany: {
            args: Prisma.SecurityAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>[]
          }
          create: {
            args: Prisma.SecurityAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          createMany: {
            args: Prisma.SecurityAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SecurityAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>[]
          }
          delete: {
            args: Prisma.SecurityAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          update: {
            args: Prisma.SecurityAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.SecurityAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SecurityAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SecurityAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.SecurityAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SecurityAuditLogPayload>
          }
          aggregate: {
            args: Prisma.SecurityAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSecurityAuditLog>
          }
          groupBy: {
            args: Prisma.SecurityAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<SecurityAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.SecurityAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<SecurityAuditLogCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      AssuranceCase: {
        payload: Prisma.$AssuranceCasePayload<ExtArgs>
        fields: Prisma.AssuranceCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssuranceCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssuranceCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload>
          }
          findFirst: {
            args: Prisma.AssuranceCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssuranceCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload>
          }
          findMany: {
            args: Prisma.AssuranceCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload>[]
          }
          create: {
            args: Prisma.AssuranceCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload>
          }
          createMany: {
            args: Prisma.AssuranceCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssuranceCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload>[]
          }
          delete: {
            args: Prisma.AssuranceCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload>
          }
          update: {
            args: Prisma.AssuranceCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload>
          }
          deleteMany: {
            args: Prisma.AssuranceCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssuranceCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssuranceCaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload>[]
          }
          upsert: {
            args: Prisma.AssuranceCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceCasePayload>
          }
          aggregate: {
            args: Prisma.AssuranceCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssuranceCase>
          }
          groupBy: {
            args: Prisma.AssuranceCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssuranceCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssuranceCaseCountArgs<ExtArgs>
            result: $Utils.Optional<AssuranceCaseCountAggregateOutputType> | number
          }
        }
      }
      CasePermission: {
        payload: Prisma.$CasePermissionPayload<ExtArgs>
        fields: Prisma.CasePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CasePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CasePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload>
          }
          findFirst: {
            args: Prisma.CasePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CasePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload>
          }
          findMany: {
            args: Prisma.CasePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload>[]
          }
          create: {
            args: Prisma.CasePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload>
          }
          createMany: {
            args: Prisma.CasePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CasePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload>[]
          }
          delete: {
            args: Prisma.CasePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload>
          }
          update: {
            args: Prisma.CasePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload>
          }
          deleteMany: {
            args: Prisma.CasePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CasePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CasePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload>[]
          }
          upsert: {
            args: Prisma.CasePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CasePermissionPayload>
          }
          aggregate: {
            args: Prisma.CasePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCasePermission>
          }
          groupBy: {
            args: Prisma.CasePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CasePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CasePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<CasePermissionCountAggregateOutputType> | number
          }
        }
      }
      CaseTeamPermission: {
        payload: Prisma.$CaseTeamPermissionPayload<ExtArgs>
        fields: Prisma.CaseTeamPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseTeamPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseTeamPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload>
          }
          findFirst: {
            args: Prisma.CaseTeamPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseTeamPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload>
          }
          findMany: {
            args: Prisma.CaseTeamPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload>[]
          }
          create: {
            args: Prisma.CaseTeamPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload>
          }
          createMany: {
            args: Prisma.CaseTeamPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseTeamPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload>[]
          }
          delete: {
            args: Prisma.CaseTeamPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload>
          }
          update: {
            args: Prisma.CaseTeamPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload>
          }
          deleteMany: {
            args: Prisma.CaseTeamPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseTeamPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseTeamPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload>[]
          }
          upsert: {
            args: Prisma.CaseTeamPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTeamPermissionPayload>
          }
          aggregate: {
            args: Prisma.CaseTeamPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseTeamPermission>
          }
          groupBy: {
            args: Prisma.CaseTeamPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseTeamPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseTeamPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<CaseTeamPermissionCountAggregateOutputType> | number
          }
        }
      }
      CaseInvite: {
        payload: Prisma.$CaseInvitePayload<ExtArgs>
        fields: Prisma.CaseInviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseInviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseInviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload>
          }
          findFirst: {
            args: Prisma.CaseInviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseInviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload>
          }
          findMany: {
            args: Prisma.CaseInviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload>[]
          }
          create: {
            args: Prisma.CaseInviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload>
          }
          createMany: {
            args: Prisma.CaseInviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseInviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload>[]
          }
          delete: {
            args: Prisma.CaseInviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload>
          }
          update: {
            args: Prisma.CaseInviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload>
          }
          deleteMany: {
            args: Prisma.CaseInviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseInviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseInviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload>[]
          }
          upsert: {
            args: Prisma.CaseInviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseInvitePayload>
          }
          aggregate: {
            args: Prisma.CaseInviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseInvite>
          }
          groupBy: {
            args: Prisma.CaseInviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseInviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseInviteCountArgs<ExtArgs>
            result: $Utils.Optional<CaseInviteCountAggregateOutputType> | number
          }
        }
      }
      AssuranceElement: {
        payload: Prisma.$AssuranceElementPayload<ExtArgs>
        fields: Prisma.AssuranceElementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssuranceElementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssuranceElementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload>
          }
          findFirst: {
            args: Prisma.AssuranceElementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssuranceElementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload>
          }
          findMany: {
            args: Prisma.AssuranceElementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload>[]
          }
          create: {
            args: Prisma.AssuranceElementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload>
          }
          createMany: {
            args: Prisma.AssuranceElementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssuranceElementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload>[]
          }
          delete: {
            args: Prisma.AssuranceElementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload>
          }
          update: {
            args: Prisma.AssuranceElementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload>
          }
          deleteMany: {
            args: Prisma.AssuranceElementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssuranceElementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssuranceElementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload>[]
          }
          upsert: {
            args: Prisma.AssuranceElementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssuranceElementPayload>
          }
          aggregate: {
            args: Prisma.AssuranceElementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssuranceElement>
          }
          groupBy: {
            args: Prisma.AssuranceElementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssuranceElementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssuranceElementCountArgs<ExtArgs>
            result: $Utils.Optional<AssuranceElementCountAggregateOutputType> | number
          }
        }
      }
      EvidenceLink: {
        payload: Prisma.$EvidenceLinkPayload<ExtArgs>
        fields: Prisma.EvidenceLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvidenceLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvidenceLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload>
          }
          findFirst: {
            args: Prisma.EvidenceLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvidenceLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload>
          }
          findMany: {
            args: Prisma.EvidenceLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload>[]
          }
          create: {
            args: Prisma.EvidenceLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload>
          }
          createMany: {
            args: Prisma.EvidenceLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvidenceLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload>[]
          }
          delete: {
            args: Prisma.EvidenceLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload>
          }
          update: {
            args: Prisma.EvidenceLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload>
          }
          deleteMany: {
            args: Prisma.EvidenceLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvidenceLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvidenceLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload>[]
          }
          upsert: {
            args: Prisma.EvidenceLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvidenceLinkPayload>
          }
          aggregate: {
            args: Prisma.EvidenceLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvidenceLink>
          }
          groupBy: {
            args: Prisma.EvidenceLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvidenceLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvidenceLinkCountArgs<ExtArgs>
            result: $Utils.Optional<EvidenceLinkCountAggregateOutputType> | number
          }
        }
      }
      ArgumentPattern: {
        payload: Prisma.$ArgumentPatternPayload<ExtArgs>
        fields: Prisma.ArgumentPatternFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArgumentPatternFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArgumentPatternFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload>
          }
          findFirst: {
            args: Prisma.ArgumentPatternFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArgumentPatternFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload>
          }
          findMany: {
            args: Prisma.ArgumentPatternFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload>[]
          }
          create: {
            args: Prisma.ArgumentPatternCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload>
          }
          createMany: {
            args: Prisma.ArgumentPatternCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArgumentPatternCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload>[]
          }
          delete: {
            args: Prisma.ArgumentPatternDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload>
          }
          update: {
            args: Prisma.ArgumentPatternUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload>
          }
          deleteMany: {
            args: Prisma.ArgumentPatternDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArgumentPatternUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArgumentPatternUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload>[]
          }
          upsert: {
            args: Prisma.ArgumentPatternUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArgumentPatternPayload>
          }
          aggregate: {
            args: Prisma.ArgumentPatternAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArgumentPattern>
          }
          groupBy: {
            args: Prisma.ArgumentPatternGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArgumentPatternGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArgumentPatternCountArgs<ExtArgs>
            result: $Utils.Optional<ArgumentPatternCountAggregateOutputType> | number
          }
        }
      }
      PatternElement: {
        payload: Prisma.$PatternElementPayload<ExtArgs>
        fields: Prisma.PatternElementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatternElementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatternElementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload>
          }
          findFirst: {
            args: Prisma.PatternElementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatternElementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload>
          }
          findMany: {
            args: Prisma.PatternElementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload>[]
          }
          create: {
            args: Prisma.PatternElementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload>
          }
          createMany: {
            args: Prisma.PatternElementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatternElementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload>[]
          }
          delete: {
            args: Prisma.PatternElementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload>
          }
          update: {
            args: Prisma.PatternElementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload>
          }
          deleteMany: {
            args: Prisma.PatternElementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatternElementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatternElementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload>[]
          }
          upsert: {
            args: Prisma.PatternElementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternElementPayload>
          }
          aggregate: {
            args: Prisma.PatternElementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatternElement>
          }
          groupBy: {
            args: Prisma.PatternElementGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatternElementGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatternElementCountArgs<ExtArgs>
            result: $Utils.Optional<PatternElementCountAggregateOutputType> | number
          }
        }
      }
      PatternPermission: {
        payload: Prisma.$PatternPermissionPayload<ExtArgs>
        fields: Prisma.PatternPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatternPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatternPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload>
          }
          findFirst: {
            args: Prisma.PatternPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatternPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload>
          }
          findMany: {
            args: Prisma.PatternPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload>[]
          }
          create: {
            args: Prisma.PatternPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload>
          }
          createMany: {
            args: Prisma.PatternPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatternPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload>[]
          }
          delete: {
            args: Prisma.PatternPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload>
          }
          update: {
            args: Prisma.PatternPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload>
          }
          deleteMany: {
            args: Prisma.PatternPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatternPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatternPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload>[]
          }
          upsert: {
            args: Prisma.PatternPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternPermissionPayload>
          }
          aggregate: {
            args: Prisma.PatternPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatternPermission>
          }
          groupBy: {
            args: Prisma.PatternPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatternPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatternPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PatternPermissionCountAggregateOutputType> | number
          }
        }
      }
      PatternTeamPermission: {
        payload: Prisma.$PatternTeamPermissionPayload<ExtArgs>
        fields: Prisma.PatternTeamPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatternTeamPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatternTeamPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload>
          }
          findFirst: {
            args: Prisma.PatternTeamPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatternTeamPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload>
          }
          findMany: {
            args: Prisma.PatternTeamPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload>[]
          }
          create: {
            args: Prisma.PatternTeamPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload>
          }
          createMany: {
            args: Prisma.PatternTeamPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatternTeamPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload>[]
          }
          delete: {
            args: Prisma.PatternTeamPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload>
          }
          update: {
            args: Prisma.PatternTeamPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload>
          }
          deleteMany: {
            args: Prisma.PatternTeamPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatternTeamPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PatternTeamPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload>[]
          }
          upsert: {
            args: Prisma.PatternTeamPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatternTeamPermissionPayload>
          }
          aggregate: {
            args: Prisma.PatternTeamPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatternTeamPermission>
          }
          groupBy: {
            args: Prisma.PatternTeamPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatternTeamPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatternTeamPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PatternTeamPermissionCountAggregateOutputType> | number
          }
        }
      }
      Release: {
        payload: Prisma.$ReleasePayload<ExtArgs>
        fields: Prisma.ReleaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReleaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReleaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          findFirst: {
            args: Prisma.ReleaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReleaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          findMany: {
            args: Prisma.ReleaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>[]
          }
          create: {
            args: Prisma.ReleaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          createMany: {
            args: Prisma.ReleaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReleaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>[]
          }
          delete: {
            args: Prisma.ReleaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          update: {
            args: Prisma.ReleaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          deleteMany: {
            args: Prisma.ReleaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReleaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReleaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>[]
          }
          upsert: {
            args: Prisma.ReleaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleasePayload>
          }
          aggregate: {
            args: Prisma.ReleaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRelease>
          }
          groupBy: {
            args: Prisma.ReleaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReleaseCountArgs<ExtArgs>
            result: $Utils.Optional<ReleaseCountAggregateOutputType> | number
          }
        }
      }
      ReleaseSnapshot: {
        payload: Prisma.$ReleaseSnapshotPayload<ExtArgs>
        fields: Prisma.ReleaseSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReleaseSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReleaseSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload>
          }
          findFirst: {
            args: Prisma.ReleaseSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReleaseSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload>
          }
          findMany: {
            args: Prisma.ReleaseSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload>[]
          }
          create: {
            args: Prisma.ReleaseSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload>
          }
          createMany: {
            args: Prisma.ReleaseSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReleaseSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload>[]
          }
          delete: {
            args: Prisma.ReleaseSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload>
          }
          update: {
            args: Prisma.ReleaseSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.ReleaseSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReleaseSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReleaseSnapshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload>[]
          }
          upsert: {
            args: Prisma.ReleaseSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseSnapshotPayload>
          }
          aggregate: {
            args: Prisma.ReleaseSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReleaseSnapshot>
          }
          groupBy: {
            args: Prisma.ReleaseSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleaseSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReleaseSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<ReleaseSnapshotCountAggregateOutputType> | number
          }
        }
      }
      ReleaseComment: {
        payload: Prisma.$ReleaseCommentPayload<ExtArgs>
        fields: Prisma.ReleaseCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReleaseCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReleaseCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload>
          }
          findFirst: {
            args: Prisma.ReleaseCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReleaseCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload>
          }
          findMany: {
            args: Prisma.ReleaseCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload>[]
          }
          create: {
            args: Prisma.ReleaseCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload>
          }
          createMany: {
            args: Prisma.ReleaseCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReleaseCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload>[]
          }
          delete: {
            args: Prisma.ReleaseCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload>
          }
          update: {
            args: Prisma.ReleaseCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload>
          }
          deleteMany: {
            args: Prisma.ReleaseCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReleaseCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReleaseCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload>[]
          }
          upsert: {
            args: Prisma.ReleaseCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseCommentPayload>
          }
          aggregate: {
            args: Prisma.ReleaseCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReleaseComment>
          }
          groupBy: {
            args: Prisma.ReleaseCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleaseCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReleaseCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ReleaseCommentCountAggregateOutputType> | number
          }
        }
      }
      ReleaseImage: {
        payload: Prisma.$ReleaseImagePayload<ExtArgs>
        fields: Prisma.ReleaseImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReleaseImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReleaseImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload>
          }
          findFirst: {
            args: Prisma.ReleaseImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReleaseImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload>
          }
          findMany: {
            args: Prisma.ReleaseImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload>[]
          }
          create: {
            args: Prisma.ReleaseImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload>
          }
          createMany: {
            args: Prisma.ReleaseImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReleaseImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload>[]
          }
          delete: {
            args: Prisma.ReleaseImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload>
          }
          update: {
            args: Prisma.ReleaseImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload>
          }
          deleteMany: {
            args: Prisma.ReleaseImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReleaseImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReleaseImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload>[]
          }
          upsert: {
            args: Prisma.ReleaseImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReleaseImagePayload>
          }
          aggregate: {
            args: Prisma.ReleaseImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReleaseImage>
          }
          groupBy: {
            args: Prisma.ReleaseImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReleaseImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReleaseImageCountArgs<ExtArgs>
            result: $Utils.Optional<ReleaseImageCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CaseImage: {
        payload: Prisma.$CaseImagePayload<ExtArgs>
        fields: Prisma.CaseImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload>
          }
          findFirst: {
            args: Prisma.CaseImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload>
          }
          findMany: {
            args: Prisma.CaseImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload>[]
          }
          create: {
            args: Prisma.CaseImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload>
          }
          createMany: {
            args: Prisma.CaseImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload>[]
          }
          delete: {
            args: Prisma.CaseImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload>
          }
          update: {
            args: Prisma.CaseImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload>
          }
          deleteMany: {
            args: Prisma.CaseImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload>[]
          }
          upsert: {
            args: Prisma.CaseImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseImagePayload>
          }
          aggregate: {
            args: Prisma.CaseImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseImage>
          }
          groupBy: {
            args: Prisma.CaseImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseImageCountArgs<ExtArgs>
            result: $Utils.Optional<CaseImageCountAggregateOutputType> | number
          }
        }
      }
      CaseType: {
        payload: Prisma.$CaseTypePayload<ExtArgs>
        fields: Prisma.CaseTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload>
          }
          findFirst: {
            args: Prisma.CaseTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload>
          }
          findMany: {
            args: Prisma.CaseTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload>[]
          }
          create: {
            args: Prisma.CaseTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload>
          }
          createMany: {
            args: Prisma.CaseTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload>[]
          }
          delete: {
            args: Prisma.CaseTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload>
          }
          update: {
            args: Prisma.CaseTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload>
          }
          deleteMany: {
            args: Prisma.CaseTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload>[]
          }
          upsert: {
            args: Prisma.CaseTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypePayload>
          }
          aggregate: {
            args: Prisma.CaseTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseType>
          }
          groupBy: {
            args: Prisma.CaseTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseTypeCountArgs<ExtArgs>
            result: $Utils.Optional<CaseTypeCountAggregateOutputType> | number
          }
        }
      }
      CaseTypeAssignment: {
        payload: Prisma.$CaseTypeAssignmentPayload<ExtArgs>
        fields: Prisma.CaseTypeAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseTypeAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseTypeAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload>
          }
          findFirst: {
            args: Prisma.CaseTypeAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseTypeAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload>
          }
          findMany: {
            args: Prisma.CaseTypeAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload>[]
          }
          create: {
            args: Prisma.CaseTypeAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload>
          }
          createMany: {
            args: Prisma.CaseTypeAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseTypeAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload>[]
          }
          delete: {
            args: Prisma.CaseTypeAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload>
          }
          update: {
            args: Prisma.CaseTypeAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.CaseTypeAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseTypeAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseTypeAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.CaseTypeAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseTypeAssignmentPayload>
          }
          aggregate: {
            args: Prisma.CaseTypeAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseTypeAssignment>
          }
          groupBy: {
            args: Prisma.CaseTypeAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseTypeAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseTypeAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<CaseTypeAssignmentCountAggregateOutputType> | number
          }
        }
      }
      GitHubRepository: {
        payload: Prisma.$GitHubRepositoryPayload<ExtArgs>
        fields: Prisma.GitHubRepositoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GitHubRepositoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GitHubRepositoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload>
          }
          findFirst: {
            args: Prisma.GitHubRepositoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GitHubRepositoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload>
          }
          findMany: {
            args: Prisma.GitHubRepositoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload>[]
          }
          create: {
            args: Prisma.GitHubRepositoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload>
          }
          createMany: {
            args: Prisma.GitHubRepositoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GitHubRepositoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload>[]
          }
          delete: {
            args: Prisma.GitHubRepositoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload>
          }
          update: {
            args: Prisma.GitHubRepositoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload>
          }
          deleteMany: {
            args: Prisma.GitHubRepositoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GitHubRepositoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GitHubRepositoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload>[]
          }
          upsert: {
            args: Prisma.GitHubRepositoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GitHubRepositoryPayload>
          }
          aggregate: {
            args: Prisma.GitHubRepositoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGitHubRepository>
          }
          groupBy: {
            args: Prisma.GitHubRepositoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<GitHubRepositoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.GitHubRepositoryCountArgs<ExtArgs>
            result: $Utils.Optional<GitHubRepositoryCountAggregateOutputType> | number
          }
        }
      }
      CaseStudy: {
        payload: Prisma.$CaseStudyPayload<ExtArgs>
        fields: Prisma.CaseStudyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseStudyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseStudyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          findFirst: {
            args: Prisma.CaseStudyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseStudyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          findMany: {
            args: Prisma.CaseStudyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>[]
          }
          create: {
            args: Prisma.CaseStudyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          createMany: {
            args: Prisma.CaseStudyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseStudyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>[]
          }
          delete: {
            args: Prisma.CaseStudyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          update: {
            args: Prisma.CaseStudyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          deleteMany: {
            args: Prisma.CaseStudyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseStudyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseStudyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>[]
          }
          upsert: {
            args: Prisma.CaseStudyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPayload>
          }
          aggregate: {
            args: Prisma.CaseStudyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseStudy>
          }
          groupBy: {
            args: Prisma.CaseStudyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseStudyCountArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyCountAggregateOutputType> | number
          }
        }
      }
      CaseStudyPublishedCase: {
        payload: Prisma.$CaseStudyPublishedCasePayload<ExtArgs>
        fields: Prisma.CaseStudyPublishedCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseStudyPublishedCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseStudyPublishedCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload>
          }
          findFirst: {
            args: Prisma.CaseStudyPublishedCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseStudyPublishedCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload>
          }
          findMany: {
            args: Prisma.CaseStudyPublishedCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload>[]
          }
          create: {
            args: Prisma.CaseStudyPublishedCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload>
          }
          createMany: {
            args: Prisma.CaseStudyPublishedCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseStudyPublishedCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload>[]
          }
          delete: {
            args: Prisma.CaseStudyPublishedCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload>
          }
          update: {
            args: Prisma.CaseStudyPublishedCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload>
          }
          deleteMany: {
            args: Prisma.CaseStudyPublishedCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseStudyPublishedCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseStudyPublishedCaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload>[]
          }
          upsert: {
            args: Prisma.CaseStudyPublishedCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyPublishedCasePayload>
          }
          aggregate: {
            args: Prisma.CaseStudyPublishedCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseStudyPublishedCase>
          }
          groupBy: {
            args: Prisma.CaseStudyPublishedCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyPublishedCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseStudyPublishedCaseCountArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyPublishedCaseCountAggregateOutputType> | number
          }
        }
      }
      CaseStudyImage: {
        payload: Prisma.$CaseStudyImagePayload<ExtArgs>
        fields: Prisma.CaseStudyImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CaseStudyImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CaseStudyImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload>
          }
          findFirst: {
            args: Prisma.CaseStudyImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CaseStudyImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload>
          }
          findMany: {
            args: Prisma.CaseStudyImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload>[]
          }
          create: {
            args: Prisma.CaseStudyImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload>
          }
          createMany: {
            args: Prisma.CaseStudyImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CaseStudyImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload>[]
          }
          delete: {
            args: Prisma.CaseStudyImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload>
          }
          update: {
            args: Prisma.CaseStudyImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload>
          }
          deleteMany: {
            args: Prisma.CaseStudyImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CaseStudyImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CaseStudyImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload>[]
          }
          upsert: {
            args: Prisma.CaseStudyImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CaseStudyImagePayload>
          }
          aggregate: {
            args: Prisma.CaseStudyImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCaseStudyImage>
          }
          groupBy: {
            args: Prisma.CaseStudyImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CaseStudyImageCountArgs<ExtArgs>
            result: $Utils.Optional<CaseStudyImageCountAggregateOutputType> | number
          }
        }
      }
      PublishedAssuranceCase: {
        payload: Prisma.$PublishedAssuranceCasePayload<ExtArgs>
        fields: Prisma.PublishedAssuranceCaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublishedAssuranceCaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublishedAssuranceCaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload>
          }
          findFirst: {
            args: Prisma.PublishedAssuranceCaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublishedAssuranceCaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload>
          }
          findMany: {
            args: Prisma.PublishedAssuranceCaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload>[]
          }
          create: {
            args: Prisma.PublishedAssuranceCaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload>
          }
          createMany: {
            args: Prisma.PublishedAssuranceCaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PublishedAssuranceCaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload>[]
          }
          delete: {
            args: Prisma.PublishedAssuranceCaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload>
          }
          update: {
            args: Prisma.PublishedAssuranceCaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload>
          }
          deleteMany: {
            args: Prisma.PublishedAssuranceCaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PublishedAssuranceCaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PublishedAssuranceCaseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload>[]
          }
          upsert: {
            args: Prisma.PublishedAssuranceCaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PublishedAssuranceCasePayload>
          }
          aggregate: {
            args: Prisma.PublishedAssuranceCaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublishedAssuranceCase>
          }
          groupBy: {
            args: Prisma.PublishedAssuranceCaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublishedAssuranceCaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublishedAssuranceCaseCountArgs<ExtArgs>
            result: $Utils.Optional<PublishedAssuranceCaseCountAggregateOutputType> | number
          }
        }
      }
      LegacyMapping: {
        payload: Prisma.$LegacyMappingPayload<ExtArgs>
        fields: Prisma.LegacyMappingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LegacyMappingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LegacyMappingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload>
          }
          findFirst: {
            args: Prisma.LegacyMappingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LegacyMappingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload>
          }
          findMany: {
            args: Prisma.LegacyMappingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload>[]
          }
          create: {
            args: Prisma.LegacyMappingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload>
          }
          createMany: {
            args: Prisma.LegacyMappingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LegacyMappingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload>[]
          }
          delete: {
            args: Prisma.LegacyMappingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload>
          }
          update: {
            args: Prisma.LegacyMappingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload>
          }
          deleteMany: {
            args: Prisma.LegacyMappingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LegacyMappingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LegacyMappingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload>[]
          }
          upsert: {
            args: Prisma.LegacyMappingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LegacyMappingPayload>
          }
          aggregate: {
            args: Prisma.LegacyMappingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLegacyMapping>
          }
          groupBy: {
            args: Prisma.LegacyMappingGroupByArgs<ExtArgs>
            result: $Utils.Optional<LegacyMappingGroupByOutputType>[]
          }
          count: {
            args: Prisma.LegacyMappingCountArgs<ExtArgs>
            result: $Utils.Optional<LegacyMappingCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    refreshToken?: RefreshTokenOmit
    passwordResetAttempt?: PasswordResetAttemptOmit
    securityAuditLog?: SecurityAuditLogOmit
    team?: TeamOmit
    teamMember?: TeamMemberOmit
    assuranceCase?: AssuranceCaseOmit
    casePermission?: CasePermissionOmit
    caseTeamPermission?: CaseTeamPermissionOmit
    caseInvite?: CaseInviteOmit
    assuranceElement?: AssuranceElementOmit
    evidenceLink?: EvidenceLinkOmit
    argumentPattern?: ArgumentPatternOmit
    patternElement?: PatternElementOmit
    patternPermission?: PatternPermissionOmit
    patternTeamPermission?: PatternTeamPermissionOmit
    release?: ReleaseOmit
    releaseSnapshot?: ReleaseSnapshotOmit
    releaseComment?: ReleaseCommentOmit
    releaseImage?: ReleaseImageOmit
    comment?: CommentOmit
    caseImage?: CaseImageOmit
    caseType?: CaseTypeOmit
    caseTypeAssignment?: CaseTypeAssignmentOmit
    gitHubRepository?: GitHubRepositoryOmit
    caseStudy?: CaseStudyOmit
    caseStudyPublishedCase?: CaseStudyPublishedCaseOmit
    caseStudyImage?: CaseStudyImageOmit
    publishedAssuranceCase?: PublishedAssuranceCaseOmit
    legacyMapping?: LegacyMappingOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    teamMemberships: number
    createdTeams: number
    createdCases: number
    casePermissions: number
    grantedPermissions: number
    createdElements: number
    authoredComments: number
    resolvedComments: number
    releaseComments: number
    githubRepositories: number
    refreshTokens: number
    caseStudies: number
    markedReadyCases: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    createdTeams?: boolean | UserCountOutputTypeCountCreatedTeamsArgs
    createdCases?: boolean | UserCountOutputTypeCountCreatedCasesArgs
    casePermissions?: boolean | UserCountOutputTypeCountCasePermissionsArgs
    grantedPermissions?: boolean | UserCountOutputTypeCountGrantedPermissionsArgs
    createdElements?: boolean | UserCountOutputTypeCountCreatedElementsArgs
    authoredComments?: boolean | UserCountOutputTypeCountAuthoredCommentsArgs
    resolvedComments?: boolean | UserCountOutputTypeCountResolvedCommentsArgs
    releaseComments?: boolean | UserCountOutputTypeCountReleaseCommentsArgs
    githubRepositories?: boolean | UserCountOutputTypeCountGithubRepositoriesArgs
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    caseStudies?: boolean | UserCountOutputTypeCountCaseStudiesArgs
    markedReadyCases?: boolean | UserCountOutputTypeCountMarkedReadyCasesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceCaseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCasePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CasePermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGrantedPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CasePermissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceElementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthoredCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountResolvedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReleaseCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGithubRepositoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GitHubRepositoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCaseStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMarkedReadyCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceCaseWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    casePermissions: number
    patternPermissions: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    casePermissions?: boolean | TeamCountOutputTypeCountCasePermissionsArgs
    patternPermissions?: boolean | TeamCountOutputTypeCountPatternPermissionsArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountCasePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseTeamPermissionWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountPatternPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternTeamPermissionWhereInput
  }


  /**
   * Count Type AssuranceCaseCountOutputType
   */

  export type AssuranceCaseCountOutputType = {
    elements: number
    userPermissions: number
    teamPermissions: number
    invites: number
    comments: number
    caseTypes: number
    sourceReleases: number
    publishedReleases: number
    publishedVersions: number
    embeddedIn: number
  }

  export type AssuranceCaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elements?: boolean | AssuranceCaseCountOutputTypeCountElementsArgs
    userPermissions?: boolean | AssuranceCaseCountOutputTypeCountUserPermissionsArgs
    teamPermissions?: boolean | AssuranceCaseCountOutputTypeCountTeamPermissionsArgs
    invites?: boolean | AssuranceCaseCountOutputTypeCountInvitesArgs
    comments?: boolean | AssuranceCaseCountOutputTypeCountCommentsArgs
    caseTypes?: boolean | AssuranceCaseCountOutputTypeCountCaseTypesArgs
    sourceReleases?: boolean | AssuranceCaseCountOutputTypeCountSourceReleasesArgs
    publishedReleases?: boolean | AssuranceCaseCountOutputTypeCountPublishedReleasesArgs
    publishedVersions?: boolean | AssuranceCaseCountOutputTypeCountPublishedVersionsArgs
    embeddedIn?: boolean | AssuranceCaseCountOutputTypeCountEmbeddedInArgs
  }

  // Custom InputTypes
  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCaseCountOutputType
     */
    select?: AssuranceCaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceElementWhereInput
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountUserPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CasePermissionWhereInput
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountTeamPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseTeamPermissionWhereInput
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseInviteWhereInput
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountCaseTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseTypeAssignmentWhereInput
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountSourceReleasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseWhereInput
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountPublishedReleasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseWhereInput
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountPublishedVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublishedAssuranceCaseWhereInput
  }

  /**
   * AssuranceCaseCountOutputType without action
   */
  export type AssuranceCaseCountOutputTypeCountEmbeddedInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceElementWhereInput
  }


  /**
   * Count Type AssuranceElementCountOutputType
   */

  export type AssuranceElementCountOutputType = {
    children: number
    defeatedBy: number
    evidenceLinksFrom: number
    evidenceLinksTo: number
    comments: number
    releaseComments: number
  }

  export type AssuranceElementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | AssuranceElementCountOutputTypeCountChildrenArgs
    defeatedBy?: boolean | AssuranceElementCountOutputTypeCountDefeatedByArgs
    evidenceLinksFrom?: boolean | AssuranceElementCountOutputTypeCountEvidenceLinksFromArgs
    evidenceLinksTo?: boolean | AssuranceElementCountOutputTypeCountEvidenceLinksToArgs
    comments?: boolean | AssuranceElementCountOutputTypeCountCommentsArgs
    releaseComments?: boolean | AssuranceElementCountOutputTypeCountReleaseCommentsArgs
  }

  // Custom InputTypes
  /**
   * AssuranceElementCountOutputType without action
   */
  export type AssuranceElementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElementCountOutputType
     */
    select?: AssuranceElementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssuranceElementCountOutputType without action
   */
  export type AssuranceElementCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceElementWhereInput
  }

  /**
   * AssuranceElementCountOutputType without action
   */
  export type AssuranceElementCountOutputTypeCountDefeatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceElementWhereInput
  }

  /**
   * AssuranceElementCountOutputType without action
   */
  export type AssuranceElementCountOutputTypeCountEvidenceLinksFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceLinkWhereInput
  }

  /**
   * AssuranceElementCountOutputType without action
   */
  export type AssuranceElementCountOutputTypeCountEvidenceLinksToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceLinkWhereInput
  }

  /**
   * AssuranceElementCountOutputType without action
   */
  export type AssuranceElementCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * AssuranceElementCountOutputType without action
   */
  export type AssuranceElementCountOutputTypeCountReleaseCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseCommentWhereInput
  }


  /**
   * Count Type ArgumentPatternCountOutputType
   */

  export type ArgumentPatternCountOutputType = {
    elements: number
    userPermissions: number
    teamPermissions: number
    derivedCases: number
  }

  export type ArgumentPatternCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elements?: boolean | ArgumentPatternCountOutputTypeCountElementsArgs
    userPermissions?: boolean | ArgumentPatternCountOutputTypeCountUserPermissionsArgs
    teamPermissions?: boolean | ArgumentPatternCountOutputTypeCountTeamPermissionsArgs
    derivedCases?: boolean | ArgumentPatternCountOutputTypeCountDerivedCasesArgs
  }

  // Custom InputTypes
  /**
   * ArgumentPatternCountOutputType without action
   */
  export type ArgumentPatternCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPatternCountOutputType
     */
    select?: ArgumentPatternCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ArgumentPatternCountOutputType without action
   */
  export type ArgumentPatternCountOutputTypeCountElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternElementWhereInput
  }

  /**
   * ArgumentPatternCountOutputType without action
   */
  export type ArgumentPatternCountOutputTypeCountUserPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternPermissionWhereInput
  }

  /**
   * ArgumentPatternCountOutputType without action
   */
  export type ArgumentPatternCountOutputTypeCountTeamPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternTeamPermissionWhereInput
  }

  /**
   * ArgumentPatternCountOutputType without action
   */
  export type ArgumentPatternCountOutputTypeCountDerivedCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceCaseWhereInput
  }


  /**
   * Count Type PatternElementCountOutputType
   */

  export type PatternElementCountOutputType = {
    children: number
  }

  export type PatternElementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | PatternElementCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * PatternElementCountOutputType without action
   */
  export type PatternElementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElementCountOutputType
     */
    select?: PatternElementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatternElementCountOutputType without action
   */
  export type PatternElementCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternElementWhereInput
  }


  /**
   * Count Type ReleaseCountOutputType
   */

  export type ReleaseCountOutputType = {
    snapshots: number
    comments: number
  }

  export type ReleaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    snapshots?: boolean | ReleaseCountOutputTypeCountSnapshotsArgs
    comments?: boolean | ReleaseCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * ReleaseCountOutputType without action
   */
  export type ReleaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseCountOutputType
     */
    select?: ReleaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReleaseCountOutputType without action
   */
  export type ReleaseCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseSnapshotWhereInput
  }

  /**
   * ReleaseCountOutputType without action
   */
  export type ReleaseCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseCommentWhereInput
  }


  /**
   * Count Type ReleaseCommentCountOutputType
   */

  export type ReleaseCommentCountOutputType = {
    replies: number
  }

  export type ReleaseCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | ReleaseCommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * ReleaseCommentCountOutputType without action
   */
  export type ReleaseCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseCommentCountOutputType
     */
    select?: ReleaseCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReleaseCommentCountOutputType without action
   */
  export type ReleaseCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseCommentWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type CaseTypeCountOutputType
   */

  export type CaseTypeCountOutputType = {
    assignments: number
  }

  export type CaseTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | CaseTypeCountOutputTypeCountAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * CaseTypeCountOutputType without action
   */
  export type CaseTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeCountOutputType
     */
    select?: CaseTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaseTypeCountOutputType without action
   */
  export type CaseTypeCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseTypeAssignmentWhereInput
  }


  /**
   * Count Type CaseStudyCountOutputType
   */

  export type CaseStudyCountOutputType = {
    publishedCases: number
  }

  export type CaseStudyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publishedCases?: boolean | CaseStudyCountOutputTypeCountPublishedCasesArgs
  }

  // Custom InputTypes
  /**
   * CaseStudyCountOutputType without action
   */
  export type CaseStudyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyCountOutputType
     */
    select?: CaseStudyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CaseStudyCountOutputType without action
   */
  export type CaseStudyCountOutputTypeCountPublishedCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyPublishedCaseWhereInput
  }


  /**
   * Count Type PublishedAssuranceCaseCountOutputType
   */

  export type PublishedAssuranceCaseCountOutputType = {
    caseStudyLinks: number
  }

  export type PublishedAssuranceCaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caseStudyLinks?: boolean | PublishedAssuranceCaseCountOutputTypeCountCaseStudyLinksArgs
  }

  // Custom InputTypes
  /**
   * PublishedAssuranceCaseCountOutputType without action
   */
  export type PublishedAssuranceCaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCaseCountOutputType
     */
    select?: PublishedAssuranceCaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PublishedAssuranceCaseCountOutputType without action
   */
  export type PublishedAssuranceCaseCountOutputTypeCountCaseStudyLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyPublishedCaseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    passwordAlgorithm: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    authProvider: $Enums.AuthProvider | null
    githubId: string | null
    githubUsername: string | null
    emailVerified: boolean | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    defaultCaseMode: $Enums.CaseMode | null
    hasSeenMigrationNotice: boolean | null
    isSystemUser: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    passwordHash: string | null
    passwordAlgorithm: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    authProvider: $Enums.AuthProvider | null
    githubId: string | null
    githubUsername: string | null
    emailVerified: boolean | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    defaultCaseMode: $Enums.CaseMode | null
    hasSeenMigrationNotice: boolean | null
    isSystemUser: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLoginAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    passwordHash: number
    passwordAlgorithm: number
    firstName: number
    lastName: number
    avatarUrl: number
    authProvider: number
    githubId: number
    githubUsername: number
    emailVerified: number
    passwordResetToken: number
    passwordResetExpires: number
    defaultCaseMode: number
    hasSeenMigrationNotice: number
    isSystemUser: number
    createdAt: number
    updatedAt: number
    lastLoginAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    passwordAlgorithm?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    authProvider?: true
    githubId?: true
    githubUsername?: true
    emailVerified?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    defaultCaseMode?: true
    hasSeenMigrationNotice?: true
    isSystemUser?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    passwordAlgorithm?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    authProvider?: true
    githubId?: true
    githubUsername?: true
    emailVerified?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    defaultCaseMode?: true
    hasSeenMigrationNotice?: true
    isSystemUser?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    passwordHash?: true
    passwordAlgorithm?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    authProvider?: true
    githubId?: true
    githubUsername?: true
    emailVerified?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    defaultCaseMode?: true
    hasSeenMigrationNotice?: true
    isSystemUser?: true
    createdAt?: true
    updatedAt?: true
    lastLoginAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    passwordHash: string | null
    passwordAlgorithm: string
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    authProvider: $Enums.AuthProvider
    githubId: string | null
    githubUsername: string | null
    emailVerified: boolean
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    defaultCaseMode: $Enums.CaseMode
    hasSeenMigrationNotice: boolean
    isSystemUser: boolean
    createdAt: Date
    updatedAt: Date
    lastLoginAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    passwordAlgorithm?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    authProvider?: boolean
    githubId?: boolean
    githubUsername?: boolean
    emailVerified?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    defaultCaseMode?: boolean
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    createdTeams?: boolean | User$createdTeamsArgs<ExtArgs>
    createdCases?: boolean | User$createdCasesArgs<ExtArgs>
    casePermissions?: boolean | User$casePermissionsArgs<ExtArgs>
    grantedPermissions?: boolean | User$grantedPermissionsArgs<ExtArgs>
    createdElements?: boolean | User$createdElementsArgs<ExtArgs>
    authoredComments?: boolean | User$authoredCommentsArgs<ExtArgs>
    resolvedComments?: boolean | User$resolvedCommentsArgs<ExtArgs>
    releaseComments?: boolean | User$releaseCommentsArgs<ExtArgs>
    githubRepositories?: boolean | User$githubRepositoriesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    caseStudies?: boolean | User$caseStudiesArgs<ExtArgs>
    markedReadyCases?: boolean | User$markedReadyCasesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    passwordAlgorithm?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    authProvider?: boolean
    githubId?: boolean
    githubUsername?: boolean
    emailVerified?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    defaultCaseMode?: boolean
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    passwordAlgorithm?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    authProvider?: boolean
    githubId?: boolean
    githubUsername?: boolean
    emailVerified?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    defaultCaseMode?: boolean
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    passwordHash?: boolean
    passwordAlgorithm?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    authProvider?: boolean
    githubId?: boolean
    githubUsername?: boolean
    emailVerified?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    defaultCaseMode?: boolean
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLoginAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "passwordHash" | "passwordAlgorithm" | "firstName" | "lastName" | "avatarUrl" | "authProvider" | "githubId" | "githubUsername" | "emailVerified" | "passwordResetToken" | "passwordResetExpires" | "defaultCaseMode" | "hasSeenMigrationNotice" | "isSystemUser" | "createdAt" | "updatedAt" | "lastLoginAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    createdTeams?: boolean | User$createdTeamsArgs<ExtArgs>
    createdCases?: boolean | User$createdCasesArgs<ExtArgs>
    casePermissions?: boolean | User$casePermissionsArgs<ExtArgs>
    grantedPermissions?: boolean | User$grantedPermissionsArgs<ExtArgs>
    createdElements?: boolean | User$createdElementsArgs<ExtArgs>
    authoredComments?: boolean | User$authoredCommentsArgs<ExtArgs>
    resolvedComments?: boolean | User$resolvedCommentsArgs<ExtArgs>
    releaseComments?: boolean | User$releaseCommentsArgs<ExtArgs>
    githubRepositories?: boolean | User$githubRepositoriesArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    caseStudies?: boolean | User$caseStudiesArgs<ExtArgs>
    markedReadyCases?: boolean | User$markedReadyCasesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      teamMemberships: Prisma.$TeamMemberPayload<ExtArgs>[]
      createdTeams: Prisma.$TeamPayload<ExtArgs>[]
      createdCases: Prisma.$AssuranceCasePayload<ExtArgs>[]
      casePermissions: Prisma.$CasePermissionPayload<ExtArgs>[]
      grantedPermissions: Prisma.$CasePermissionPayload<ExtArgs>[]
      createdElements: Prisma.$AssuranceElementPayload<ExtArgs>[]
      authoredComments: Prisma.$CommentPayload<ExtArgs>[]
      resolvedComments: Prisma.$CommentPayload<ExtArgs>[]
      releaseComments: Prisma.$ReleaseCommentPayload<ExtArgs>[]
      githubRepositories: Prisma.$GitHubRepositoryPayload<ExtArgs>[]
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      caseStudies: Prisma.$CaseStudyPayload<ExtArgs>[]
      markedReadyCases: Prisma.$AssuranceCasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      passwordHash: string | null
      passwordAlgorithm: string
      firstName: string | null
      lastName: string | null
      avatarUrl: string | null
      authProvider: $Enums.AuthProvider
      githubId: string | null
      githubUsername: string | null
      emailVerified: boolean
      passwordResetToken: string | null
      passwordResetExpires: Date | null
      defaultCaseMode: $Enums.CaseMode
      hasSeenMigrationNotice: boolean
      isSystemUser: boolean
      createdAt: Date
      updatedAt: Date
      lastLoginAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdTeams<T extends User$createdTeamsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdCases<T extends User$createdCasesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    casePermissions<T extends User$casePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$casePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grantedPermissions<T extends User$grantedPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$grantedPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdElements<T extends User$createdElementsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdElementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    authoredComments<T extends User$authoredCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$authoredCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    resolvedComments<T extends User$resolvedCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$resolvedCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    releaseComments<T extends User$releaseCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$releaseCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    githubRepositories<T extends User$githubRepositoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$githubRepositoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    caseStudies<T extends User$caseStudiesArgs<ExtArgs> = {}>(args?: Subset<T, User$caseStudiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    markedReadyCases<T extends User$markedReadyCasesArgs<ExtArgs> = {}>(args?: Subset<T, User$markedReadyCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly passwordAlgorithm: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly authProvider: FieldRef<"User", 'AuthProvider'>
    readonly githubId: FieldRef<"User", 'String'>
    readonly githubUsername: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpires: FieldRef<"User", 'DateTime'>
    readonly defaultCaseMode: FieldRef<"User", 'CaseMode'>
    readonly hasSeenMigrationNotice: FieldRef<"User", 'Boolean'>
    readonly isSystemUser: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.createdTeams
   */
  export type User$createdTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.createdCases
   */
  export type User$createdCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    where?: AssuranceCaseWhereInput
    orderBy?: AssuranceCaseOrderByWithRelationInput | AssuranceCaseOrderByWithRelationInput[]
    cursor?: AssuranceCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssuranceCaseScalarFieldEnum | AssuranceCaseScalarFieldEnum[]
  }

  /**
   * User.casePermissions
   */
  export type User$casePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    where?: CasePermissionWhereInput
    orderBy?: CasePermissionOrderByWithRelationInput | CasePermissionOrderByWithRelationInput[]
    cursor?: CasePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CasePermissionScalarFieldEnum | CasePermissionScalarFieldEnum[]
  }

  /**
   * User.grantedPermissions
   */
  export type User$grantedPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    where?: CasePermissionWhereInput
    orderBy?: CasePermissionOrderByWithRelationInput | CasePermissionOrderByWithRelationInput[]
    cursor?: CasePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CasePermissionScalarFieldEnum | CasePermissionScalarFieldEnum[]
  }

  /**
   * User.createdElements
   */
  export type User$createdElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    where?: AssuranceElementWhereInput
    orderBy?: AssuranceElementOrderByWithRelationInput | AssuranceElementOrderByWithRelationInput[]
    cursor?: AssuranceElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssuranceElementScalarFieldEnum | AssuranceElementScalarFieldEnum[]
  }

  /**
   * User.authoredComments
   */
  export type User$authoredCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.resolvedComments
   */
  export type User$resolvedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.releaseComments
   */
  export type User$releaseCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    where?: ReleaseCommentWhereInput
    orderBy?: ReleaseCommentOrderByWithRelationInput | ReleaseCommentOrderByWithRelationInput[]
    cursor?: ReleaseCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReleaseCommentScalarFieldEnum | ReleaseCommentScalarFieldEnum[]
  }

  /**
   * User.githubRepositories
   */
  export type User$githubRepositoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    where?: GitHubRepositoryWhereInput
    orderBy?: GitHubRepositoryOrderByWithRelationInput | GitHubRepositoryOrderByWithRelationInput[]
    cursor?: GitHubRepositoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GitHubRepositoryScalarFieldEnum | GitHubRepositoryScalarFieldEnum[]
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.caseStudies
   */
  export type User$caseStudiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    where?: CaseStudyWhereInput
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    cursor?: CaseStudyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * User.markedReadyCases
   */
  export type User$markedReadyCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    where?: AssuranceCaseWhereInput
    orderBy?: AssuranceCaseOrderByWithRelationInput | AssuranceCaseOrderByWithRelationInput[]
    cursor?: AssuranceCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssuranceCaseScalarFieldEnum | AssuranceCaseScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
    userAgent: string | null
    ipAddress: string | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    userId: string | null
    expiresAt: Date | null
    createdAt: Date | null
    revokedAt: Date | null
    userAgent: string | null
    ipAddress: string | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    token: number
    userId: number
    expiresAt: number
    createdAt: number
    revokedAt: number
    userAgent: number
    ipAddress: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    userAgent?: true
    ipAddress?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    userAgent?: true
    ipAddress?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    token?: true
    userId?: true
    expiresAt?: true
    createdAt?: true
    revokedAt?: true
    userAgent?: true
    ipAddress?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    token: string
    userId: string
    expiresAt: Date
    createdAt: Date
    revokedAt: Date | null
    userAgent: string | null
    ipAddress: string | null
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    token?: boolean
    userId?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    userAgent?: boolean
    ipAddress?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "userId" | "expiresAt" | "createdAt" | "revokedAt" | "userAgent" | "ipAddress", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      userId: string
      expiresAt: Date
      createdAt: Date
      revokedAt: Date | null
      userAgent: string | null
      ipAddress: string | null
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     *
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     *
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     *
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly userAgent: FieldRef<"RefreshToken", 'String'>
    readonly ipAddress: FieldRef<"RefreshToken", 'String'>
  }


  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetAttempt
   */

  export type AggregatePasswordResetAttempt = {
    _count: PasswordResetAttemptCountAggregateOutputType | null
    _min: PasswordResetAttemptMinAggregateOutputType | null
    _max: PasswordResetAttemptMaxAggregateOutputType | null
  }

  export type PasswordResetAttemptMinAggregateOutputType = {
    id: string | null
    email: string | null
    ipAddress: string | null
    attemptedAt: Date | null
    successful: boolean | null
  }

  export type PasswordResetAttemptMaxAggregateOutputType = {
    id: string | null
    email: string | null
    ipAddress: string | null
    attemptedAt: Date | null
    successful: boolean | null
  }

  export type PasswordResetAttemptCountAggregateOutputType = {
    id: number
    email: number
    ipAddress: number
    attemptedAt: number
    successful: number
    _all: number
  }


  export type PasswordResetAttemptMinAggregateInputType = {
    id?: true
    email?: true
    ipAddress?: true
    attemptedAt?: true
    successful?: true
  }

  export type PasswordResetAttemptMaxAggregateInputType = {
    id?: true
    email?: true
    ipAddress?: true
    attemptedAt?: true
    successful?: true
  }

  export type PasswordResetAttemptCountAggregateInputType = {
    id?: true
    email?: true
    ipAddress?: true
    attemptedAt?: true
    successful?: true
    _all?: true
  }

  export type PasswordResetAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetAttempt to aggregate.
     */
    where?: PasswordResetAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PasswordResetAttempts to fetch.
     */
    orderBy?: PasswordResetAttemptOrderByWithRelationInput | PasswordResetAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PasswordResetAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PasswordResetAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PasswordResetAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PasswordResetAttempts
    **/
    _count?: true | PasswordResetAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetAttemptMaxAggregateInputType
  }

  export type GetPasswordResetAttemptAggregateType<T extends PasswordResetAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetAttempt[P]>
      : GetScalarType<T[P], AggregatePasswordResetAttempt[P]>
  }




  export type PasswordResetAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetAttemptWhereInput
    orderBy?: PasswordResetAttemptOrderByWithAggregationInput | PasswordResetAttemptOrderByWithAggregationInput[]
    by: PasswordResetAttemptScalarFieldEnum[] | PasswordResetAttemptScalarFieldEnum
    having?: PasswordResetAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetAttemptCountAggregateInputType | true
    _min?: PasswordResetAttemptMinAggregateInputType
    _max?: PasswordResetAttemptMaxAggregateInputType
  }

  export type PasswordResetAttemptGroupByOutputType = {
    id: string
    email: string
    ipAddress: string
    attemptedAt: Date
    successful: boolean
    _count: PasswordResetAttemptCountAggregateOutputType | null
    _min: PasswordResetAttemptMinAggregateOutputType | null
    _max: PasswordResetAttemptMaxAggregateOutputType | null
  }

  type GetPasswordResetAttemptGroupByPayload<T extends PasswordResetAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetAttemptGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    ipAddress?: boolean
    attemptedAt?: boolean
    successful?: boolean
  }, ExtArgs["result"]["passwordResetAttempt"]>

  export type PasswordResetAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    ipAddress?: boolean
    attemptedAt?: boolean
    successful?: boolean
  }, ExtArgs["result"]["passwordResetAttempt"]>

  export type PasswordResetAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    ipAddress?: boolean
    attemptedAt?: boolean
    successful?: boolean
  }, ExtArgs["result"]["passwordResetAttempt"]>

  export type PasswordResetAttemptSelectScalar = {
    id?: boolean
    email?: boolean
    ipAddress?: boolean
    attemptedAt?: boolean
    successful?: boolean
  }

  export type PasswordResetAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "ipAddress" | "attemptedAt" | "successful", ExtArgs["result"]["passwordResetAttempt"]>

  export type $PasswordResetAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetAttempt"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      ipAddress: string
      attemptedAt: Date
      successful: boolean
    }, ExtArgs["result"]["passwordResetAttempt"]>
    composites: {}
  }

  type PasswordResetAttemptGetPayload<S extends boolean | null | undefined | PasswordResetAttemptDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetAttemptPayload, S>

  type PasswordResetAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetAttemptCountAggregateInputType | true
    }

  export interface PasswordResetAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetAttempt'], meta: { name: 'PasswordResetAttempt' } }
    /**
     * Find zero or one PasswordResetAttempt that matches the filter.
     * @param {PasswordResetAttemptFindUniqueArgs} args - Arguments to find a PasswordResetAttempt
     * @example
     * // Get one PasswordResetAttempt
     * const passwordResetAttempt = await prisma.passwordResetAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetAttemptFindUniqueArgs>(args: SelectSubset<T, PasswordResetAttemptFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetAttemptClient<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetAttemptFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetAttempt
     * @example
     * // Get one PasswordResetAttempt
     * const passwordResetAttempt = await prisma.passwordResetAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetAttemptClient<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAttemptFindFirstArgs} args - Arguments to find a PasswordResetAttempt
     * @example
     * // Get one PasswordResetAttempt
     * const passwordResetAttempt = await prisma.passwordResetAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetAttemptFindFirstArgs>(args?: SelectSubset<T, PasswordResetAttemptFindFirstArgs<ExtArgs>>): Prisma__PasswordResetAttemptClient<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAttemptFindFirstOrThrowArgs} args - Arguments to find a PasswordResetAttempt
     * @example
     * // Get one PasswordResetAttempt
     * const passwordResetAttempt = await prisma.passwordResetAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetAttemptClient<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetAttempts
     * const passwordResetAttempts = await prisma.passwordResetAttempt.findMany()
     *
     * // Get first 10 PasswordResetAttempts
     * const passwordResetAttempts = await prisma.passwordResetAttempt.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const passwordResetAttemptWithIdOnly = await prisma.passwordResetAttempt.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PasswordResetAttemptFindManyArgs>(args?: SelectSubset<T, PasswordResetAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetAttempt.
     * @param {PasswordResetAttemptCreateArgs} args - Arguments to create a PasswordResetAttempt.
     * @example
     * // Create one PasswordResetAttempt
     * const PasswordResetAttempt = await prisma.passwordResetAttempt.create({
     *   data: {
     *     // ... data to create a PasswordResetAttempt
     *   }
     * })
     *
     */
    create<T extends PasswordResetAttemptCreateArgs>(args: SelectSubset<T, PasswordResetAttemptCreateArgs<ExtArgs>>): Prisma__PasswordResetAttemptClient<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetAttempts.
     * @param {PasswordResetAttemptCreateManyArgs} args - Arguments to create many PasswordResetAttempts.
     * @example
     * // Create many PasswordResetAttempts
     * const passwordResetAttempt = await prisma.passwordResetAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PasswordResetAttemptCreateManyArgs>(args?: SelectSubset<T, PasswordResetAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetAttempts and returns the data saved in the database.
     * @param {PasswordResetAttemptCreateManyAndReturnArgs} args - Arguments to create many PasswordResetAttempts.
     * @example
     * // Create many PasswordResetAttempts
     * const passwordResetAttempt = await prisma.passwordResetAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PasswordResetAttempts and only return the `id`
     * const passwordResetAttemptWithIdOnly = await prisma.passwordResetAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PasswordResetAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetAttempt.
     * @param {PasswordResetAttemptDeleteArgs} args - Arguments to delete one PasswordResetAttempt.
     * @example
     * // Delete one PasswordResetAttempt
     * const PasswordResetAttempt = await prisma.passwordResetAttempt.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetAttempt
     *   }
     * })
     *
     */
    delete<T extends PasswordResetAttemptDeleteArgs>(args: SelectSubset<T, PasswordResetAttemptDeleteArgs<ExtArgs>>): Prisma__PasswordResetAttemptClient<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetAttempt.
     * @param {PasswordResetAttemptUpdateArgs} args - Arguments to update one PasswordResetAttempt.
     * @example
     * // Update one PasswordResetAttempt
     * const passwordResetAttempt = await prisma.passwordResetAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PasswordResetAttemptUpdateArgs>(args: SelectSubset<T, PasswordResetAttemptUpdateArgs<ExtArgs>>): Prisma__PasswordResetAttemptClient<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetAttempts.
     * @param {PasswordResetAttemptDeleteManyArgs} args - Arguments to filter PasswordResetAttempts to delete.
     * @example
     * // Delete a few PasswordResetAttempts
     * const { count } = await prisma.passwordResetAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PasswordResetAttemptDeleteManyArgs>(args?: SelectSubset<T, PasswordResetAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetAttempts
     * const passwordResetAttempt = await prisma.passwordResetAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PasswordResetAttemptUpdateManyArgs>(args: SelectSubset<T, PasswordResetAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetAttempts and returns the data updated in the database.
     * @param {PasswordResetAttemptUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetAttempts.
     * @example
     * // Update many PasswordResetAttempts
     * const passwordResetAttempt = await prisma.passwordResetAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PasswordResetAttempts and only return the `id`
     * const passwordResetAttemptWithIdOnly = await prisma.passwordResetAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PasswordResetAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetAttempt.
     * @param {PasswordResetAttemptUpsertArgs} args - Arguments to update or create a PasswordResetAttempt.
     * @example
     * // Update or create a PasswordResetAttempt
     * const passwordResetAttempt = await prisma.passwordResetAttempt.upsert({
     *   create: {
     *     // ... data to create a PasswordResetAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetAttempt we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetAttemptUpsertArgs>(args: SelectSubset<T, PasswordResetAttemptUpsertArgs<ExtArgs>>): Prisma__PasswordResetAttemptClient<$Result.GetResult<Prisma.$PasswordResetAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAttemptCountArgs} args - Arguments to filter PasswordResetAttempts to count.
     * @example
     * // Count the number of PasswordResetAttempts
     * const count = await prisma.passwordResetAttempt.count({
     *   where: {
     *     // ... the filter for the PasswordResetAttempts we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetAttemptCountArgs>(
      args?: Subset<T, PasswordResetAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAttemptAggregateArgs>(args: Subset<T, PasswordResetAttemptAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAttemptAggregateType<T>>

    /**
     * Group by PasswordResetAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends PasswordResetAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetAttemptGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetAttempt model
   */
  readonly fields: PasswordResetAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetAttempt model
   */
  interface PasswordResetAttemptFieldRefs {
    readonly id: FieldRef<"PasswordResetAttempt", 'String'>
    readonly email: FieldRef<"PasswordResetAttempt", 'String'>
    readonly ipAddress: FieldRef<"PasswordResetAttempt", 'String'>
    readonly attemptedAt: FieldRef<"PasswordResetAttempt", 'DateTime'>
    readonly successful: FieldRef<"PasswordResetAttempt", 'Boolean'>
  }


  // Custom InputTypes
  /**
   * PasswordResetAttempt findUnique
   */
  export type PasswordResetAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetAttempt to fetch.
     */
    where: PasswordResetAttemptWhereUniqueInput
  }

  /**
   * PasswordResetAttempt findUniqueOrThrow
   */
  export type PasswordResetAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetAttempt to fetch.
     */
    where: PasswordResetAttemptWhereUniqueInput
  }

  /**
   * PasswordResetAttempt findFirst
   */
  export type PasswordResetAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetAttempt to fetch.
     */
    where?: PasswordResetAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PasswordResetAttempts to fetch.
     */
    orderBy?: PasswordResetAttemptOrderByWithRelationInput | PasswordResetAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PasswordResetAttempts.
     */
    cursor?: PasswordResetAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PasswordResetAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PasswordResetAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PasswordResetAttempts.
     */
    distinct?: PasswordResetAttemptScalarFieldEnum | PasswordResetAttemptScalarFieldEnum[]
  }

  /**
   * PasswordResetAttempt findFirstOrThrow
   */
  export type PasswordResetAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetAttempt to fetch.
     */
    where?: PasswordResetAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PasswordResetAttempts to fetch.
     */
    orderBy?: PasswordResetAttemptOrderByWithRelationInput | PasswordResetAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PasswordResetAttempts.
     */
    cursor?: PasswordResetAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PasswordResetAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PasswordResetAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PasswordResetAttempts.
     */
    distinct?: PasswordResetAttemptScalarFieldEnum | PasswordResetAttemptScalarFieldEnum[]
  }

  /**
   * PasswordResetAttempt findMany
   */
  export type PasswordResetAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetAttempts to fetch.
     */
    where?: PasswordResetAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PasswordResetAttempts to fetch.
     */
    orderBy?: PasswordResetAttemptOrderByWithRelationInput | PasswordResetAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PasswordResetAttempts.
     */
    cursor?: PasswordResetAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PasswordResetAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PasswordResetAttempts.
     */
    skip?: number
    distinct?: PasswordResetAttemptScalarFieldEnum | PasswordResetAttemptScalarFieldEnum[]
  }

  /**
   * PasswordResetAttempt create
   */
  export type PasswordResetAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetAttempt.
     */
    data: XOR<PasswordResetAttemptCreateInput, PasswordResetAttemptUncheckedCreateInput>
  }

  /**
   * PasswordResetAttempt createMany
   */
  export type PasswordResetAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetAttempts.
     */
    data: PasswordResetAttemptCreateManyInput | PasswordResetAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetAttempt createManyAndReturn
   */
  export type PasswordResetAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetAttempts.
     */
    data: PasswordResetAttemptCreateManyInput | PasswordResetAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetAttempt update
   */
  export type PasswordResetAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetAttempt.
     */
    data: XOR<PasswordResetAttemptUpdateInput, PasswordResetAttemptUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetAttempt to update.
     */
    where: PasswordResetAttemptWhereUniqueInput
  }

  /**
   * PasswordResetAttempt updateMany
   */
  export type PasswordResetAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetAttempts.
     */
    data: XOR<PasswordResetAttemptUpdateManyMutationInput, PasswordResetAttemptUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetAttempts to update
     */
    where?: PasswordResetAttemptWhereInput
    /**
     * Limit how many PasswordResetAttempts to update.
     */
    limit?: number
  }

  /**
   * PasswordResetAttempt updateManyAndReturn
   */
  export type PasswordResetAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetAttempts.
     */
    data: XOR<PasswordResetAttemptUpdateManyMutationInput, PasswordResetAttemptUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetAttempts to update
     */
    where?: PasswordResetAttemptWhereInput
    /**
     * Limit how many PasswordResetAttempts to update.
     */
    limit?: number
  }

  /**
   * PasswordResetAttempt upsert
   */
  export type PasswordResetAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetAttempt to update in case it exists.
     */
    where: PasswordResetAttemptWhereUniqueInput
    /**
     * In case the PasswordResetAttempt found by the `where` argument doesn't exist, create a new PasswordResetAttempt with this data.
     */
    create: XOR<PasswordResetAttemptCreateInput, PasswordResetAttemptUncheckedCreateInput>
    /**
     * In case the PasswordResetAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetAttemptUpdateInput, PasswordResetAttemptUncheckedUpdateInput>
  }

  /**
   * PasswordResetAttempt delete
   */
  export type PasswordResetAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
    /**
     * Filter which PasswordResetAttempt to delete.
     */
    where: PasswordResetAttemptWhereUniqueInput
  }

  /**
   * PasswordResetAttempt deleteMany
   */
  export type PasswordResetAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetAttempts to delete
     */
    where?: PasswordResetAttemptWhereInput
    /**
     * Limit how many PasswordResetAttempts to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetAttempt without action
   */
  export type PasswordResetAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetAttempt
     */
    select?: PasswordResetAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetAttempt
     */
    omit?: PasswordResetAttemptOmit<ExtArgs> | null
  }


  /**
   * Model SecurityAuditLog
   */

  export type AggregateSecurityAuditLog = {
    _count: SecurityAuditLogCountAggregateOutputType | null
    _min: SecurityAuditLogMinAggregateOutputType | null
    _max: SecurityAuditLogMaxAggregateOutputType | null
  }

  export type SecurityAuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SecurityAuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    eventType: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type SecurityAuditLogCountAggregateOutputType = {
    id: number
    userId: number
    eventType: number
    ipAddress: number
    userAgent: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type SecurityAuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SecurityAuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type SecurityAuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    eventType?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type SecurityAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAuditLog to aggregate.
     */
    where?: SecurityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SecurityAuditLogs to fetch.
     */
    orderBy?: SecurityAuditLogOrderByWithRelationInput | SecurityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: SecurityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SecurityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SecurityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned SecurityAuditLogs
    **/
    _count?: true | SecurityAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: SecurityAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: SecurityAuditLogMaxAggregateInputType
  }

  export type GetSecurityAuditLogAggregateType<T extends SecurityAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateSecurityAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSecurityAuditLog[P]>
      : GetScalarType<T[P], AggregateSecurityAuditLog[P]>
  }




  export type SecurityAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SecurityAuditLogWhereInput
    orderBy?: SecurityAuditLogOrderByWithAggregationInput | SecurityAuditLogOrderByWithAggregationInput[]
    by: SecurityAuditLogScalarFieldEnum[] | SecurityAuditLogScalarFieldEnum
    having?: SecurityAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SecurityAuditLogCountAggregateInputType | true
    _min?: SecurityAuditLogMinAggregateInputType
    _max?: SecurityAuditLogMaxAggregateInputType
  }

  export type SecurityAuditLogGroupByOutputType = {
    id: string
    userId: string | null
    eventType: string
    ipAddress: string | null
    userAgent: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: SecurityAuditLogCountAggregateOutputType | null
    _min: SecurityAuditLogMinAggregateOutputType | null
    _max: SecurityAuditLogMaxAggregateOutputType | null
  }

  type GetSecurityAuditLogGroupByPayload<T extends SecurityAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SecurityAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SecurityAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SecurityAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], SecurityAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type SecurityAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityAuditLog"]>

  export type SecurityAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityAuditLog"]>

  export type SecurityAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    eventType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["securityAuditLog"]>

  export type SecurityAuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    eventType?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type SecurityAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "eventType" | "ipAddress" | "userAgent" | "metadata" | "createdAt", ExtArgs["result"]["securityAuditLog"]>

  export type $SecurityAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SecurityAuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      eventType: string
      ipAddress: string | null
      userAgent: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["securityAuditLog"]>
    composites: {}
  }

  type SecurityAuditLogGetPayload<S extends boolean | null | undefined | SecurityAuditLogDefaultArgs> = $Result.GetResult<Prisma.$SecurityAuditLogPayload, S>

  type SecurityAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SecurityAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SecurityAuditLogCountAggregateInputType | true
    }

  export interface SecurityAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SecurityAuditLog'], meta: { name: 'SecurityAuditLog' } }
    /**
     * Find zero or one SecurityAuditLog that matches the filter.
     * @param {SecurityAuditLogFindUniqueArgs} args - Arguments to find a SecurityAuditLog
     * @example
     * // Get one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SecurityAuditLogFindUniqueArgs>(args: SelectSubset<T, SecurityAuditLogFindUniqueArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SecurityAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SecurityAuditLogFindUniqueOrThrowArgs} args - Arguments to find a SecurityAuditLog
     * @example
     * // Get one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SecurityAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, SecurityAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogFindFirstArgs} args - Arguments to find a SecurityAuditLog
     * @example
     * // Get one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SecurityAuditLogFindFirstArgs>(args?: SelectSubset<T, SecurityAuditLogFindFirstArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SecurityAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogFindFirstOrThrowArgs} args - Arguments to find a SecurityAuditLog
     * @example
     * // Get one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SecurityAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, SecurityAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SecurityAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SecurityAuditLogs
     * const securityAuditLogs = await prisma.securityAuditLog.findMany()
     *
     * // Get first 10 SecurityAuditLogs
     * const securityAuditLogs = await prisma.securityAuditLog.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const securityAuditLogWithIdOnly = await prisma.securityAuditLog.findMany({ select: { id: true } })
     *
     */
    findMany<T extends SecurityAuditLogFindManyArgs>(args?: SelectSubset<T, SecurityAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SecurityAuditLog.
     * @param {SecurityAuditLogCreateArgs} args - Arguments to create a SecurityAuditLog.
     * @example
     * // Create one SecurityAuditLog
     * const SecurityAuditLog = await prisma.securityAuditLog.create({
     *   data: {
     *     // ... data to create a SecurityAuditLog
     *   }
     * })
     *
     */
    create<T extends SecurityAuditLogCreateArgs>(args: SelectSubset<T, SecurityAuditLogCreateArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SecurityAuditLogs.
     * @param {SecurityAuditLogCreateManyArgs} args - Arguments to create many SecurityAuditLogs.
     * @example
     * // Create many SecurityAuditLogs
     * const securityAuditLog = await prisma.securityAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends SecurityAuditLogCreateManyArgs>(args?: SelectSubset<T, SecurityAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SecurityAuditLogs and returns the data saved in the database.
     * @param {SecurityAuditLogCreateManyAndReturnArgs} args - Arguments to create many SecurityAuditLogs.
     * @example
     * // Create many SecurityAuditLogs
     * const securityAuditLog = await prisma.securityAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many SecurityAuditLogs and only return the `id`
     * const securityAuditLogWithIdOnly = await prisma.securityAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends SecurityAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, SecurityAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SecurityAuditLog.
     * @param {SecurityAuditLogDeleteArgs} args - Arguments to delete one SecurityAuditLog.
     * @example
     * // Delete one SecurityAuditLog
     * const SecurityAuditLog = await prisma.securityAuditLog.delete({
     *   where: {
     *     // ... filter to delete one SecurityAuditLog
     *   }
     * })
     *
     */
    delete<T extends SecurityAuditLogDeleteArgs>(args: SelectSubset<T, SecurityAuditLogDeleteArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SecurityAuditLog.
     * @param {SecurityAuditLogUpdateArgs} args - Arguments to update one SecurityAuditLog.
     * @example
     * // Update one SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends SecurityAuditLogUpdateArgs>(args: SelectSubset<T, SecurityAuditLogUpdateArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SecurityAuditLogs.
     * @param {SecurityAuditLogDeleteManyArgs} args - Arguments to filter SecurityAuditLogs to delete.
     * @example
     * // Delete a few SecurityAuditLogs
     * const { count } = await prisma.securityAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends SecurityAuditLogDeleteManyArgs>(args?: SelectSubset<T, SecurityAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SecurityAuditLogs
     * const securityAuditLog = await prisma.securityAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends SecurityAuditLogUpdateManyArgs>(args: SelectSubset<T, SecurityAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SecurityAuditLogs and returns the data updated in the database.
     * @param {SecurityAuditLogUpdateManyAndReturnArgs} args - Arguments to update many SecurityAuditLogs.
     * @example
     * // Update many SecurityAuditLogs
     * const securityAuditLog = await prisma.securityAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more SecurityAuditLogs and only return the `id`
     * const securityAuditLogWithIdOnly = await prisma.securityAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends SecurityAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, SecurityAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SecurityAuditLog.
     * @param {SecurityAuditLogUpsertArgs} args - Arguments to update or create a SecurityAuditLog.
     * @example
     * // Update or create a SecurityAuditLog
     * const securityAuditLog = await prisma.securityAuditLog.upsert({
     *   create: {
     *     // ... data to create a SecurityAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SecurityAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends SecurityAuditLogUpsertArgs>(args: SelectSubset<T, SecurityAuditLogUpsertArgs<ExtArgs>>): Prisma__SecurityAuditLogClient<$Result.GetResult<Prisma.$SecurityAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SecurityAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogCountArgs} args - Arguments to filter SecurityAuditLogs to count.
     * @example
     * // Count the number of SecurityAuditLogs
     * const count = await prisma.securityAuditLog.count({
     *   where: {
     *     // ... the filter for the SecurityAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends SecurityAuditLogCountArgs>(
      args?: Subset<T, SecurityAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SecurityAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SecurityAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SecurityAuditLogAggregateArgs>(args: Subset<T, SecurityAuditLogAggregateArgs>): Prisma.PrismaPromise<GetSecurityAuditLogAggregateType<T>>

    /**
     * Group by SecurityAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SecurityAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends SecurityAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SecurityAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: SecurityAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SecurityAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSecurityAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SecurityAuditLog model
   */
  readonly fields: SecurityAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SecurityAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SecurityAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SecurityAuditLog model
   */
  interface SecurityAuditLogFieldRefs {
    readonly id: FieldRef<"SecurityAuditLog", 'String'>
    readonly userId: FieldRef<"SecurityAuditLog", 'String'>
    readonly eventType: FieldRef<"SecurityAuditLog", 'String'>
    readonly ipAddress: FieldRef<"SecurityAuditLog", 'String'>
    readonly userAgent: FieldRef<"SecurityAuditLog", 'String'>
    readonly metadata: FieldRef<"SecurityAuditLog", 'Json'>
    readonly createdAt: FieldRef<"SecurityAuditLog", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * SecurityAuditLog findUnique
   */
  export type SecurityAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLog to fetch.
     */
    where: SecurityAuditLogWhereUniqueInput
  }

  /**
   * SecurityAuditLog findUniqueOrThrow
   */
  export type SecurityAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLog to fetch.
     */
    where: SecurityAuditLogWhereUniqueInput
  }

  /**
   * SecurityAuditLog findFirst
   */
  export type SecurityAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLog to fetch.
     */
    where?: SecurityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SecurityAuditLogs to fetch.
     */
    orderBy?: SecurityAuditLogOrderByWithRelationInput | SecurityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SecurityAuditLogs.
     */
    cursor?: SecurityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SecurityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SecurityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SecurityAuditLogs.
     */
    distinct?: SecurityAuditLogScalarFieldEnum | SecurityAuditLogScalarFieldEnum[]
  }

  /**
   * SecurityAuditLog findFirstOrThrow
   */
  export type SecurityAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLog to fetch.
     */
    where?: SecurityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SecurityAuditLogs to fetch.
     */
    orderBy?: SecurityAuditLogOrderByWithRelationInput | SecurityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for SecurityAuditLogs.
     */
    cursor?: SecurityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SecurityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SecurityAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of SecurityAuditLogs.
     */
    distinct?: SecurityAuditLogScalarFieldEnum | SecurityAuditLogScalarFieldEnum[]
  }

  /**
   * SecurityAuditLog findMany
   */
  export type SecurityAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter, which SecurityAuditLogs to fetch.
     */
    where?: SecurityAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of SecurityAuditLogs to fetch.
     */
    orderBy?: SecurityAuditLogOrderByWithRelationInput | SecurityAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing SecurityAuditLogs.
     */
    cursor?: SecurityAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` SecurityAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` SecurityAuditLogs.
     */
    skip?: number
    distinct?: SecurityAuditLogScalarFieldEnum | SecurityAuditLogScalarFieldEnum[]
  }

  /**
   * SecurityAuditLog create
   */
  export type SecurityAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to create a SecurityAuditLog.
     */
    data: XOR<SecurityAuditLogCreateInput, SecurityAuditLogUncheckedCreateInput>
  }

  /**
   * SecurityAuditLog createMany
   */
  export type SecurityAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SecurityAuditLogs.
     */
    data: SecurityAuditLogCreateManyInput | SecurityAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityAuditLog createManyAndReturn
   */
  export type SecurityAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many SecurityAuditLogs.
     */
    data: SecurityAuditLogCreateManyInput | SecurityAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SecurityAuditLog update
   */
  export type SecurityAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The data needed to update a SecurityAuditLog.
     */
    data: XOR<SecurityAuditLogUpdateInput, SecurityAuditLogUncheckedUpdateInput>
    /**
     * Choose, which SecurityAuditLog to update.
     */
    where: SecurityAuditLogWhereUniqueInput
  }

  /**
   * SecurityAuditLog updateMany
   */
  export type SecurityAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SecurityAuditLogs.
     */
    data: XOR<SecurityAuditLogUpdateManyMutationInput, SecurityAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAuditLogs to update
     */
    where?: SecurityAuditLogWhereInput
    /**
     * Limit how many SecurityAuditLogs to update.
     */
    limit?: number
  }

  /**
   * SecurityAuditLog updateManyAndReturn
   */
  export type SecurityAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update SecurityAuditLogs.
     */
    data: XOR<SecurityAuditLogUpdateManyMutationInput, SecurityAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which SecurityAuditLogs to update
     */
    where?: SecurityAuditLogWhereInput
    /**
     * Limit how many SecurityAuditLogs to update.
     */
    limit?: number
  }

  /**
   * SecurityAuditLog upsert
   */
  export type SecurityAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * The filter to search for the SecurityAuditLog to update in case it exists.
     */
    where: SecurityAuditLogWhereUniqueInput
    /**
     * In case the SecurityAuditLog found by the `where` argument doesn't exist, create a new SecurityAuditLog with this data.
     */
    create: XOR<SecurityAuditLogCreateInput, SecurityAuditLogUncheckedCreateInput>
    /**
     * In case the SecurityAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SecurityAuditLogUpdateInput, SecurityAuditLogUncheckedUpdateInput>
  }

  /**
   * SecurityAuditLog delete
   */
  export type SecurityAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
    /**
     * Filter which SecurityAuditLog to delete.
     */
    where: SecurityAuditLogWhereUniqueInput
  }

  /**
   * SecurityAuditLog deleteMany
   */
  export type SecurityAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SecurityAuditLogs to delete
     */
    where?: SecurityAuditLogWhereInput
    /**
     * Limit how many SecurityAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * SecurityAuditLog without action
   */
  export type SecurityAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SecurityAuditLog
     */
    select?: SecurityAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SecurityAuditLog
     */
    omit?: SecurityAuditLogOmit<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    organisationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    organisationId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    organisationId: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    organisationId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    organisationId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    organisationId?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    organisationId: string | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    organisationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    casePermissions?: boolean | Team$casePermissionsArgs<ExtArgs>
    patternPermissions?: boolean | Team$patternPermissionsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    organisationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    organisationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    organisationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "organisationId" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    casePermissions?: boolean | Team$casePermissionsArgs<ExtArgs>
    patternPermissions?: boolean | Team$patternPermissionsArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
      casePermissions: Prisma.$CaseTeamPermissionPayload<ExtArgs>[]
      patternPermissions: Prisma.$PatternTeamPermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      organisationId: string | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     *
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     *
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     *
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    casePermissions<T extends Team$casePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Team$casePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patternPermissions<T extends Team$patternPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Team$patternPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly slug: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly organisationId: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
    readonly createdById: FieldRef<"Team", 'String'>
  }


  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team.casePermissions
   */
  export type Team$casePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    where?: CaseTeamPermissionWhereInput
    orderBy?: CaseTeamPermissionOrderByWithRelationInput | CaseTeamPermissionOrderByWithRelationInput[]
    cursor?: CaseTeamPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseTeamPermissionScalarFieldEnum | CaseTeamPermissionScalarFieldEnum[]
  }

  /**
   * Team.patternPermissions
   */
  export type Team$patternPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    where?: PatternTeamPermissionWhereInput
    orderBy?: PatternTeamPermissionOrderByWithRelationInput | PatternTeamPermissionOrderByWithRelationInput[]
    cursor?: PatternTeamPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternTeamPermissionScalarFieldEnum | PatternTeamPermissionScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: $Enums.TeamRole | null
    invitedById: string | null
    joinedAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    role: $Enums.TeamRole | null
    invitedById: string | null
    joinedAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    role: number
    invitedById: number
    joinedAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    invitedById?: true
    joinedAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    invitedById?: true
    joinedAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    role?: true
    invitedById?: true
    joinedAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    teamId: string
    userId: string
    role: $Enums.TeamRole
    invitedById: string | null
    joinedAt: Date
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    invitedById?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    invitedById?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    invitedById?: boolean
    joinedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>

  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    role?: boolean
    invitedById?: boolean
    joinedAt?: boolean
  }

  export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teamId" | "userId" | "role" | "invitedById" | "joinedAt", ExtArgs["result"]["teamMember"]>
  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeamMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      userId: string
      role: $Enums.TeamRole
      invitedById: string | null
      joinedAt: Date
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     *
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     *
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     *
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeamMembers and returns the data saved in the database.
     * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     *
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers and returns the data updated in the database.
     * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more TeamMembers and only return the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly userId: FieldRef<"TeamMember", 'String'>
    readonly role: FieldRef<"TeamMember", 'TeamRole'>
    readonly invitedById: FieldRef<"TeamMember", 'String'>
    readonly joinedAt: FieldRef<"TeamMember", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember createManyAndReturn
   */
  export type TeamMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
  }

  /**
   * TeamMember updateManyAndReturn
   */
  export type TeamMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
    /**
     * Limit how many TeamMembers to delete.
     */
    limit?: number
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeamMember
     */
    omit?: TeamMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model AssuranceCase
   */

  export type AggregateAssuranceCase = {
    _count: AssuranceCaseCountAggregateOutputType | null
    _min: AssuranceCaseMinAggregateOutputType | null
    _max: AssuranceCaseMaxAggregateOutputType | null
  }

  export type AssuranceCaseMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdById: string | null
    mode: $Enums.CaseMode | null
    colorProfile: string | null
    lockUuid: string | null
    lockedById: string | null
    lockedAt: Date | null
    sourcePatternId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    published: boolean | null
    publishedAt: Date | null
    publishStatus: $Enums.PublishStatus | null
    markedReadyAt: Date | null
    markedReadyById: string | null
  }

  export type AssuranceCaseMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    createdById: string | null
    mode: $Enums.CaseMode | null
    colorProfile: string | null
    lockUuid: string | null
    lockedById: string | null
    lockedAt: Date | null
    sourcePatternId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    published: boolean | null
    publishedAt: Date | null
    publishStatus: $Enums.PublishStatus | null
    markedReadyAt: Date | null
    markedReadyById: string | null
  }

  export type AssuranceCaseCountAggregateOutputType = {
    id: number
    name: number
    description: number
    createdById: number
    mode: number
    colorProfile: number
    lockUuid: number
    lockedById: number
    lockedAt: number
    sourcePatternId: number
    createdAt: number
    updatedAt: number
    published: number
    publishedAt: number
    publishStatus: number
    markedReadyAt: number
    markedReadyById: number
    _all: number
  }


  export type AssuranceCaseMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdById?: true
    mode?: true
    colorProfile?: true
    lockUuid?: true
    lockedById?: true
    lockedAt?: true
    sourcePatternId?: true
    createdAt?: true
    updatedAt?: true
    published?: true
    publishedAt?: true
    publishStatus?: true
    markedReadyAt?: true
    markedReadyById?: true
  }

  export type AssuranceCaseMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdById?: true
    mode?: true
    colorProfile?: true
    lockUuid?: true
    lockedById?: true
    lockedAt?: true
    sourcePatternId?: true
    createdAt?: true
    updatedAt?: true
    published?: true
    publishedAt?: true
    publishStatus?: true
    markedReadyAt?: true
    markedReadyById?: true
  }

  export type AssuranceCaseCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    createdById?: true
    mode?: true
    colorProfile?: true
    lockUuid?: true
    lockedById?: true
    lockedAt?: true
    sourcePatternId?: true
    createdAt?: true
    updatedAt?: true
    published?: true
    publishedAt?: true
    publishStatus?: true
    markedReadyAt?: true
    markedReadyById?: true
    _all?: true
  }

  export type AssuranceCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssuranceCase to aggregate.
     */
    where?: AssuranceCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssuranceCases to fetch.
     */
    orderBy?: AssuranceCaseOrderByWithRelationInput | AssuranceCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AssuranceCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssuranceCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssuranceCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AssuranceCases
    **/
    _count?: true | AssuranceCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: AssuranceCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: AssuranceCaseMaxAggregateInputType
  }

  export type GetAssuranceCaseAggregateType<T extends AssuranceCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateAssuranceCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssuranceCase[P]>
      : GetScalarType<T[P], AggregateAssuranceCase[P]>
  }




  export type AssuranceCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceCaseWhereInput
    orderBy?: AssuranceCaseOrderByWithAggregationInput | AssuranceCaseOrderByWithAggregationInput[]
    by: AssuranceCaseScalarFieldEnum[] | AssuranceCaseScalarFieldEnum
    having?: AssuranceCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssuranceCaseCountAggregateInputType | true
    _min?: AssuranceCaseMinAggregateInputType
    _max?: AssuranceCaseMaxAggregateInputType
  }

  export type AssuranceCaseGroupByOutputType = {
    id: string
    name: string
    description: string
    createdById: string
    mode: $Enums.CaseMode
    colorProfile: string
    lockUuid: string | null
    lockedById: string | null
    lockedAt: Date | null
    sourcePatternId: string | null
    createdAt: Date
    updatedAt: Date
    published: boolean
    publishedAt: Date | null
    publishStatus: $Enums.PublishStatus
    markedReadyAt: Date | null
    markedReadyById: string | null
    _count: AssuranceCaseCountAggregateOutputType | null
    _min: AssuranceCaseMinAggregateOutputType | null
    _max: AssuranceCaseMaxAggregateOutputType | null
  }

  type GetAssuranceCaseGroupByPayload<T extends AssuranceCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssuranceCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssuranceCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssuranceCaseGroupByOutputType[P]>
            : GetScalarType<T[P], AssuranceCaseGroupByOutputType[P]>
        }
      >
    >


  export type AssuranceCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdById?: boolean
    mode?: boolean
    colorProfile?: boolean
    lockUuid?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    sourcePatternId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    published?: boolean
    publishedAt?: boolean
    publishStatus?: boolean
    markedReadyAt?: boolean
    markedReadyById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    markedReadyBy?: boolean | AssuranceCase$markedReadyByArgs<ExtArgs>
    sourcePattern?: boolean | AssuranceCase$sourcePatternArgs<ExtArgs>
    elements?: boolean | AssuranceCase$elementsArgs<ExtArgs>
    userPermissions?: boolean | AssuranceCase$userPermissionsArgs<ExtArgs>
    teamPermissions?: boolean | AssuranceCase$teamPermissionsArgs<ExtArgs>
    invites?: boolean | AssuranceCase$invitesArgs<ExtArgs>
    comments?: boolean | AssuranceCase$commentsArgs<ExtArgs>
    caseImage?: boolean | AssuranceCase$caseImageArgs<ExtArgs>
    caseTypes?: boolean | AssuranceCase$caseTypesArgs<ExtArgs>
    sourceReleases?: boolean | AssuranceCase$sourceReleasesArgs<ExtArgs>
    publishedReleases?: boolean | AssuranceCase$publishedReleasesArgs<ExtArgs>
    publishedVersions?: boolean | AssuranceCase$publishedVersionsArgs<ExtArgs>
    embeddedIn?: boolean | AssuranceCase$embeddedInArgs<ExtArgs>
    _count?: boolean | AssuranceCaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assuranceCase"]>

  export type AssuranceCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdById?: boolean
    mode?: boolean
    colorProfile?: boolean
    lockUuid?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    sourcePatternId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    published?: boolean
    publishedAt?: boolean
    publishStatus?: boolean
    markedReadyAt?: boolean
    markedReadyById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    markedReadyBy?: boolean | AssuranceCase$markedReadyByArgs<ExtArgs>
    sourcePattern?: boolean | AssuranceCase$sourcePatternArgs<ExtArgs>
  }, ExtArgs["result"]["assuranceCase"]>

  export type AssuranceCaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    createdById?: boolean
    mode?: boolean
    colorProfile?: boolean
    lockUuid?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    sourcePatternId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    published?: boolean
    publishedAt?: boolean
    publishStatus?: boolean
    markedReadyAt?: boolean
    markedReadyById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    markedReadyBy?: boolean | AssuranceCase$markedReadyByArgs<ExtArgs>
    sourcePattern?: boolean | AssuranceCase$sourcePatternArgs<ExtArgs>
  }, ExtArgs["result"]["assuranceCase"]>

  export type AssuranceCaseSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    createdById?: boolean
    mode?: boolean
    colorProfile?: boolean
    lockUuid?: boolean
    lockedById?: boolean
    lockedAt?: boolean
    sourcePatternId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    published?: boolean
    publishedAt?: boolean
    publishStatus?: boolean
    markedReadyAt?: boolean
    markedReadyById?: boolean
  }

  export type AssuranceCaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "createdById" | "mode" | "colorProfile" | "lockUuid" | "lockedById" | "lockedAt" | "sourcePatternId" | "createdAt" | "updatedAt" | "published" | "publishedAt" | "publishStatus" | "markedReadyAt" | "markedReadyById", ExtArgs["result"]["assuranceCase"]>
  export type AssuranceCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    markedReadyBy?: boolean | AssuranceCase$markedReadyByArgs<ExtArgs>
    sourcePattern?: boolean | AssuranceCase$sourcePatternArgs<ExtArgs>
    elements?: boolean | AssuranceCase$elementsArgs<ExtArgs>
    userPermissions?: boolean | AssuranceCase$userPermissionsArgs<ExtArgs>
    teamPermissions?: boolean | AssuranceCase$teamPermissionsArgs<ExtArgs>
    invites?: boolean | AssuranceCase$invitesArgs<ExtArgs>
    comments?: boolean | AssuranceCase$commentsArgs<ExtArgs>
    caseImage?: boolean | AssuranceCase$caseImageArgs<ExtArgs>
    caseTypes?: boolean | AssuranceCase$caseTypesArgs<ExtArgs>
    sourceReleases?: boolean | AssuranceCase$sourceReleasesArgs<ExtArgs>
    publishedReleases?: boolean | AssuranceCase$publishedReleasesArgs<ExtArgs>
    publishedVersions?: boolean | AssuranceCase$publishedVersionsArgs<ExtArgs>
    embeddedIn?: boolean | AssuranceCase$embeddedInArgs<ExtArgs>
    _count?: boolean | AssuranceCaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssuranceCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    markedReadyBy?: boolean | AssuranceCase$markedReadyByArgs<ExtArgs>
    sourcePattern?: boolean | AssuranceCase$sourcePatternArgs<ExtArgs>
  }
  export type AssuranceCaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    markedReadyBy?: boolean | AssuranceCase$markedReadyByArgs<ExtArgs>
    sourcePattern?: boolean | AssuranceCase$sourcePatternArgs<ExtArgs>
  }

  export type $AssuranceCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssuranceCase"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      markedReadyBy: Prisma.$UserPayload<ExtArgs> | null
      sourcePattern: Prisma.$ArgumentPatternPayload<ExtArgs> | null
      elements: Prisma.$AssuranceElementPayload<ExtArgs>[]
      userPermissions: Prisma.$CasePermissionPayload<ExtArgs>[]
      teamPermissions: Prisma.$CaseTeamPermissionPayload<ExtArgs>[]
      invites: Prisma.$CaseInvitePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      caseImage: Prisma.$CaseImagePayload<ExtArgs> | null
      caseTypes: Prisma.$CaseTypeAssignmentPayload<ExtArgs>[]
      sourceReleases: Prisma.$ReleasePayload<ExtArgs>[]
      publishedReleases: Prisma.$ReleasePayload<ExtArgs>[]
      publishedVersions: Prisma.$PublishedAssuranceCasePayload<ExtArgs>[]
      embeddedIn: Prisma.$AssuranceElementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      createdById: string
      mode: $Enums.CaseMode
      colorProfile: string
      lockUuid: string | null
      lockedById: string | null
      lockedAt: Date | null
      sourcePatternId: string | null
      createdAt: Date
      updatedAt: Date
      published: boolean
      publishedAt: Date | null
      publishStatus: $Enums.PublishStatus
      markedReadyAt: Date | null
      markedReadyById: string | null
    }, ExtArgs["result"]["assuranceCase"]>
    composites: {}
  }

  type AssuranceCaseGetPayload<S extends boolean | null | undefined | AssuranceCaseDefaultArgs> = $Result.GetResult<Prisma.$AssuranceCasePayload, S>

  type AssuranceCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssuranceCaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssuranceCaseCountAggregateInputType | true
    }

  export interface AssuranceCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssuranceCase'], meta: { name: 'AssuranceCase' } }
    /**
     * Find zero or one AssuranceCase that matches the filter.
     * @param {AssuranceCaseFindUniqueArgs} args - Arguments to find a AssuranceCase
     * @example
     * // Get one AssuranceCase
     * const assuranceCase = await prisma.assuranceCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssuranceCaseFindUniqueArgs>(args: SelectSubset<T, AssuranceCaseFindUniqueArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssuranceCase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssuranceCaseFindUniqueOrThrowArgs} args - Arguments to find a AssuranceCase
     * @example
     * // Get one AssuranceCase
     * const assuranceCase = await prisma.assuranceCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssuranceCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, AssuranceCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssuranceCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceCaseFindFirstArgs} args - Arguments to find a AssuranceCase
     * @example
     * // Get one AssuranceCase
     * const assuranceCase = await prisma.assuranceCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssuranceCaseFindFirstArgs>(args?: SelectSubset<T, AssuranceCaseFindFirstArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssuranceCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceCaseFindFirstOrThrowArgs} args - Arguments to find a AssuranceCase
     * @example
     * // Get one AssuranceCase
     * const assuranceCase = await prisma.assuranceCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssuranceCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, AssuranceCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssuranceCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssuranceCases
     * const assuranceCases = await prisma.assuranceCase.findMany()
     *
     * // Get first 10 AssuranceCases
     * const assuranceCases = await prisma.assuranceCase.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const assuranceCaseWithIdOnly = await prisma.assuranceCase.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AssuranceCaseFindManyArgs>(args?: SelectSubset<T, AssuranceCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssuranceCase.
     * @param {AssuranceCaseCreateArgs} args - Arguments to create a AssuranceCase.
     * @example
     * // Create one AssuranceCase
     * const AssuranceCase = await prisma.assuranceCase.create({
     *   data: {
     *     // ... data to create a AssuranceCase
     *   }
     * })
     *
     */
    create<T extends AssuranceCaseCreateArgs>(args: SelectSubset<T, AssuranceCaseCreateArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssuranceCases.
     * @param {AssuranceCaseCreateManyArgs} args - Arguments to create many AssuranceCases.
     * @example
     * // Create many AssuranceCases
     * const assuranceCase = await prisma.assuranceCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AssuranceCaseCreateManyArgs>(args?: SelectSubset<T, AssuranceCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssuranceCases and returns the data saved in the database.
     * @param {AssuranceCaseCreateManyAndReturnArgs} args - Arguments to create many AssuranceCases.
     * @example
     * // Create many AssuranceCases
     * const assuranceCase = await prisma.assuranceCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AssuranceCases and only return the `id`
     * const assuranceCaseWithIdOnly = await prisma.assuranceCase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AssuranceCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, AssuranceCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssuranceCase.
     * @param {AssuranceCaseDeleteArgs} args - Arguments to delete one AssuranceCase.
     * @example
     * // Delete one AssuranceCase
     * const AssuranceCase = await prisma.assuranceCase.delete({
     *   where: {
     *     // ... filter to delete one AssuranceCase
     *   }
     * })
     *
     */
    delete<T extends AssuranceCaseDeleteArgs>(args: SelectSubset<T, AssuranceCaseDeleteArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssuranceCase.
     * @param {AssuranceCaseUpdateArgs} args - Arguments to update one AssuranceCase.
     * @example
     * // Update one AssuranceCase
     * const assuranceCase = await prisma.assuranceCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AssuranceCaseUpdateArgs>(args: SelectSubset<T, AssuranceCaseUpdateArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssuranceCases.
     * @param {AssuranceCaseDeleteManyArgs} args - Arguments to filter AssuranceCases to delete.
     * @example
     * // Delete a few AssuranceCases
     * const { count } = await prisma.assuranceCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AssuranceCaseDeleteManyArgs>(args?: SelectSubset<T, AssuranceCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssuranceCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssuranceCases
     * const assuranceCase = await prisma.assuranceCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AssuranceCaseUpdateManyArgs>(args: SelectSubset<T, AssuranceCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssuranceCases and returns the data updated in the database.
     * @param {AssuranceCaseUpdateManyAndReturnArgs} args - Arguments to update many AssuranceCases.
     * @example
     * // Update many AssuranceCases
     * const assuranceCase = await prisma.assuranceCase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AssuranceCases and only return the `id`
     * const assuranceCaseWithIdOnly = await prisma.assuranceCase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AssuranceCaseUpdateManyAndReturnArgs>(args: SelectSubset<T, AssuranceCaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssuranceCase.
     * @param {AssuranceCaseUpsertArgs} args - Arguments to update or create a AssuranceCase.
     * @example
     * // Update or create a AssuranceCase
     * const assuranceCase = await prisma.assuranceCase.upsert({
     *   create: {
     *     // ... data to create a AssuranceCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssuranceCase we want to update
     *   }
     * })
     */
    upsert<T extends AssuranceCaseUpsertArgs>(args: SelectSubset<T, AssuranceCaseUpsertArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssuranceCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceCaseCountArgs} args - Arguments to filter AssuranceCases to count.
     * @example
     * // Count the number of AssuranceCases
     * const count = await prisma.assuranceCase.count({
     *   where: {
     *     // ... the filter for the AssuranceCases we want to count
     *   }
     * })
    **/
    count<T extends AssuranceCaseCountArgs>(
      args?: Subset<T, AssuranceCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssuranceCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssuranceCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssuranceCaseAggregateArgs>(args: Subset<T, AssuranceCaseAggregateArgs>): Prisma.PrismaPromise<GetAssuranceCaseAggregateType<T>>

    /**
     * Group by AssuranceCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends AssuranceCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssuranceCaseGroupByArgs['orderBy'] }
        : { orderBy?: AssuranceCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssuranceCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssuranceCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssuranceCase model
   */
  readonly fields: AssuranceCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssuranceCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssuranceCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    markedReadyBy<T extends AssuranceCase$markedReadyByArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$markedReadyByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sourcePattern<T extends AssuranceCase$sourcePatternArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$sourcePatternArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    elements<T extends AssuranceCase$elementsArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$elementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPermissions<T extends AssuranceCase$userPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$userPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamPermissions<T extends AssuranceCase$teamPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$teamPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invites<T extends AssuranceCase$invitesArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends AssuranceCase$commentsArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    caseImage<T extends AssuranceCase$caseImageArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$caseImageArgs<ExtArgs>>): Prisma__CaseImageClient<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    caseTypes<T extends AssuranceCase$caseTypesArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$caseTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sourceReleases<T extends AssuranceCase$sourceReleasesArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$sourceReleasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publishedReleases<T extends AssuranceCase$publishedReleasesArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$publishedReleasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publishedVersions<T extends AssuranceCase$publishedVersionsArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$publishedVersionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    embeddedIn<T extends AssuranceCase$embeddedInArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCase$embeddedInArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssuranceCase model
   */
  interface AssuranceCaseFieldRefs {
    readonly id: FieldRef<"AssuranceCase", 'String'>
    readonly name: FieldRef<"AssuranceCase", 'String'>
    readonly description: FieldRef<"AssuranceCase", 'String'>
    readonly createdById: FieldRef<"AssuranceCase", 'String'>
    readonly mode: FieldRef<"AssuranceCase", 'CaseMode'>
    readonly colorProfile: FieldRef<"AssuranceCase", 'String'>
    readonly lockUuid: FieldRef<"AssuranceCase", 'String'>
    readonly lockedById: FieldRef<"AssuranceCase", 'String'>
    readonly lockedAt: FieldRef<"AssuranceCase", 'DateTime'>
    readonly sourcePatternId: FieldRef<"AssuranceCase", 'String'>
    readonly createdAt: FieldRef<"AssuranceCase", 'DateTime'>
    readonly updatedAt: FieldRef<"AssuranceCase", 'DateTime'>
    readonly published: FieldRef<"AssuranceCase", 'Boolean'>
    readonly publishedAt: FieldRef<"AssuranceCase", 'DateTime'>
    readonly publishStatus: FieldRef<"AssuranceCase", 'PublishStatus'>
    readonly markedReadyAt: FieldRef<"AssuranceCase", 'DateTime'>
    readonly markedReadyById: FieldRef<"AssuranceCase", 'String'>
  }


  // Custom InputTypes
  /**
   * AssuranceCase findUnique
   */
  export type AssuranceCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceCase to fetch.
     */
    where: AssuranceCaseWhereUniqueInput
  }

  /**
   * AssuranceCase findUniqueOrThrow
   */
  export type AssuranceCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceCase to fetch.
     */
    where: AssuranceCaseWhereUniqueInput
  }

  /**
   * AssuranceCase findFirst
   */
  export type AssuranceCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceCase to fetch.
     */
    where?: AssuranceCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssuranceCases to fetch.
     */
    orderBy?: AssuranceCaseOrderByWithRelationInput | AssuranceCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AssuranceCases.
     */
    cursor?: AssuranceCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssuranceCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssuranceCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AssuranceCases.
     */
    distinct?: AssuranceCaseScalarFieldEnum | AssuranceCaseScalarFieldEnum[]
  }

  /**
   * AssuranceCase findFirstOrThrow
   */
  export type AssuranceCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceCase to fetch.
     */
    where?: AssuranceCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssuranceCases to fetch.
     */
    orderBy?: AssuranceCaseOrderByWithRelationInput | AssuranceCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AssuranceCases.
     */
    cursor?: AssuranceCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssuranceCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssuranceCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AssuranceCases.
     */
    distinct?: AssuranceCaseScalarFieldEnum | AssuranceCaseScalarFieldEnum[]
  }

  /**
   * AssuranceCase findMany
   */
  export type AssuranceCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceCases to fetch.
     */
    where?: AssuranceCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssuranceCases to fetch.
     */
    orderBy?: AssuranceCaseOrderByWithRelationInput | AssuranceCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AssuranceCases.
     */
    cursor?: AssuranceCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssuranceCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssuranceCases.
     */
    skip?: number
    distinct?: AssuranceCaseScalarFieldEnum | AssuranceCaseScalarFieldEnum[]
  }

  /**
   * AssuranceCase create
   */
  export type AssuranceCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a AssuranceCase.
     */
    data: XOR<AssuranceCaseCreateInput, AssuranceCaseUncheckedCreateInput>
  }

  /**
   * AssuranceCase createMany
   */
  export type AssuranceCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssuranceCases.
     */
    data: AssuranceCaseCreateManyInput | AssuranceCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssuranceCase createManyAndReturn
   */
  export type AssuranceCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * The data used to create many AssuranceCases.
     */
    data: AssuranceCaseCreateManyInput | AssuranceCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssuranceCase update
   */
  export type AssuranceCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a AssuranceCase.
     */
    data: XOR<AssuranceCaseUpdateInput, AssuranceCaseUncheckedUpdateInput>
    /**
     * Choose, which AssuranceCase to update.
     */
    where: AssuranceCaseWhereUniqueInput
  }

  /**
   * AssuranceCase updateMany
   */
  export type AssuranceCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssuranceCases.
     */
    data: XOR<AssuranceCaseUpdateManyMutationInput, AssuranceCaseUncheckedUpdateManyInput>
    /**
     * Filter which AssuranceCases to update
     */
    where?: AssuranceCaseWhereInput
    /**
     * Limit how many AssuranceCases to update.
     */
    limit?: number
  }

  /**
   * AssuranceCase updateManyAndReturn
   */
  export type AssuranceCaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * The data used to update AssuranceCases.
     */
    data: XOR<AssuranceCaseUpdateManyMutationInput, AssuranceCaseUncheckedUpdateManyInput>
    /**
     * Filter which AssuranceCases to update
     */
    where?: AssuranceCaseWhereInput
    /**
     * Limit how many AssuranceCases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssuranceCase upsert
   */
  export type AssuranceCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the AssuranceCase to update in case it exists.
     */
    where: AssuranceCaseWhereUniqueInput
    /**
     * In case the AssuranceCase found by the `where` argument doesn't exist, create a new AssuranceCase with this data.
     */
    create: XOR<AssuranceCaseCreateInput, AssuranceCaseUncheckedCreateInput>
    /**
     * In case the AssuranceCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssuranceCaseUpdateInput, AssuranceCaseUncheckedUpdateInput>
  }

  /**
   * AssuranceCase delete
   */
  export type AssuranceCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter which AssuranceCase to delete.
     */
    where: AssuranceCaseWhereUniqueInput
  }

  /**
   * AssuranceCase deleteMany
   */
  export type AssuranceCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssuranceCases to delete
     */
    where?: AssuranceCaseWhereInput
    /**
     * Limit how many AssuranceCases to delete.
     */
    limit?: number
  }

  /**
   * AssuranceCase.markedReadyBy
   */
  export type AssuranceCase$markedReadyByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AssuranceCase.sourcePattern
   */
  export type AssuranceCase$sourcePatternArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    where?: ArgumentPatternWhereInput
  }

  /**
   * AssuranceCase.elements
   */
  export type AssuranceCase$elementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    where?: AssuranceElementWhereInput
    orderBy?: AssuranceElementOrderByWithRelationInput | AssuranceElementOrderByWithRelationInput[]
    cursor?: AssuranceElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssuranceElementScalarFieldEnum | AssuranceElementScalarFieldEnum[]
  }

  /**
   * AssuranceCase.userPermissions
   */
  export type AssuranceCase$userPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    where?: CasePermissionWhereInput
    orderBy?: CasePermissionOrderByWithRelationInput | CasePermissionOrderByWithRelationInput[]
    cursor?: CasePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CasePermissionScalarFieldEnum | CasePermissionScalarFieldEnum[]
  }

  /**
   * AssuranceCase.teamPermissions
   */
  export type AssuranceCase$teamPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    where?: CaseTeamPermissionWhereInput
    orderBy?: CaseTeamPermissionOrderByWithRelationInput | CaseTeamPermissionOrderByWithRelationInput[]
    cursor?: CaseTeamPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseTeamPermissionScalarFieldEnum | CaseTeamPermissionScalarFieldEnum[]
  }

  /**
   * AssuranceCase.invites
   */
  export type AssuranceCase$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    where?: CaseInviteWhereInput
    orderBy?: CaseInviteOrderByWithRelationInput | CaseInviteOrderByWithRelationInput[]
    cursor?: CaseInviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseInviteScalarFieldEnum | CaseInviteScalarFieldEnum[]
  }

  /**
   * AssuranceCase.comments
   */
  export type AssuranceCase$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * AssuranceCase.caseImage
   */
  export type AssuranceCase$caseImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    where?: CaseImageWhereInput
  }

  /**
   * AssuranceCase.caseTypes
   */
  export type AssuranceCase$caseTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    where?: CaseTypeAssignmentWhereInput
    orderBy?: CaseTypeAssignmentOrderByWithRelationInput | CaseTypeAssignmentOrderByWithRelationInput[]
    cursor?: CaseTypeAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseTypeAssignmentScalarFieldEnum | CaseTypeAssignmentScalarFieldEnum[]
  }

  /**
   * AssuranceCase.sourceReleases
   */
  export type AssuranceCase$sourceReleasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    where?: ReleaseWhereInput
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    cursor?: ReleaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * AssuranceCase.publishedReleases
   */
  export type AssuranceCase$publishedReleasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    where?: ReleaseWhereInput
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    cursor?: ReleaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * AssuranceCase.publishedVersions
   */
  export type AssuranceCase$publishedVersionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    where?: PublishedAssuranceCaseWhereInput
    orderBy?: PublishedAssuranceCaseOrderByWithRelationInput | PublishedAssuranceCaseOrderByWithRelationInput[]
    cursor?: PublishedAssuranceCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublishedAssuranceCaseScalarFieldEnum | PublishedAssuranceCaseScalarFieldEnum[]
  }

  /**
   * AssuranceCase.embeddedIn
   */
  export type AssuranceCase$embeddedInArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    where?: AssuranceElementWhereInput
    orderBy?: AssuranceElementOrderByWithRelationInput | AssuranceElementOrderByWithRelationInput[]
    cursor?: AssuranceElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssuranceElementScalarFieldEnum | AssuranceElementScalarFieldEnum[]
  }

  /**
   * AssuranceCase without action
   */
  export type AssuranceCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
  }


  /**
   * Model CasePermission
   */

  export type AggregateCasePermission = {
    _count: CasePermissionCountAggregateOutputType | null
    _min: CasePermissionMinAggregateOutputType | null
    _max: CasePermissionMaxAggregateOutputType | null
  }

  export type CasePermissionMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    userId: string | null
    permission: $Enums.PermissionLevel | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type CasePermissionMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    userId: string | null
    permission: $Enums.PermissionLevel | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type CasePermissionCountAggregateOutputType = {
    id: number
    caseId: number
    userId: number
    permission: number
    grantedById: number
    grantedAt: number
    _all: number
  }


  export type CasePermissionMinAggregateInputType = {
    id?: true
    caseId?: true
    userId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
  }

  export type CasePermissionMaxAggregateInputType = {
    id?: true
    caseId?: true
    userId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
  }

  export type CasePermissionCountAggregateInputType = {
    id?: true
    caseId?: true
    userId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
    _all?: true
  }

  export type CasePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CasePermission to aggregate.
     */
    where?: CasePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CasePermissions to fetch.
     */
    orderBy?: CasePermissionOrderByWithRelationInput | CasePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CasePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CasePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CasePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CasePermissions
    **/
    _count?: true | CasePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CasePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CasePermissionMaxAggregateInputType
  }

  export type GetCasePermissionAggregateType<T extends CasePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateCasePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCasePermission[P]>
      : GetScalarType<T[P], AggregateCasePermission[P]>
  }




  export type CasePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CasePermissionWhereInput
    orderBy?: CasePermissionOrderByWithAggregationInput | CasePermissionOrderByWithAggregationInput[]
    by: CasePermissionScalarFieldEnum[] | CasePermissionScalarFieldEnum
    having?: CasePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CasePermissionCountAggregateInputType | true
    _min?: CasePermissionMinAggregateInputType
    _max?: CasePermissionMaxAggregateInputType
  }

  export type CasePermissionGroupByOutputType = {
    id: string
    caseId: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt: Date
    _count: CasePermissionCountAggregateOutputType | null
    _min: CasePermissionMinAggregateOutputType | null
    _max: CasePermissionMaxAggregateOutputType | null
  }

  type GetCasePermissionGroupByPayload<T extends CasePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CasePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CasePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CasePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], CasePermissionGroupByOutputType[P]>
        }
      >
    >


  export type CasePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    userId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["casePermission"]>

  export type CasePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    userId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["casePermission"]>

  export type CasePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    userId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["casePermission"]>

  export type CasePermissionSelectScalar = {
    id?: boolean
    caseId?: boolean
    userId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
  }

  export type CasePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "userId" | "permission" | "grantedById" | "grantedAt", ExtArgs["result"]["casePermission"]>
  export type CasePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CasePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CasePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    grantedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CasePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CasePermission"
    objects: {
      case: Prisma.$AssuranceCasePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      grantedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      userId: string
      permission: $Enums.PermissionLevel
      grantedById: string
      grantedAt: Date
    }, ExtArgs["result"]["casePermission"]>
    composites: {}
  }

  type CasePermissionGetPayload<S extends boolean | null | undefined | CasePermissionDefaultArgs> = $Result.GetResult<Prisma.$CasePermissionPayload, S>

  type CasePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CasePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CasePermissionCountAggregateInputType | true
    }

  export interface CasePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CasePermission'], meta: { name: 'CasePermission' } }
    /**
     * Find zero or one CasePermission that matches the filter.
     * @param {CasePermissionFindUniqueArgs} args - Arguments to find a CasePermission
     * @example
     * // Get one CasePermission
     * const casePermission = await prisma.casePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CasePermissionFindUniqueArgs>(args: SelectSubset<T, CasePermissionFindUniqueArgs<ExtArgs>>): Prisma__CasePermissionClient<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CasePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CasePermissionFindUniqueOrThrowArgs} args - Arguments to find a CasePermission
     * @example
     * // Get one CasePermission
     * const casePermission = await prisma.casePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CasePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, CasePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CasePermissionClient<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CasePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CasePermissionFindFirstArgs} args - Arguments to find a CasePermission
     * @example
     * // Get one CasePermission
     * const casePermission = await prisma.casePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CasePermissionFindFirstArgs>(args?: SelectSubset<T, CasePermissionFindFirstArgs<ExtArgs>>): Prisma__CasePermissionClient<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CasePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CasePermissionFindFirstOrThrowArgs} args - Arguments to find a CasePermission
     * @example
     * // Get one CasePermission
     * const casePermission = await prisma.casePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CasePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, CasePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CasePermissionClient<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CasePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CasePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CasePermissions
     * const casePermissions = await prisma.casePermission.findMany()
     *
     * // Get first 10 CasePermissions
     * const casePermissions = await prisma.casePermission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const casePermissionWithIdOnly = await prisma.casePermission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CasePermissionFindManyArgs>(args?: SelectSubset<T, CasePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CasePermission.
     * @param {CasePermissionCreateArgs} args - Arguments to create a CasePermission.
     * @example
     * // Create one CasePermission
     * const CasePermission = await prisma.casePermission.create({
     *   data: {
     *     // ... data to create a CasePermission
     *   }
     * })
     *
     */
    create<T extends CasePermissionCreateArgs>(args: SelectSubset<T, CasePermissionCreateArgs<ExtArgs>>): Prisma__CasePermissionClient<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CasePermissions.
     * @param {CasePermissionCreateManyArgs} args - Arguments to create many CasePermissions.
     * @example
     * // Create many CasePermissions
     * const casePermission = await prisma.casePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CasePermissionCreateManyArgs>(args?: SelectSubset<T, CasePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CasePermissions and returns the data saved in the database.
     * @param {CasePermissionCreateManyAndReturnArgs} args - Arguments to create many CasePermissions.
     * @example
     * // Create many CasePermissions
     * const casePermission = await prisma.casePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CasePermissions and only return the `id`
     * const casePermissionWithIdOnly = await prisma.casePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CasePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, CasePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CasePermission.
     * @param {CasePermissionDeleteArgs} args - Arguments to delete one CasePermission.
     * @example
     * // Delete one CasePermission
     * const CasePermission = await prisma.casePermission.delete({
     *   where: {
     *     // ... filter to delete one CasePermission
     *   }
     * })
     *
     */
    delete<T extends CasePermissionDeleteArgs>(args: SelectSubset<T, CasePermissionDeleteArgs<ExtArgs>>): Prisma__CasePermissionClient<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CasePermission.
     * @param {CasePermissionUpdateArgs} args - Arguments to update one CasePermission.
     * @example
     * // Update one CasePermission
     * const casePermission = await prisma.casePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CasePermissionUpdateArgs>(args: SelectSubset<T, CasePermissionUpdateArgs<ExtArgs>>): Prisma__CasePermissionClient<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CasePermissions.
     * @param {CasePermissionDeleteManyArgs} args - Arguments to filter CasePermissions to delete.
     * @example
     * // Delete a few CasePermissions
     * const { count } = await prisma.casePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CasePermissionDeleteManyArgs>(args?: SelectSubset<T, CasePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CasePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CasePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CasePermissions
     * const casePermission = await prisma.casePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CasePermissionUpdateManyArgs>(args: SelectSubset<T, CasePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CasePermissions and returns the data updated in the database.
     * @param {CasePermissionUpdateManyAndReturnArgs} args - Arguments to update many CasePermissions.
     * @example
     * // Update many CasePermissions
     * const casePermission = await prisma.casePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CasePermissions and only return the `id`
     * const casePermissionWithIdOnly = await prisma.casePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CasePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, CasePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CasePermission.
     * @param {CasePermissionUpsertArgs} args - Arguments to update or create a CasePermission.
     * @example
     * // Update or create a CasePermission
     * const casePermission = await prisma.casePermission.upsert({
     *   create: {
     *     // ... data to create a CasePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CasePermission we want to update
     *   }
     * })
     */
    upsert<T extends CasePermissionUpsertArgs>(args: SelectSubset<T, CasePermissionUpsertArgs<ExtArgs>>): Prisma__CasePermissionClient<$Result.GetResult<Prisma.$CasePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CasePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CasePermissionCountArgs} args - Arguments to filter CasePermissions to count.
     * @example
     * // Count the number of CasePermissions
     * const count = await prisma.casePermission.count({
     *   where: {
     *     // ... the filter for the CasePermissions we want to count
     *   }
     * })
    **/
    count<T extends CasePermissionCountArgs>(
      args?: Subset<T, CasePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CasePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CasePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CasePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CasePermissionAggregateArgs>(args: Subset<T, CasePermissionAggregateArgs>): Prisma.PrismaPromise<GetCasePermissionAggregateType<T>>

    /**
     * Group by CasePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CasePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CasePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CasePermissionGroupByArgs['orderBy'] }
        : { orderBy?: CasePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CasePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCasePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CasePermission model
   */
  readonly fields: CasePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CasePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CasePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends AssuranceCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCaseDefaultArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grantedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CasePermission model
   */
  interface CasePermissionFieldRefs {
    readonly id: FieldRef<"CasePermission", 'String'>
    readonly caseId: FieldRef<"CasePermission", 'String'>
    readonly userId: FieldRef<"CasePermission", 'String'>
    readonly permission: FieldRef<"CasePermission", 'PermissionLevel'>
    readonly grantedById: FieldRef<"CasePermission", 'String'>
    readonly grantedAt: FieldRef<"CasePermission", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * CasePermission findUnique
   */
  export type CasePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which CasePermission to fetch.
     */
    where: CasePermissionWhereUniqueInput
  }

  /**
   * CasePermission findUniqueOrThrow
   */
  export type CasePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which CasePermission to fetch.
     */
    where: CasePermissionWhereUniqueInput
  }

  /**
   * CasePermission findFirst
   */
  export type CasePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which CasePermission to fetch.
     */
    where?: CasePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CasePermissions to fetch.
     */
    orderBy?: CasePermissionOrderByWithRelationInput | CasePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CasePermissions.
     */
    cursor?: CasePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CasePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CasePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CasePermissions.
     */
    distinct?: CasePermissionScalarFieldEnum | CasePermissionScalarFieldEnum[]
  }

  /**
   * CasePermission findFirstOrThrow
   */
  export type CasePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which CasePermission to fetch.
     */
    where?: CasePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CasePermissions to fetch.
     */
    orderBy?: CasePermissionOrderByWithRelationInput | CasePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CasePermissions.
     */
    cursor?: CasePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CasePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CasePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CasePermissions.
     */
    distinct?: CasePermissionScalarFieldEnum | CasePermissionScalarFieldEnum[]
  }

  /**
   * CasePermission findMany
   */
  export type CasePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    /**
     * Filter, which CasePermissions to fetch.
     */
    where?: CasePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CasePermissions to fetch.
     */
    orderBy?: CasePermissionOrderByWithRelationInput | CasePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CasePermissions.
     */
    cursor?: CasePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CasePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CasePermissions.
     */
    skip?: number
    distinct?: CasePermissionScalarFieldEnum | CasePermissionScalarFieldEnum[]
  }

  /**
   * CasePermission create
   */
  export type CasePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a CasePermission.
     */
    data: XOR<CasePermissionCreateInput, CasePermissionUncheckedCreateInput>
  }

  /**
   * CasePermission createMany
   */
  export type CasePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CasePermissions.
     */
    data: CasePermissionCreateManyInput | CasePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CasePermission createManyAndReturn
   */
  export type CasePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many CasePermissions.
     */
    data: CasePermissionCreateManyInput | CasePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CasePermission update
   */
  export type CasePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a CasePermission.
     */
    data: XOR<CasePermissionUpdateInput, CasePermissionUncheckedUpdateInput>
    /**
     * Choose, which CasePermission to update.
     */
    where: CasePermissionWhereUniqueInput
  }

  /**
   * CasePermission updateMany
   */
  export type CasePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CasePermissions.
     */
    data: XOR<CasePermissionUpdateManyMutationInput, CasePermissionUncheckedUpdateManyInput>
    /**
     * Filter which CasePermissions to update
     */
    where?: CasePermissionWhereInput
    /**
     * Limit how many CasePermissions to update.
     */
    limit?: number
  }

  /**
   * CasePermission updateManyAndReturn
   */
  export type CasePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * The data used to update CasePermissions.
     */
    data: XOR<CasePermissionUpdateManyMutationInput, CasePermissionUncheckedUpdateManyInput>
    /**
     * Filter which CasePermissions to update
     */
    where?: CasePermissionWhereInput
    /**
     * Limit how many CasePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CasePermission upsert
   */
  export type CasePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the CasePermission to update in case it exists.
     */
    where: CasePermissionWhereUniqueInput
    /**
     * In case the CasePermission found by the `where` argument doesn't exist, create a new CasePermission with this data.
     */
    create: XOR<CasePermissionCreateInput, CasePermissionUncheckedCreateInput>
    /**
     * In case the CasePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CasePermissionUpdateInput, CasePermissionUncheckedUpdateInput>
  }

  /**
   * CasePermission delete
   */
  export type CasePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
    /**
     * Filter which CasePermission to delete.
     */
    where: CasePermissionWhereUniqueInput
  }

  /**
   * CasePermission deleteMany
   */
  export type CasePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CasePermissions to delete
     */
    where?: CasePermissionWhereInput
    /**
     * Limit how many CasePermissions to delete.
     */
    limit?: number
  }

  /**
   * CasePermission without action
   */
  export type CasePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CasePermission
     */
    select?: CasePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CasePermission
     */
    omit?: CasePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CasePermissionInclude<ExtArgs> | null
  }


  /**
   * Model CaseTeamPermission
   */

  export type AggregateCaseTeamPermission = {
    _count: CaseTeamPermissionCountAggregateOutputType | null
    _min: CaseTeamPermissionMinAggregateOutputType | null
    _max: CaseTeamPermissionMaxAggregateOutputType | null
  }

  export type CaseTeamPermissionMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    teamId: string | null
    permission: $Enums.PermissionLevel | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type CaseTeamPermissionMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    teamId: string | null
    permission: $Enums.PermissionLevel | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type CaseTeamPermissionCountAggregateOutputType = {
    id: number
    caseId: number
    teamId: number
    permission: number
    grantedById: number
    grantedAt: number
    _all: number
  }


  export type CaseTeamPermissionMinAggregateInputType = {
    id?: true
    caseId?: true
    teamId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
  }

  export type CaseTeamPermissionMaxAggregateInputType = {
    id?: true
    caseId?: true
    teamId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
  }

  export type CaseTeamPermissionCountAggregateInputType = {
    id?: true
    caseId?: true
    teamId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
    _all?: true
  }

  export type CaseTeamPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseTeamPermission to aggregate.
     */
    where?: CaseTeamPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTeamPermissions to fetch.
     */
    orderBy?: CaseTeamPermissionOrderByWithRelationInput | CaseTeamPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CaseTeamPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTeamPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTeamPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CaseTeamPermissions
    **/
    _count?: true | CaseTeamPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CaseTeamPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CaseTeamPermissionMaxAggregateInputType
  }

  export type GetCaseTeamPermissionAggregateType<T extends CaseTeamPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseTeamPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseTeamPermission[P]>
      : GetScalarType<T[P], AggregateCaseTeamPermission[P]>
  }




  export type CaseTeamPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseTeamPermissionWhereInput
    orderBy?: CaseTeamPermissionOrderByWithAggregationInput | CaseTeamPermissionOrderByWithAggregationInput[]
    by: CaseTeamPermissionScalarFieldEnum[] | CaseTeamPermissionScalarFieldEnum
    having?: CaseTeamPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseTeamPermissionCountAggregateInputType | true
    _min?: CaseTeamPermissionMinAggregateInputType
    _max?: CaseTeamPermissionMaxAggregateInputType
  }

  export type CaseTeamPermissionGroupByOutputType = {
    id: string
    caseId: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt: Date
    _count: CaseTeamPermissionCountAggregateOutputType | null
    _min: CaseTeamPermissionMinAggregateOutputType | null
    _max: CaseTeamPermissionMaxAggregateOutputType | null
  }

  type GetCaseTeamPermissionGroupByPayload<T extends CaseTeamPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseTeamPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseTeamPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseTeamPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], CaseTeamPermissionGroupByOutputType[P]>
        }
      >
    >


  export type CaseTeamPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    teamId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseTeamPermission"]>

  export type CaseTeamPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    teamId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseTeamPermission"]>

  export type CaseTeamPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    teamId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseTeamPermission"]>

  export type CaseTeamPermissionSelectScalar = {
    id?: boolean
    caseId?: boolean
    teamId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
  }

  export type CaseTeamPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "teamId" | "permission" | "grantedById" | "grantedAt", ExtArgs["result"]["caseTeamPermission"]>
  export type CaseTeamPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type CaseTeamPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type CaseTeamPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $CaseTeamPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseTeamPermission"
    objects: {
      case: Prisma.$AssuranceCasePayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      teamId: string
      permission: $Enums.PermissionLevel
      grantedById: string
      grantedAt: Date
    }, ExtArgs["result"]["caseTeamPermission"]>
    composites: {}
  }

  type CaseTeamPermissionGetPayload<S extends boolean | null | undefined | CaseTeamPermissionDefaultArgs> = $Result.GetResult<Prisma.$CaseTeamPermissionPayload, S>

  type CaseTeamPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseTeamPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseTeamPermissionCountAggregateInputType | true
    }

  export interface CaseTeamPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseTeamPermission'], meta: { name: 'CaseTeamPermission' } }
    /**
     * Find zero or one CaseTeamPermission that matches the filter.
     * @param {CaseTeamPermissionFindUniqueArgs} args - Arguments to find a CaseTeamPermission
     * @example
     * // Get one CaseTeamPermission
     * const caseTeamPermission = await prisma.caseTeamPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseTeamPermissionFindUniqueArgs>(args: SelectSubset<T, CaseTeamPermissionFindUniqueArgs<ExtArgs>>): Prisma__CaseTeamPermissionClient<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseTeamPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseTeamPermissionFindUniqueOrThrowArgs} args - Arguments to find a CaseTeamPermission
     * @example
     * // Get one CaseTeamPermission
     * const caseTeamPermission = await prisma.caseTeamPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseTeamPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseTeamPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseTeamPermissionClient<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseTeamPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTeamPermissionFindFirstArgs} args - Arguments to find a CaseTeamPermission
     * @example
     * // Get one CaseTeamPermission
     * const caseTeamPermission = await prisma.caseTeamPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseTeamPermissionFindFirstArgs>(args?: SelectSubset<T, CaseTeamPermissionFindFirstArgs<ExtArgs>>): Prisma__CaseTeamPermissionClient<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseTeamPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTeamPermissionFindFirstOrThrowArgs} args - Arguments to find a CaseTeamPermission
     * @example
     * // Get one CaseTeamPermission
     * const caseTeamPermission = await prisma.caseTeamPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseTeamPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseTeamPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseTeamPermissionClient<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseTeamPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTeamPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseTeamPermissions
     * const caseTeamPermissions = await prisma.caseTeamPermission.findMany()
     *
     * // Get first 10 CaseTeamPermissions
     * const caseTeamPermissions = await prisma.caseTeamPermission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const caseTeamPermissionWithIdOnly = await prisma.caseTeamPermission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CaseTeamPermissionFindManyArgs>(args?: SelectSubset<T, CaseTeamPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseTeamPermission.
     * @param {CaseTeamPermissionCreateArgs} args - Arguments to create a CaseTeamPermission.
     * @example
     * // Create one CaseTeamPermission
     * const CaseTeamPermission = await prisma.caseTeamPermission.create({
     *   data: {
     *     // ... data to create a CaseTeamPermission
     *   }
     * })
     *
     */
    create<T extends CaseTeamPermissionCreateArgs>(args: SelectSubset<T, CaseTeamPermissionCreateArgs<ExtArgs>>): Prisma__CaseTeamPermissionClient<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseTeamPermissions.
     * @param {CaseTeamPermissionCreateManyArgs} args - Arguments to create many CaseTeamPermissions.
     * @example
     * // Create many CaseTeamPermissions
     * const caseTeamPermission = await prisma.caseTeamPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CaseTeamPermissionCreateManyArgs>(args?: SelectSubset<T, CaseTeamPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseTeamPermissions and returns the data saved in the database.
     * @param {CaseTeamPermissionCreateManyAndReturnArgs} args - Arguments to create many CaseTeamPermissions.
     * @example
     * // Create many CaseTeamPermissions
     * const caseTeamPermission = await prisma.caseTeamPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CaseTeamPermissions and only return the `id`
     * const caseTeamPermissionWithIdOnly = await prisma.caseTeamPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CaseTeamPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseTeamPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseTeamPermission.
     * @param {CaseTeamPermissionDeleteArgs} args - Arguments to delete one CaseTeamPermission.
     * @example
     * // Delete one CaseTeamPermission
     * const CaseTeamPermission = await prisma.caseTeamPermission.delete({
     *   where: {
     *     // ... filter to delete one CaseTeamPermission
     *   }
     * })
     *
     */
    delete<T extends CaseTeamPermissionDeleteArgs>(args: SelectSubset<T, CaseTeamPermissionDeleteArgs<ExtArgs>>): Prisma__CaseTeamPermissionClient<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseTeamPermission.
     * @param {CaseTeamPermissionUpdateArgs} args - Arguments to update one CaseTeamPermission.
     * @example
     * // Update one CaseTeamPermission
     * const caseTeamPermission = await prisma.caseTeamPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CaseTeamPermissionUpdateArgs>(args: SelectSubset<T, CaseTeamPermissionUpdateArgs<ExtArgs>>): Prisma__CaseTeamPermissionClient<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseTeamPermissions.
     * @param {CaseTeamPermissionDeleteManyArgs} args - Arguments to filter CaseTeamPermissions to delete.
     * @example
     * // Delete a few CaseTeamPermissions
     * const { count } = await prisma.caseTeamPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CaseTeamPermissionDeleteManyArgs>(args?: SelectSubset<T, CaseTeamPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseTeamPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTeamPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseTeamPermissions
     * const caseTeamPermission = await prisma.caseTeamPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CaseTeamPermissionUpdateManyArgs>(args: SelectSubset<T, CaseTeamPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseTeamPermissions and returns the data updated in the database.
     * @param {CaseTeamPermissionUpdateManyAndReturnArgs} args - Arguments to update many CaseTeamPermissions.
     * @example
     * // Update many CaseTeamPermissions
     * const caseTeamPermission = await prisma.caseTeamPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CaseTeamPermissions and only return the `id`
     * const caseTeamPermissionWithIdOnly = await prisma.caseTeamPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CaseTeamPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseTeamPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseTeamPermission.
     * @param {CaseTeamPermissionUpsertArgs} args - Arguments to update or create a CaseTeamPermission.
     * @example
     * // Update or create a CaseTeamPermission
     * const caseTeamPermission = await prisma.caseTeamPermission.upsert({
     *   create: {
     *     // ... data to create a CaseTeamPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseTeamPermission we want to update
     *   }
     * })
     */
    upsert<T extends CaseTeamPermissionUpsertArgs>(args: SelectSubset<T, CaseTeamPermissionUpsertArgs<ExtArgs>>): Prisma__CaseTeamPermissionClient<$Result.GetResult<Prisma.$CaseTeamPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseTeamPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTeamPermissionCountArgs} args - Arguments to filter CaseTeamPermissions to count.
     * @example
     * // Count the number of CaseTeamPermissions
     * const count = await prisma.caseTeamPermission.count({
     *   where: {
     *     // ... the filter for the CaseTeamPermissions we want to count
     *   }
     * })
    **/
    count<T extends CaseTeamPermissionCountArgs>(
      args?: Subset<T, CaseTeamPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseTeamPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseTeamPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTeamPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseTeamPermissionAggregateArgs>(args: Subset<T, CaseTeamPermissionAggregateArgs>): Prisma.PrismaPromise<GetCaseTeamPermissionAggregateType<T>>

    /**
     * Group by CaseTeamPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTeamPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CaseTeamPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseTeamPermissionGroupByArgs['orderBy'] }
        : { orderBy?: CaseTeamPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseTeamPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseTeamPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseTeamPermission model
   */
  readonly fields: CaseTeamPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseTeamPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseTeamPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends AssuranceCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCaseDefaultArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseTeamPermission model
   */
  interface CaseTeamPermissionFieldRefs {
    readonly id: FieldRef<"CaseTeamPermission", 'String'>
    readonly caseId: FieldRef<"CaseTeamPermission", 'String'>
    readonly teamId: FieldRef<"CaseTeamPermission", 'String'>
    readonly permission: FieldRef<"CaseTeamPermission", 'PermissionLevel'>
    readonly grantedById: FieldRef<"CaseTeamPermission", 'String'>
    readonly grantedAt: FieldRef<"CaseTeamPermission", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * CaseTeamPermission findUnique
   */
  export type CaseTeamPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CaseTeamPermission to fetch.
     */
    where: CaseTeamPermissionWhereUniqueInput
  }

  /**
   * CaseTeamPermission findUniqueOrThrow
   */
  export type CaseTeamPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CaseTeamPermission to fetch.
     */
    where: CaseTeamPermissionWhereUniqueInput
  }

  /**
   * CaseTeamPermission findFirst
   */
  export type CaseTeamPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CaseTeamPermission to fetch.
     */
    where?: CaseTeamPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTeamPermissions to fetch.
     */
    orderBy?: CaseTeamPermissionOrderByWithRelationInput | CaseTeamPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseTeamPermissions.
     */
    cursor?: CaseTeamPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTeamPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTeamPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseTeamPermissions.
     */
    distinct?: CaseTeamPermissionScalarFieldEnum | CaseTeamPermissionScalarFieldEnum[]
  }

  /**
   * CaseTeamPermission findFirstOrThrow
   */
  export type CaseTeamPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CaseTeamPermission to fetch.
     */
    where?: CaseTeamPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTeamPermissions to fetch.
     */
    orderBy?: CaseTeamPermissionOrderByWithRelationInput | CaseTeamPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseTeamPermissions.
     */
    cursor?: CaseTeamPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTeamPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTeamPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseTeamPermissions.
     */
    distinct?: CaseTeamPermissionScalarFieldEnum | CaseTeamPermissionScalarFieldEnum[]
  }

  /**
   * CaseTeamPermission findMany
   */
  export type CaseTeamPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which CaseTeamPermissions to fetch.
     */
    where?: CaseTeamPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTeamPermissions to fetch.
     */
    orderBy?: CaseTeamPermissionOrderByWithRelationInput | CaseTeamPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CaseTeamPermissions.
     */
    cursor?: CaseTeamPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTeamPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTeamPermissions.
     */
    skip?: number
    distinct?: CaseTeamPermissionScalarFieldEnum | CaseTeamPermissionScalarFieldEnum[]
  }

  /**
   * CaseTeamPermission create
   */
  export type CaseTeamPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseTeamPermission.
     */
    data: XOR<CaseTeamPermissionCreateInput, CaseTeamPermissionUncheckedCreateInput>
  }

  /**
   * CaseTeamPermission createMany
   */
  export type CaseTeamPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseTeamPermissions.
     */
    data: CaseTeamPermissionCreateManyInput | CaseTeamPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseTeamPermission createManyAndReturn
   */
  export type CaseTeamPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many CaseTeamPermissions.
     */
    data: CaseTeamPermissionCreateManyInput | CaseTeamPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseTeamPermission update
   */
  export type CaseTeamPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseTeamPermission.
     */
    data: XOR<CaseTeamPermissionUpdateInput, CaseTeamPermissionUncheckedUpdateInput>
    /**
     * Choose, which CaseTeamPermission to update.
     */
    where: CaseTeamPermissionWhereUniqueInput
  }

  /**
   * CaseTeamPermission updateMany
   */
  export type CaseTeamPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseTeamPermissions.
     */
    data: XOR<CaseTeamPermissionUpdateManyMutationInput, CaseTeamPermissionUncheckedUpdateManyInput>
    /**
     * Filter which CaseTeamPermissions to update
     */
    where?: CaseTeamPermissionWhereInput
    /**
     * Limit how many CaseTeamPermissions to update.
     */
    limit?: number
  }

  /**
   * CaseTeamPermission updateManyAndReturn
   */
  export type CaseTeamPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * The data used to update CaseTeamPermissions.
     */
    data: XOR<CaseTeamPermissionUpdateManyMutationInput, CaseTeamPermissionUncheckedUpdateManyInput>
    /**
     * Filter which CaseTeamPermissions to update
     */
    where?: CaseTeamPermissionWhereInput
    /**
     * Limit how many CaseTeamPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseTeamPermission upsert
   */
  export type CaseTeamPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseTeamPermission to update in case it exists.
     */
    where: CaseTeamPermissionWhereUniqueInput
    /**
     * In case the CaseTeamPermission found by the `where` argument doesn't exist, create a new CaseTeamPermission with this data.
     */
    create: XOR<CaseTeamPermissionCreateInput, CaseTeamPermissionUncheckedCreateInput>
    /**
     * In case the CaseTeamPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseTeamPermissionUpdateInput, CaseTeamPermissionUncheckedUpdateInput>
  }

  /**
   * CaseTeamPermission delete
   */
  export type CaseTeamPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter which CaseTeamPermission to delete.
     */
    where: CaseTeamPermissionWhereUniqueInput
  }

  /**
   * CaseTeamPermission deleteMany
   */
  export type CaseTeamPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseTeamPermissions to delete
     */
    where?: CaseTeamPermissionWhereInput
    /**
     * Limit how many CaseTeamPermissions to delete.
     */
    limit?: number
  }

  /**
   * CaseTeamPermission without action
   */
  export type CaseTeamPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTeamPermission
     */
    select?: CaseTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTeamPermission
     */
    omit?: CaseTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTeamPermissionInclude<ExtArgs> | null
  }


  /**
   * Model CaseInvite
   */

  export type AggregateCaseInvite = {
    _count: CaseInviteCountAggregateOutputType | null
    _min: CaseInviteMinAggregateOutputType | null
    _max: CaseInviteMaxAggregateOutputType | null
  }

  export type CaseInviteMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    email: string | null
    permission: $Enums.PermissionLevel | null
    inviteToken: string | null
    inviteExpiresAt: Date | null
    acceptedAt: Date | null
    acceptedById: string | null
    invitedById: string | null
    createdAt: Date | null
  }

  export type CaseInviteMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    email: string | null
    permission: $Enums.PermissionLevel | null
    inviteToken: string | null
    inviteExpiresAt: Date | null
    acceptedAt: Date | null
    acceptedById: string | null
    invitedById: string | null
    createdAt: Date | null
  }

  export type CaseInviteCountAggregateOutputType = {
    id: number
    caseId: number
    email: number
    permission: number
    inviteToken: number
    inviteExpiresAt: number
    acceptedAt: number
    acceptedById: number
    invitedById: number
    createdAt: number
    _all: number
  }


  export type CaseInviteMinAggregateInputType = {
    id?: true
    caseId?: true
    email?: true
    permission?: true
    inviteToken?: true
    inviteExpiresAt?: true
    acceptedAt?: true
    acceptedById?: true
    invitedById?: true
    createdAt?: true
  }

  export type CaseInviteMaxAggregateInputType = {
    id?: true
    caseId?: true
    email?: true
    permission?: true
    inviteToken?: true
    inviteExpiresAt?: true
    acceptedAt?: true
    acceptedById?: true
    invitedById?: true
    createdAt?: true
  }

  export type CaseInviteCountAggregateInputType = {
    id?: true
    caseId?: true
    email?: true
    permission?: true
    inviteToken?: true
    inviteExpiresAt?: true
    acceptedAt?: true
    acceptedById?: true
    invitedById?: true
    createdAt?: true
    _all?: true
  }

  export type CaseInviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseInvite to aggregate.
     */
    where?: CaseInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseInvites to fetch.
     */
    orderBy?: CaseInviteOrderByWithRelationInput | CaseInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CaseInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CaseInvites
    **/
    _count?: true | CaseInviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CaseInviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CaseInviteMaxAggregateInputType
  }

  export type GetCaseInviteAggregateType<T extends CaseInviteAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseInvite[P]>
      : GetScalarType<T[P], AggregateCaseInvite[P]>
  }




  export type CaseInviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseInviteWhereInput
    orderBy?: CaseInviteOrderByWithAggregationInput | CaseInviteOrderByWithAggregationInput[]
    by: CaseInviteScalarFieldEnum[] | CaseInviteScalarFieldEnum
    having?: CaseInviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseInviteCountAggregateInputType | true
    _min?: CaseInviteMinAggregateInputType
    _max?: CaseInviteMaxAggregateInputType
  }

  export type CaseInviteGroupByOutputType = {
    id: string
    caseId: string
    email: string
    permission: $Enums.PermissionLevel
    inviteToken: string
    inviteExpiresAt: Date
    acceptedAt: Date | null
    acceptedById: string | null
    invitedById: string
    createdAt: Date
    _count: CaseInviteCountAggregateOutputType | null
    _min: CaseInviteMinAggregateOutputType | null
    _max: CaseInviteMaxAggregateOutputType | null
  }

  type GetCaseInviteGroupByPayload<T extends CaseInviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseInviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseInviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseInviteGroupByOutputType[P]>
            : GetScalarType<T[P], CaseInviteGroupByOutputType[P]>
        }
      >
    >


  export type CaseInviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    email?: boolean
    permission?: boolean
    inviteToken?: boolean
    inviteExpiresAt?: boolean
    acceptedAt?: boolean
    acceptedById?: boolean
    invitedById?: boolean
    createdAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseInvite"]>

  export type CaseInviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    email?: boolean
    permission?: boolean
    inviteToken?: boolean
    inviteExpiresAt?: boolean
    acceptedAt?: boolean
    acceptedById?: boolean
    invitedById?: boolean
    createdAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseInvite"]>

  export type CaseInviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    email?: boolean
    permission?: boolean
    inviteToken?: boolean
    inviteExpiresAt?: boolean
    acceptedAt?: boolean
    acceptedById?: boolean
    invitedById?: boolean
    createdAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseInvite"]>

  export type CaseInviteSelectScalar = {
    id?: boolean
    caseId?: boolean
    email?: boolean
    permission?: boolean
    inviteToken?: boolean
    inviteExpiresAt?: boolean
    acceptedAt?: boolean
    acceptedById?: boolean
    invitedById?: boolean
    createdAt?: boolean
  }

  export type CaseInviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "email" | "permission" | "inviteToken" | "inviteExpiresAt" | "acceptedAt" | "acceptedById" | "invitedById" | "createdAt", ExtArgs["result"]["caseInvite"]>
  export type CaseInviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }
  export type CaseInviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }
  export type CaseInviteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }

  export type $CaseInvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseInvite"
    objects: {
      case: Prisma.$AssuranceCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      email: string
      permission: $Enums.PermissionLevel
      inviteToken: string
      inviteExpiresAt: Date
      acceptedAt: Date | null
      acceptedById: string | null
      invitedById: string
      createdAt: Date
    }, ExtArgs["result"]["caseInvite"]>
    composites: {}
  }

  type CaseInviteGetPayload<S extends boolean | null | undefined | CaseInviteDefaultArgs> = $Result.GetResult<Prisma.$CaseInvitePayload, S>

  type CaseInviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseInviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseInviteCountAggregateInputType | true
    }

  export interface CaseInviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseInvite'], meta: { name: 'CaseInvite' } }
    /**
     * Find zero or one CaseInvite that matches the filter.
     * @param {CaseInviteFindUniqueArgs} args - Arguments to find a CaseInvite
     * @example
     * // Get one CaseInvite
     * const caseInvite = await prisma.caseInvite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseInviteFindUniqueArgs>(args: SelectSubset<T, CaseInviteFindUniqueArgs<ExtArgs>>): Prisma__CaseInviteClient<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseInvite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseInviteFindUniqueOrThrowArgs} args - Arguments to find a CaseInvite
     * @example
     * // Get one CaseInvite
     * const caseInvite = await prisma.caseInvite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseInviteFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseInviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseInviteClient<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseInvite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseInviteFindFirstArgs} args - Arguments to find a CaseInvite
     * @example
     * // Get one CaseInvite
     * const caseInvite = await prisma.caseInvite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseInviteFindFirstArgs>(args?: SelectSubset<T, CaseInviteFindFirstArgs<ExtArgs>>): Prisma__CaseInviteClient<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseInvite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseInviteFindFirstOrThrowArgs} args - Arguments to find a CaseInvite
     * @example
     * // Get one CaseInvite
     * const caseInvite = await prisma.caseInvite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseInviteFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseInviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseInviteClient<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseInvites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseInviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseInvites
     * const caseInvites = await prisma.caseInvite.findMany()
     *
     * // Get first 10 CaseInvites
     * const caseInvites = await prisma.caseInvite.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const caseInviteWithIdOnly = await prisma.caseInvite.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CaseInviteFindManyArgs>(args?: SelectSubset<T, CaseInviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseInvite.
     * @param {CaseInviteCreateArgs} args - Arguments to create a CaseInvite.
     * @example
     * // Create one CaseInvite
     * const CaseInvite = await prisma.caseInvite.create({
     *   data: {
     *     // ... data to create a CaseInvite
     *   }
     * })
     *
     */
    create<T extends CaseInviteCreateArgs>(args: SelectSubset<T, CaseInviteCreateArgs<ExtArgs>>): Prisma__CaseInviteClient<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseInvites.
     * @param {CaseInviteCreateManyArgs} args - Arguments to create many CaseInvites.
     * @example
     * // Create many CaseInvites
     * const caseInvite = await prisma.caseInvite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CaseInviteCreateManyArgs>(args?: SelectSubset<T, CaseInviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseInvites and returns the data saved in the database.
     * @param {CaseInviteCreateManyAndReturnArgs} args - Arguments to create many CaseInvites.
     * @example
     * // Create many CaseInvites
     * const caseInvite = await prisma.caseInvite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CaseInvites and only return the `id`
     * const caseInviteWithIdOnly = await prisma.caseInvite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CaseInviteCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseInviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseInvite.
     * @param {CaseInviteDeleteArgs} args - Arguments to delete one CaseInvite.
     * @example
     * // Delete one CaseInvite
     * const CaseInvite = await prisma.caseInvite.delete({
     *   where: {
     *     // ... filter to delete one CaseInvite
     *   }
     * })
     *
     */
    delete<T extends CaseInviteDeleteArgs>(args: SelectSubset<T, CaseInviteDeleteArgs<ExtArgs>>): Prisma__CaseInviteClient<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseInvite.
     * @param {CaseInviteUpdateArgs} args - Arguments to update one CaseInvite.
     * @example
     * // Update one CaseInvite
     * const caseInvite = await prisma.caseInvite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CaseInviteUpdateArgs>(args: SelectSubset<T, CaseInviteUpdateArgs<ExtArgs>>): Prisma__CaseInviteClient<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseInvites.
     * @param {CaseInviteDeleteManyArgs} args - Arguments to filter CaseInvites to delete.
     * @example
     * // Delete a few CaseInvites
     * const { count } = await prisma.caseInvite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CaseInviteDeleteManyArgs>(args?: SelectSubset<T, CaseInviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseInviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseInvites
     * const caseInvite = await prisma.caseInvite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CaseInviteUpdateManyArgs>(args: SelectSubset<T, CaseInviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseInvites and returns the data updated in the database.
     * @param {CaseInviteUpdateManyAndReturnArgs} args - Arguments to update many CaseInvites.
     * @example
     * // Update many CaseInvites
     * const caseInvite = await prisma.caseInvite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CaseInvites and only return the `id`
     * const caseInviteWithIdOnly = await prisma.caseInvite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CaseInviteUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseInviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseInvite.
     * @param {CaseInviteUpsertArgs} args - Arguments to update or create a CaseInvite.
     * @example
     * // Update or create a CaseInvite
     * const caseInvite = await prisma.caseInvite.upsert({
     *   create: {
     *     // ... data to create a CaseInvite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseInvite we want to update
     *   }
     * })
     */
    upsert<T extends CaseInviteUpsertArgs>(args: SelectSubset<T, CaseInviteUpsertArgs<ExtArgs>>): Prisma__CaseInviteClient<$Result.GetResult<Prisma.$CaseInvitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseInvites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseInviteCountArgs} args - Arguments to filter CaseInvites to count.
     * @example
     * // Count the number of CaseInvites
     * const count = await prisma.caseInvite.count({
     *   where: {
     *     // ... the filter for the CaseInvites we want to count
     *   }
     * })
    **/
    count<T extends CaseInviteCountArgs>(
      args?: Subset<T, CaseInviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseInviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseInviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseInviteAggregateArgs>(args: Subset<T, CaseInviteAggregateArgs>): Prisma.PrismaPromise<GetCaseInviteAggregateType<T>>

    /**
     * Group by CaseInvite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseInviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CaseInviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseInviteGroupByArgs['orderBy'] }
        : { orderBy?: CaseInviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseInviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseInvite model
   */
  readonly fields: CaseInviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseInvite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseInviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends AssuranceCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCaseDefaultArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseInvite model
   */
  interface CaseInviteFieldRefs {
    readonly id: FieldRef<"CaseInvite", 'String'>
    readonly caseId: FieldRef<"CaseInvite", 'String'>
    readonly email: FieldRef<"CaseInvite", 'String'>
    readonly permission: FieldRef<"CaseInvite", 'PermissionLevel'>
    readonly inviteToken: FieldRef<"CaseInvite", 'String'>
    readonly inviteExpiresAt: FieldRef<"CaseInvite", 'DateTime'>
    readonly acceptedAt: FieldRef<"CaseInvite", 'DateTime'>
    readonly acceptedById: FieldRef<"CaseInvite", 'String'>
    readonly invitedById: FieldRef<"CaseInvite", 'String'>
    readonly createdAt: FieldRef<"CaseInvite", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * CaseInvite findUnique
   */
  export type CaseInviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    /**
     * Filter, which CaseInvite to fetch.
     */
    where: CaseInviteWhereUniqueInput
  }

  /**
   * CaseInvite findUniqueOrThrow
   */
  export type CaseInviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    /**
     * Filter, which CaseInvite to fetch.
     */
    where: CaseInviteWhereUniqueInput
  }

  /**
   * CaseInvite findFirst
   */
  export type CaseInviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    /**
     * Filter, which CaseInvite to fetch.
     */
    where?: CaseInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseInvites to fetch.
     */
    orderBy?: CaseInviteOrderByWithRelationInput | CaseInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseInvites.
     */
    cursor?: CaseInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseInvites.
     */
    distinct?: CaseInviteScalarFieldEnum | CaseInviteScalarFieldEnum[]
  }

  /**
   * CaseInvite findFirstOrThrow
   */
  export type CaseInviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    /**
     * Filter, which CaseInvite to fetch.
     */
    where?: CaseInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseInvites to fetch.
     */
    orderBy?: CaseInviteOrderByWithRelationInput | CaseInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseInvites.
     */
    cursor?: CaseInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseInvites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseInvites.
     */
    distinct?: CaseInviteScalarFieldEnum | CaseInviteScalarFieldEnum[]
  }

  /**
   * CaseInvite findMany
   */
  export type CaseInviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    /**
     * Filter, which CaseInvites to fetch.
     */
    where?: CaseInviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseInvites to fetch.
     */
    orderBy?: CaseInviteOrderByWithRelationInput | CaseInviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CaseInvites.
     */
    cursor?: CaseInviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseInvites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseInvites.
     */
    skip?: number
    distinct?: CaseInviteScalarFieldEnum | CaseInviteScalarFieldEnum[]
  }

  /**
   * CaseInvite create
   */
  export type CaseInviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseInvite.
     */
    data: XOR<CaseInviteCreateInput, CaseInviteUncheckedCreateInput>
  }

  /**
   * CaseInvite createMany
   */
  export type CaseInviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseInvites.
     */
    data: CaseInviteCreateManyInput | CaseInviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseInvite createManyAndReturn
   */
  export type CaseInviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * The data used to create many CaseInvites.
     */
    data: CaseInviteCreateManyInput | CaseInviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseInvite update
   */
  export type CaseInviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseInvite.
     */
    data: XOR<CaseInviteUpdateInput, CaseInviteUncheckedUpdateInput>
    /**
     * Choose, which CaseInvite to update.
     */
    where: CaseInviteWhereUniqueInput
  }

  /**
   * CaseInvite updateMany
   */
  export type CaseInviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseInvites.
     */
    data: XOR<CaseInviteUpdateManyMutationInput, CaseInviteUncheckedUpdateManyInput>
    /**
     * Filter which CaseInvites to update
     */
    where?: CaseInviteWhereInput
    /**
     * Limit how many CaseInvites to update.
     */
    limit?: number
  }

  /**
   * CaseInvite updateManyAndReturn
   */
  export type CaseInviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * The data used to update CaseInvites.
     */
    data: XOR<CaseInviteUpdateManyMutationInput, CaseInviteUncheckedUpdateManyInput>
    /**
     * Filter which CaseInvites to update
     */
    where?: CaseInviteWhereInput
    /**
     * Limit how many CaseInvites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseInvite upsert
   */
  export type CaseInviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseInvite to update in case it exists.
     */
    where: CaseInviteWhereUniqueInput
    /**
     * In case the CaseInvite found by the `where` argument doesn't exist, create a new CaseInvite with this data.
     */
    create: XOR<CaseInviteCreateInput, CaseInviteUncheckedCreateInput>
    /**
     * In case the CaseInvite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseInviteUpdateInput, CaseInviteUncheckedUpdateInput>
  }

  /**
   * CaseInvite delete
   */
  export type CaseInviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
    /**
     * Filter which CaseInvite to delete.
     */
    where: CaseInviteWhereUniqueInput
  }

  /**
   * CaseInvite deleteMany
   */
  export type CaseInviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseInvites to delete
     */
    where?: CaseInviteWhereInput
    /**
     * Limit how many CaseInvites to delete.
     */
    limit?: number
  }

  /**
   * CaseInvite without action
   */
  export type CaseInviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseInvite
     */
    select?: CaseInviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseInvite
     */
    omit?: CaseInviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseInviteInclude<ExtArgs> | null
  }


  /**
   * Model AssuranceElement
   */

  export type AggregateAssuranceElement = {
    _count: AssuranceElementCountAggregateOutputType | null
    _avg: AssuranceElementAvgAggregateOutputType | null
    _sum: AssuranceElementSumAggregateOutputType | null
    _min: AssuranceElementMinAggregateOutputType | null
    _max: AssuranceElementMaxAggregateOutputType | null
  }

  export type AssuranceElementAvgAggregateOutputType = {
    level: number | null
  }

  export type AssuranceElementSumAggregateOutputType = {
    level: number | null
  }

  export type AssuranceElementMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    elementType: $Enums.ElementType | null
    role: $Enums.ElementRole | null
    parentId: string | null
    name: string | null
    description: string | null
    assumption: string | null
    justification: string | null
    url: string | null
    moduleReferenceId: string | null
    moduleEmbedType: $Enums.ModuleEmbedType | null
    modulePublicSummary: string | null
    fromPattern: boolean | null
    modifiedFromPattern: boolean | null
    inSandbox: boolean | null
    isDefeater: boolean | null
    defeatsElementId: string | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type AssuranceElementMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    elementType: $Enums.ElementType | null
    role: $Enums.ElementRole | null
    parentId: string | null
    name: string | null
    description: string | null
    assumption: string | null
    justification: string | null
    url: string | null
    moduleReferenceId: string | null
    moduleEmbedType: $Enums.ModuleEmbedType | null
    modulePublicSummary: string | null
    fromPattern: boolean | null
    modifiedFromPattern: boolean | null
    inSandbox: boolean | null
    isDefeater: boolean | null
    defeatsElementId: string | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
    createdById: string | null
  }

  export type AssuranceElementCountAggregateOutputType = {
    id: number
    caseId: number
    elementType: number
    role: number
    parentId: number
    name: number
    description: number
    assumption: number
    justification: number
    url: number
    moduleReferenceId: number
    moduleEmbedType: number
    modulePublicSummary: number
    fromPattern: number
    modifiedFromPattern: number
    inSandbox: number
    isDefeater: number
    defeatsElementId: number
    level: number
    createdAt: number
    updatedAt: number
    createdById: number
    _all: number
  }


  export type AssuranceElementAvgAggregateInputType = {
    level?: true
  }

  export type AssuranceElementSumAggregateInputType = {
    level?: true
  }

  export type AssuranceElementMinAggregateInputType = {
    id?: true
    caseId?: true
    elementType?: true
    role?: true
    parentId?: true
    name?: true
    description?: true
    assumption?: true
    justification?: true
    url?: true
    moduleReferenceId?: true
    moduleEmbedType?: true
    modulePublicSummary?: true
    fromPattern?: true
    modifiedFromPattern?: true
    inSandbox?: true
    isDefeater?: true
    defeatsElementId?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type AssuranceElementMaxAggregateInputType = {
    id?: true
    caseId?: true
    elementType?: true
    role?: true
    parentId?: true
    name?: true
    description?: true
    assumption?: true
    justification?: true
    url?: true
    moduleReferenceId?: true
    moduleEmbedType?: true
    modulePublicSummary?: true
    fromPattern?: true
    modifiedFromPattern?: true
    inSandbox?: true
    isDefeater?: true
    defeatsElementId?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
  }

  export type AssuranceElementCountAggregateInputType = {
    id?: true
    caseId?: true
    elementType?: true
    role?: true
    parentId?: true
    name?: true
    description?: true
    assumption?: true
    justification?: true
    url?: true
    moduleReferenceId?: true
    moduleEmbedType?: true
    modulePublicSummary?: true
    fromPattern?: true
    modifiedFromPattern?: true
    inSandbox?: true
    isDefeater?: true
    defeatsElementId?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    createdById?: true
    _all?: true
  }

  export type AssuranceElementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssuranceElement to aggregate.
     */
    where?: AssuranceElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssuranceElements to fetch.
     */
    orderBy?: AssuranceElementOrderByWithRelationInput | AssuranceElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AssuranceElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssuranceElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssuranceElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AssuranceElements
    **/
    _count?: true | AssuranceElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: AssuranceElementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: AssuranceElementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: AssuranceElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: AssuranceElementMaxAggregateInputType
  }

  export type GetAssuranceElementAggregateType<T extends AssuranceElementAggregateArgs> = {
        [P in keyof T & keyof AggregateAssuranceElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssuranceElement[P]>
      : GetScalarType<T[P], AggregateAssuranceElement[P]>
  }




  export type AssuranceElementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssuranceElementWhereInput
    orderBy?: AssuranceElementOrderByWithAggregationInput | AssuranceElementOrderByWithAggregationInput[]
    by: AssuranceElementScalarFieldEnum[] | AssuranceElementScalarFieldEnum
    having?: AssuranceElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssuranceElementCountAggregateInputType | true
    _avg?: AssuranceElementAvgAggregateInputType
    _sum?: AssuranceElementSumAggregateInputType
    _min?: AssuranceElementMinAggregateInputType
    _max?: AssuranceElementMaxAggregateInputType
  }

  export type AssuranceElementGroupByOutputType = {
    id: string
    caseId: string
    elementType: $Enums.ElementType
    role: $Enums.ElementRole | null
    parentId: string | null
    name: string | null
    description: string
    assumption: string | null
    justification: string | null
    url: string | null
    moduleReferenceId: string | null
    moduleEmbedType: $Enums.ModuleEmbedType | null
    modulePublicSummary: string | null
    fromPattern: boolean
    modifiedFromPattern: boolean
    inSandbox: boolean
    isDefeater: boolean
    defeatsElementId: string | null
    level: number | null
    createdAt: Date
    updatedAt: Date
    createdById: string
    _count: AssuranceElementCountAggregateOutputType | null
    _avg: AssuranceElementAvgAggregateOutputType | null
    _sum: AssuranceElementSumAggregateOutputType | null
    _min: AssuranceElementMinAggregateOutputType | null
    _max: AssuranceElementMaxAggregateOutputType | null
  }

  type GetAssuranceElementGroupByPayload<T extends AssuranceElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssuranceElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssuranceElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssuranceElementGroupByOutputType[P]>
            : GetScalarType<T[P], AssuranceElementGroupByOutputType[P]>
        }
      >
    >


  export type AssuranceElementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    elementType?: boolean
    role?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    assumption?: boolean
    justification?: boolean
    url?: boolean
    moduleReferenceId?: boolean
    moduleEmbedType?: boolean
    modulePublicSummary?: boolean
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | AssuranceElement$parentArgs<ExtArgs>
    children?: boolean | AssuranceElement$childrenArgs<ExtArgs>
    defeatsElement?: boolean | AssuranceElement$defeatsElementArgs<ExtArgs>
    defeatedBy?: boolean | AssuranceElement$defeatedByArgs<ExtArgs>
    moduleReference?: boolean | AssuranceElement$moduleReferenceArgs<ExtArgs>
    evidenceLinksFrom?: boolean | AssuranceElement$evidenceLinksFromArgs<ExtArgs>
    evidenceLinksTo?: boolean | AssuranceElement$evidenceLinksToArgs<ExtArgs>
    comments?: boolean | AssuranceElement$commentsArgs<ExtArgs>
    releaseComments?: boolean | AssuranceElement$releaseCommentsArgs<ExtArgs>
    _count?: boolean | AssuranceElementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assuranceElement"]>

  export type AssuranceElementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    elementType?: boolean
    role?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    assumption?: boolean
    justification?: boolean
    url?: boolean
    moduleReferenceId?: boolean
    moduleEmbedType?: boolean
    modulePublicSummary?: boolean
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | AssuranceElement$parentArgs<ExtArgs>
    defeatsElement?: boolean | AssuranceElement$defeatsElementArgs<ExtArgs>
    moduleReference?: boolean | AssuranceElement$moduleReferenceArgs<ExtArgs>
  }, ExtArgs["result"]["assuranceElement"]>

  export type AssuranceElementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    elementType?: boolean
    role?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    assumption?: boolean
    justification?: boolean
    url?: boolean
    moduleReferenceId?: boolean
    moduleEmbedType?: boolean
    modulePublicSummary?: boolean
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | AssuranceElement$parentArgs<ExtArgs>
    defeatsElement?: boolean | AssuranceElement$defeatsElementArgs<ExtArgs>
    moduleReference?: boolean | AssuranceElement$moduleReferenceArgs<ExtArgs>
  }, ExtArgs["result"]["assuranceElement"]>

  export type AssuranceElementSelectScalar = {
    id?: boolean
    caseId?: boolean
    elementType?: boolean
    role?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    assumption?: boolean
    justification?: boolean
    url?: boolean
    moduleReferenceId?: boolean
    moduleEmbedType?: boolean
    modulePublicSummary?: boolean
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdById?: boolean
  }

  export type AssuranceElementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "elementType" | "role" | "parentId" | "name" | "description" | "assumption" | "justification" | "url" | "moduleReferenceId" | "moduleEmbedType" | "modulePublicSummary" | "fromPattern" | "modifiedFromPattern" | "inSandbox" | "isDefeater" | "defeatsElementId" | "level" | "createdAt" | "updatedAt" | "createdById", ExtArgs["result"]["assuranceElement"]>
  export type AssuranceElementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | AssuranceElement$parentArgs<ExtArgs>
    children?: boolean | AssuranceElement$childrenArgs<ExtArgs>
    defeatsElement?: boolean | AssuranceElement$defeatsElementArgs<ExtArgs>
    defeatedBy?: boolean | AssuranceElement$defeatedByArgs<ExtArgs>
    moduleReference?: boolean | AssuranceElement$moduleReferenceArgs<ExtArgs>
    evidenceLinksFrom?: boolean | AssuranceElement$evidenceLinksFromArgs<ExtArgs>
    evidenceLinksTo?: boolean | AssuranceElement$evidenceLinksToArgs<ExtArgs>
    comments?: boolean | AssuranceElement$commentsArgs<ExtArgs>
    releaseComments?: boolean | AssuranceElement$releaseCommentsArgs<ExtArgs>
    _count?: boolean | AssuranceElementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssuranceElementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | AssuranceElement$parentArgs<ExtArgs>
    defeatsElement?: boolean | AssuranceElement$defeatsElementArgs<ExtArgs>
    moduleReference?: boolean | AssuranceElement$moduleReferenceArgs<ExtArgs>
  }
  export type AssuranceElementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | AssuranceElement$parentArgs<ExtArgs>
    defeatsElement?: boolean | AssuranceElement$defeatsElementArgs<ExtArgs>
    moduleReference?: boolean | AssuranceElement$moduleReferenceArgs<ExtArgs>
  }

  export type $AssuranceElementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AssuranceElement"
    objects: {
      case: Prisma.$AssuranceCasePayload<ExtArgs>
      createdBy: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$AssuranceElementPayload<ExtArgs> | null
      children: Prisma.$AssuranceElementPayload<ExtArgs>[]
      defeatsElement: Prisma.$AssuranceElementPayload<ExtArgs> | null
      defeatedBy: Prisma.$AssuranceElementPayload<ExtArgs>[]
      moduleReference: Prisma.$AssuranceCasePayload<ExtArgs> | null
      evidenceLinksFrom: Prisma.$EvidenceLinkPayload<ExtArgs>[]
      evidenceLinksTo: Prisma.$EvidenceLinkPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      releaseComments: Prisma.$ReleaseCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      elementType: $Enums.ElementType
      role: $Enums.ElementRole | null
      parentId: string | null
      name: string | null
      description: string
      assumption: string | null
      justification: string | null
      url: string | null
      moduleReferenceId: string | null
      moduleEmbedType: $Enums.ModuleEmbedType | null
      modulePublicSummary: string | null
      fromPattern: boolean
      modifiedFromPattern: boolean
      inSandbox: boolean
      isDefeater: boolean
      defeatsElementId: string | null
      level: number | null
      createdAt: Date
      updatedAt: Date
      createdById: string
    }, ExtArgs["result"]["assuranceElement"]>
    composites: {}
  }

  type AssuranceElementGetPayload<S extends boolean | null | undefined | AssuranceElementDefaultArgs> = $Result.GetResult<Prisma.$AssuranceElementPayload, S>

  type AssuranceElementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssuranceElementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssuranceElementCountAggregateInputType | true
    }

  export interface AssuranceElementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AssuranceElement'], meta: { name: 'AssuranceElement' } }
    /**
     * Find zero or one AssuranceElement that matches the filter.
     * @param {AssuranceElementFindUniqueArgs} args - Arguments to find a AssuranceElement
     * @example
     * // Get one AssuranceElement
     * const assuranceElement = await prisma.assuranceElement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssuranceElementFindUniqueArgs>(args: SelectSubset<T, AssuranceElementFindUniqueArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AssuranceElement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssuranceElementFindUniqueOrThrowArgs} args - Arguments to find a AssuranceElement
     * @example
     * // Get one AssuranceElement
     * const assuranceElement = await prisma.assuranceElement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssuranceElementFindUniqueOrThrowArgs>(args: SelectSubset<T, AssuranceElementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssuranceElement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceElementFindFirstArgs} args - Arguments to find a AssuranceElement
     * @example
     * // Get one AssuranceElement
     * const assuranceElement = await prisma.assuranceElement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssuranceElementFindFirstArgs>(args?: SelectSubset<T, AssuranceElementFindFirstArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AssuranceElement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceElementFindFirstOrThrowArgs} args - Arguments to find a AssuranceElement
     * @example
     * // Get one AssuranceElement
     * const assuranceElement = await prisma.assuranceElement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssuranceElementFindFirstOrThrowArgs>(args?: SelectSubset<T, AssuranceElementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AssuranceElements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceElementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AssuranceElements
     * const assuranceElements = await prisma.assuranceElement.findMany()
     *
     * // Get first 10 AssuranceElements
     * const assuranceElements = await prisma.assuranceElement.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const assuranceElementWithIdOnly = await prisma.assuranceElement.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AssuranceElementFindManyArgs>(args?: SelectSubset<T, AssuranceElementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AssuranceElement.
     * @param {AssuranceElementCreateArgs} args - Arguments to create a AssuranceElement.
     * @example
     * // Create one AssuranceElement
     * const AssuranceElement = await prisma.assuranceElement.create({
     *   data: {
     *     // ... data to create a AssuranceElement
     *   }
     * })
     *
     */
    create<T extends AssuranceElementCreateArgs>(args: SelectSubset<T, AssuranceElementCreateArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AssuranceElements.
     * @param {AssuranceElementCreateManyArgs} args - Arguments to create many AssuranceElements.
     * @example
     * // Create many AssuranceElements
     * const assuranceElement = await prisma.assuranceElement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AssuranceElementCreateManyArgs>(args?: SelectSubset<T, AssuranceElementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AssuranceElements and returns the data saved in the database.
     * @param {AssuranceElementCreateManyAndReturnArgs} args - Arguments to create many AssuranceElements.
     * @example
     * // Create many AssuranceElements
     * const assuranceElement = await prisma.assuranceElement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many AssuranceElements and only return the `id`
     * const assuranceElementWithIdOnly = await prisma.assuranceElement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends AssuranceElementCreateManyAndReturnArgs>(args?: SelectSubset<T, AssuranceElementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AssuranceElement.
     * @param {AssuranceElementDeleteArgs} args - Arguments to delete one AssuranceElement.
     * @example
     * // Delete one AssuranceElement
     * const AssuranceElement = await prisma.assuranceElement.delete({
     *   where: {
     *     // ... filter to delete one AssuranceElement
     *   }
     * })
     *
     */
    delete<T extends AssuranceElementDeleteArgs>(args: SelectSubset<T, AssuranceElementDeleteArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AssuranceElement.
     * @param {AssuranceElementUpdateArgs} args - Arguments to update one AssuranceElement.
     * @example
     * // Update one AssuranceElement
     * const assuranceElement = await prisma.assuranceElement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AssuranceElementUpdateArgs>(args: SelectSubset<T, AssuranceElementUpdateArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AssuranceElements.
     * @param {AssuranceElementDeleteManyArgs} args - Arguments to filter AssuranceElements to delete.
     * @example
     * // Delete a few AssuranceElements
     * const { count } = await prisma.assuranceElement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AssuranceElementDeleteManyArgs>(args?: SelectSubset<T, AssuranceElementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssuranceElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AssuranceElements
     * const assuranceElement = await prisma.assuranceElement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AssuranceElementUpdateManyArgs>(args: SelectSubset<T, AssuranceElementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AssuranceElements and returns the data updated in the database.
     * @param {AssuranceElementUpdateManyAndReturnArgs} args - Arguments to update many AssuranceElements.
     * @example
     * // Update many AssuranceElements
     * const assuranceElement = await prisma.assuranceElement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more AssuranceElements and only return the `id`
     * const assuranceElementWithIdOnly = await prisma.assuranceElement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends AssuranceElementUpdateManyAndReturnArgs>(args: SelectSubset<T, AssuranceElementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AssuranceElement.
     * @param {AssuranceElementUpsertArgs} args - Arguments to update or create a AssuranceElement.
     * @example
     * // Update or create a AssuranceElement
     * const assuranceElement = await prisma.assuranceElement.upsert({
     *   create: {
     *     // ... data to create a AssuranceElement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AssuranceElement we want to update
     *   }
     * })
     */
    upsert<T extends AssuranceElementUpsertArgs>(args: SelectSubset<T, AssuranceElementUpsertArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AssuranceElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceElementCountArgs} args - Arguments to filter AssuranceElements to count.
     * @example
     * // Count the number of AssuranceElements
     * const count = await prisma.assuranceElement.count({
     *   where: {
     *     // ... the filter for the AssuranceElements we want to count
     *   }
     * })
    **/
    count<T extends AssuranceElementCountArgs>(
      args?: Subset<T, AssuranceElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssuranceElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AssuranceElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssuranceElementAggregateArgs>(args: Subset<T, AssuranceElementAggregateArgs>): Prisma.PrismaPromise<GetAssuranceElementAggregateType<T>>

    /**
     * Group by AssuranceElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssuranceElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends AssuranceElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssuranceElementGroupByArgs['orderBy'] }
        : { orderBy?: AssuranceElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssuranceElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssuranceElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AssuranceElement model
   */
  readonly fields: AssuranceElementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AssuranceElement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssuranceElementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends AssuranceCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCaseDefaultArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends AssuranceElement$parentArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElement$parentArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends AssuranceElement$childrenArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElement$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    defeatsElement<T extends AssuranceElement$defeatsElementArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElement$defeatsElementArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    defeatedBy<T extends AssuranceElement$defeatedByArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElement$defeatedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    moduleReference<T extends AssuranceElement$moduleReferenceArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElement$moduleReferenceArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    evidenceLinksFrom<T extends AssuranceElement$evidenceLinksFromArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElement$evidenceLinksFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evidenceLinksTo<T extends AssuranceElement$evidenceLinksToArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElement$evidenceLinksToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends AssuranceElement$commentsArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElement$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    releaseComments<T extends AssuranceElement$releaseCommentsArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElement$releaseCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AssuranceElement model
   */
  interface AssuranceElementFieldRefs {
    readonly id: FieldRef<"AssuranceElement", 'String'>
    readonly caseId: FieldRef<"AssuranceElement", 'String'>
    readonly elementType: FieldRef<"AssuranceElement", 'ElementType'>
    readonly role: FieldRef<"AssuranceElement", 'ElementRole'>
    readonly parentId: FieldRef<"AssuranceElement", 'String'>
    readonly name: FieldRef<"AssuranceElement", 'String'>
    readonly description: FieldRef<"AssuranceElement", 'String'>
    readonly assumption: FieldRef<"AssuranceElement", 'String'>
    readonly justification: FieldRef<"AssuranceElement", 'String'>
    readonly url: FieldRef<"AssuranceElement", 'String'>
    readonly moduleReferenceId: FieldRef<"AssuranceElement", 'String'>
    readonly moduleEmbedType: FieldRef<"AssuranceElement", 'ModuleEmbedType'>
    readonly modulePublicSummary: FieldRef<"AssuranceElement", 'String'>
    readonly fromPattern: FieldRef<"AssuranceElement", 'Boolean'>
    readonly modifiedFromPattern: FieldRef<"AssuranceElement", 'Boolean'>
    readonly inSandbox: FieldRef<"AssuranceElement", 'Boolean'>
    readonly isDefeater: FieldRef<"AssuranceElement", 'Boolean'>
    readonly defeatsElementId: FieldRef<"AssuranceElement", 'String'>
    readonly level: FieldRef<"AssuranceElement", 'Int'>
    readonly createdAt: FieldRef<"AssuranceElement", 'DateTime'>
    readonly updatedAt: FieldRef<"AssuranceElement", 'DateTime'>
    readonly createdById: FieldRef<"AssuranceElement", 'String'>
  }


  // Custom InputTypes
  /**
   * AssuranceElement findUnique
   */
  export type AssuranceElementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceElement to fetch.
     */
    where: AssuranceElementWhereUniqueInput
  }

  /**
   * AssuranceElement findUniqueOrThrow
   */
  export type AssuranceElementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceElement to fetch.
     */
    where: AssuranceElementWhereUniqueInput
  }

  /**
   * AssuranceElement findFirst
   */
  export type AssuranceElementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceElement to fetch.
     */
    where?: AssuranceElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssuranceElements to fetch.
     */
    orderBy?: AssuranceElementOrderByWithRelationInput | AssuranceElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AssuranceElements.
     */
    cursor?: AssuranceElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssuranceElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssuranceElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AssuranceElements.
     */
    distinct?: AssuranceElementScalarFieldEnum | AssuranceElementScalarFieldEnum[]
  }

  /**
   * AssuranceElement findFirstOrThrow
   */
  export type AssuranceElementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceElement to fetch.
     */
    where?: AssuranceElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssuranceElements to fetch.
     */
    orderBy?: AssuranceElementOrderByWithRelationInput | AssuranceElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AssuranceElements.
     */
    cursor?: AssuranceElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssuranceElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssuranceElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AssuranceElements.
     */
    distinct?: AssuranceElementScalarFieldEnum | AssuranceElementScalarFieldEnum[]
  }

  /**
   * AssuranceElement findMany
   */
  export type AssuranceElementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    /**
     * Filter, which AssuranceElements to fetch.
     */
    where?: AssuranceElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AssuranceElements to fetch.
     */
    orderBy?: AssuranceElementOrderByWithRelationInput | AssuranceElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AssuranceElements.
     */
    cursor?: AssuranceElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AssuranceElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AssuranceElements.
     */
    skip?: number
    distinct?: AssuranceElementScalarFieldEnum | AssuranceElementScalarFieldEnum[]
  }

  /**
   * AssuranceElement create
   */
  export type AssuranceElementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    /**
     * The data needed to create a AssuranceElement.
     */
    data: XOR<AssuranceElementCreateInput, AssuranceElementUncheckedCreateInput>
  }

  /**
   * AssuranceElement createMany
   */
  export type AssuranceElementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AssuranceElements.
     */
    data: AssuranceElementCreateManyInput | AssuranceElementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AssuranceElement createManyAndReturn
   */
  export type AssuranceElementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * The data used to create many AssuranceElements.
     */
    data: AssuranceElementCreateManyInput | AssuranceElementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssuranceElement update
   */
  export type AssuranceElementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    /**
     * The data needed to update a AssuranceElement.
     */
    data: XOR<AssuranceElementUpdateInput, AssuranceElementUncheckedUpdateInput>
    /**
     * Choose, which AssuranceElement to update.
     */
    where: AssuranceElementWhereUniqueInput
  }

  /**
   * AssuranceElement updateMany
   */
  export type AssuranceElementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AssuranceElements.
     */
    data: XOR<AssuranceElementUpdateManyMutationInput, AssuranceElementUncheckedUpdateManyInput>
    /**
     * Filter which AssuranceElements to update
     */
    where?: AssuranceElementWhereInput
    /**
     * Limit how many AssuranceElements to update.
     */
    limit?: number
  }

  /**
   * AssuranceElement updateManyAndReturn
   */
  export type AssuranceElementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * The data used to update AssuranceElements.
     */
    data: XOR<AssuranceElementUpdateManyMutationInput, AssuranceElementUncheckedUpdateManyInput>
    /**
     * Filter which AssuranceElements to update
     */
    where?: AssuranceElementWhereInput
    /**
     * Limit how many AssuranceElements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AssuranceElement upsert
   */
  export type AssuranceElementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    /**
     * The filter to search for the AssuranceElement to update in case it exists.
     */
    where: AssuranceElementWhereUniqueInput
    /**
     * In case the AssuranceElement found by the `where` argument doesn't exist, create a new AssuranceElement with this data.
     */
    create: XOR<AssuranceElementCreateInput, AssuranceElementUncheckedCreateInput>
    /**
     * In case the AssuranceElement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssuranceElementUpdateInput, AssuranceElementUncheckedUpdateInput>
  }

  /**
   * AssuranceElement delete
   */
  export type AssuranceElementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    /**
     * Filter which AssuranceElement to delete.
     */
    where: AssuranceElementWhereUniqueInput
  }

  /**
   * AssuranceElement deleteMany
   */
  export type AssuranceElementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AssuranceElements to delete
     */
    where?: AssuranceElementWhereInput
    /**
     * Limit how many AssuranceElements to delete.
     */
    limit?: number
  }

  /**
   * AssuranceElement.parent
   */
  export type AssuranceElement$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    where?: AssuranceElementWhereInput
  }

  /**
   * AssuranceElement.children
   */
  export type AssuranceElement$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    where?: AssuranceElementWhereInput
    orderBy?: AssuranceElementOrderByWithRelationInput | AssuranceElementOrderByWithRelationInput[]
    cursor?: AssuranceElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssuranceElementScalarFieldEnum | AssuranceElementScalarFieldEnum[]
  }

  /**
   * AssuranceElement.defeatsElement
   */
  export type AssuranceElement$defeatsElementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    where?: AssuranceElementWhereInput
  }

  /**
   * AssuranceElement.defeatedBy
   */
  export type AssuranceElement$defeatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    where?: AssuranceElementWhereInput
    orderBy?: AssuranceElementOrderByWithRelationInput | AssuranceElementOrderByWithRelationInput[]
    cursor?: AssuranceElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssuranceElementScalarFieldEnum | AssuranceElementScalarFieldEnum[]
  }

  /**
   * AssuranceElement.moduleReference
   */
  export type AssuranceElement$moduleReferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    where?: AssuranceCaseWhereInput
  }

  /**
   * AssuranceElement.evidenceLinksFrom
   */
  export type AssuranceElement$evidenceLinksFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    where?: EvidenceLinkWhereInput
    orderBy?: EvidenceLinkOrderByWithRelationInput | EvidenceLinkOrderByWithRelationInput[]
    cursor?: EvidenceLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceLinkScalarFieldEnum | EvidenceLinkScalarFieldEnum[]
  }

  /**
   * AssuranceElement.evidenceLinksTo
   */
  export type AssuranceElement$evidenceLinksToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    where?: EvidenceLinkWhereInput
    orderBy?: EvidenceLinkOrderByWithRelationInput | EvidenceLinkOrderByWithRelationInput[]
    cursor?: EvidenceLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvidenceLinkScalarFieldEnum | EvidenceLinkScalarFieldEnum[]
  }

  /**
   * AssuranceElement.comments
   */
  export type AssuranceElement$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * AssuranceElement.releaseComments
   */
  export type AssuranceElement$releaseCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    where?: ReleaseCommentWhereInput
    orderBy?: ReleaseCommentOrderByWithRelationInput | ReleaseCommentOrderByWithRelationInput[]
    cursor?: ReleaseCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReleaseCommentScalarFieldEnum | ReleaseCommentScalarFieldEnum[]
  }

  /**
   * AssuranceElement without action
   */
  export type AssuranceElementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
  }


  /**
   * Model EvidenceLink
   */

  export type AggregateEvidenceLink = {
    _count: EvidenceLinkCountAggregateOutputType | null
    _min: EvidenceLinkMinAggregateOutputType | null
    _max: EvidenceLinkMaxAggregateOutputType | null
  }

  export type EvidenceLinkMinAggregateOutputType = {
    id: string | null
    evidenceId: string | null
    claimId: string | null
    createdAt: Date | null
  }

  export type EvidenceLinkMaxAggregateOutputType = {
    id: string | null
    evidenceId: string | null
    claimId: string | null
    createdAt: Date | null
  }

  export type EvidenceLinkCountAggregateOutputType = {
    id: number
    evidenceId: number
    claimId: number
    createdAt: number
    _all: number
  }


  export type EvidenceLinkMinAggregateInputType = {
    id?: true
    evidenceId?: true
    claimId?: true
    createdAt?: true
  }

  export type EvidenceLinkMaxAggregateInputType = {
    id?: true
    evidenceId?: true
    claimId?: true
    createdAt?: true
  }

  export type EvidenceLinkCountAggregateInputType = {
    id?: true
    evidenceId?: true
    claimId?: true
    createdAt?: true
    _all?: true
  }

  export type EvidenceLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvidenceLink to aggregate.
     */
    where?: EvidenceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EvidenceLinks to fetch.
     */
    orderBy?: EvidenceLinkOrderByWithRelationInput | EvidenceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: EvidenceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EvidenceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EvidenceLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned EvidenceLinks
    **/
    _count?: true | EvidenceLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: EvidenceLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: EvidenceLinkMaxAggregateInputType
  }

  export type GetEvidenceLinkAggregateType<T extends EvidenceLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateEvidenceLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvidenceLink[P]>
      : GetScalarType<T[P], AggregateEvidenceLink[P]>
  }




  export type EvidenceLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvidenceLinkWhereInput
    orderBy?: EvidenceLinkOrderByWithAggregationInput | EvidenceLinkOrderByWithAggregationInput[]
    by: EvidenceLinkScalarFieldEnum[] | EvidenceLinkScalarFieldEnum
    having?: EvidenceLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvidenceLinkCountAggregateInputType | true
    _min?: EvidenceLinkMinAggregateInputType
    _max?: EvidenceLinkMaxAggregateInputType
  }

  export type EvidenceLinkGroupByOutputType = {
    id: string
    evidenceId: string
    claimId: string
    createdAt: Date
    _count: EvidenceLinkCountAggregateOutputType | null
    _min: EvidenceLinkMinAggregateOutputType | null
    _max: EvidenceLinkMaxAggregateOutputType | null
  }

  type GetEvidenceLinkGroupByPayload<T extends EvidenceLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvidenceLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvidenceLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvidenceLinkGroupByOutputType[P]>
            : GetScalarType<T[P], EvidenceLinkGroupByOutputType[P]>
        }
      >
    >


  export type EvidenceLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evidenceId?: boolean
    claimId?: boolean
    createdAt?: boolean
    evidence?: boolean | AssuranceElementDefaultArgs<ExtArgs>
    claim?: boolean | AssuranceElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidenceLink"]>

  export type EvidenceLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evidenceId?: boolean
    claimId?: boolean
    createdAt?: boolean
    evidence?: boolean | AssuranceElementDefaultArgs<ExtArgs>
    claim?: boolean | AssuranceElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidenceLink"]>

  export type EvidenceLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    evidenceId?: boolean
    claimId?: boolean
    createdAt?: boolean
    evidence?: boolean | AssuranceElementDefaultArgs<ExtArgs>
    claim?: boolean | AssuranceElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evidenceLink"]>

  export type EvidenceLinkSelectScalar = {
    id?: boolean
    evidenceId?: boolean
    claimId?: boolean
    createdAt?: boolean
  }

  export type EvidenceLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "evidenceId" | "claimId" | "createdAt", ExtArgs["result"]["evidenceLink"]>
  export type EvidenceLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidence?: boolean | AssuranceElementDefaultArgs<ExtArgs>
    claim?: boolean | AssuranceElementDefaultArgs<ExtArgs>
  }
  export type EvidenceLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidence?: boolean | AssuranceElementDefaultArgs<ExtArgs>
    claim?: boolean | AssuranceElementDefaultArgs<ExtArgs>
  }
  export type EvidenceLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evidence?: boolean | AssuranceElementDefaultArgs<ExtArgs>
    claim?: boolean | AssuranceElementDefaultArgs<ExtArgs>
  }

  export type $EvidenceLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EvidenceLink"
    objects: {
      evidence: Prisma.$AssuranceElementPayload<ExtArgs>
      claim: Prisma.$AssuranceElementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      evidenceId: string
      claimId: string
      createdAt: Date
    }, ExtArgs["result"]["evidenceLink"]>
    composites: {}
  }

  type EvidenceLinkGetPayload<S extends boolean | null | undefined | EvidenceLinkDefaultArgs> = $Result.GetResult<Prisma.$EvidenceLinkPayload, S>

  type EvidenceLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvidenceLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvidenceLinkCountAggregateInputType | true
    }

  export interface EvidenceLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EvidenceLink'], meta: { name: 'EvidenceLink' } }
    /**
     * Find zero or one EvidenceLink that matches the filter.
     * @param {EvidenceLinkFindUniqueArgs} args - Arguments to find a EvidenceLink
     * @example
     * // Get one EvidenceLink
     * const evidenceLink = await prisma.evidenceLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvidenceLinkFindUniqueArgs>(args: SelectSubset<T, EvidenceLinkFindUniqueArgs<ExtArgs>>): Prisma__EvidenceLinkClient<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EvidenceLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvidenceLinkFindUniqueOrThrowArgs} args - Arguments to find a EvidenceLink
     * @example
     * // Get one EvidenceLink
     * const evidenceLink = await prisma.evidenceLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvidenceLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, EvidenceLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvidenceLinkClient<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvidenceLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceLinkFindFirstArgs} args - Arguments to find a EvidenceLink
     * @example
     * // Get one EvidenceLink
     * const evidenceLink = await prisma.evidenceLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvidenceLinkFindFirstArgs>(args?: SelectSubset<T, EvidenceLinkFindFirstArgs<ExtArgs>>): Prisma__EvidenceLinkClient<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EvidenceLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceLinkFindFirstOrThrowArgs} args - Arguments to find a EvidenceLink
     * @example
     * // Get one EvidenceLink
     * const evidenceLink = await prisma.evidenceLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvidenceLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, EvidenceLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvidenceLinkClient<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EvidenceLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EvidenceLinks
     * const evidenceLinks = await prisma.evidenceLink.findMany()
     *
     * // Get first 10 EvidenceLinks
     * const evidenceLinks = await prisma.evidenceLink.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const evidenceLinkWithIdOnly = await prisma.evidenceLink.findMany({ select: { id: true } })
     *
     */
    findMany<T extends EvidenceLinkFindManyArgs>(args?: SelectSubset<T, EvidenceLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EvidenceLink.
     * @param {EvidenceLinkCreateArgs} args - Arguments to create a EvidenceLink.
     * @example
     * // Create one EvidenceLink
     * const EvidenceLink = await prisma.evidenceLink.create({
     *   data: {
     *     // ... data to create a EvidenceLink
     *   }
     * })
     *
     */
    create<T extends EvidenceLinkCreateArgs>(args: SelectSubset<T, EvidenceLinkCreateArgs<ExtArgs>>): Prisma__EvidenceLinkClient<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EvidenceLinks.
     * @param {EvidenceLinkCreateManyArgs} args - Arguments to create many EvidenceLinks.
     * @example
     * // Create many EvidenceLinks
     * const evidenceLink = await prisma.evidenceLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends EvidenceLinkCreateManyArgs>(args?: SelectSubset<T, EvidenceLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EvidenceLinks and returns the data saved in the database.
     * @param {EvidenceLinkCreateManyAndReturnArgs} args - Arguments to create many EvidenceLinks.
     * @example
     * // Create many EvidenceLinks
     * const evidenceLink = await prisma.evidenceLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many EvidenceLinks and only return the `id`
     * const evidenceLinkWithIdOnly = await prisma.evidenceLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends EvidenceLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, EvidenceLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EvidenceLink.
     * @param {EvidenceLinkDeleteArgs} args - Arguments to delete one EvidenceLink.
     * @example
     * // Delete one EvidenceLink
     * const EvidenceLink = await prisma.evidenceLink.delete({
     *   where: {
     *     // ... filter to delete one EvidenceLink
     *   }
     * })
     *
     */
    delete<T extends EvidenceLinkDeleteArgs>(args: SelectSubset<T, EvidenceLinkDeleteArgs<ExtArgs>>): Prisma__EvidenceLinkClient<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EvidenceLink.
     * @param {EvidenceLinkUpdateArgs} args - Arguments to update one EvidenceLink.
     * @example
     * // Update one EvidenceLink
     * const evidenceLink = await prisma.evidenceLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends EvidenceLinkUpdateArgs>(args: SelectSubset<T, EvidenceLinkUpdateArgs<ExtArgs>>): Prisma__EvidenceLinkClient<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EvidenceLinks.
     * @param {EvidenceLinkDeleteManyArgs} args - Arguments to filter EvidenceLinks to delete.
     * @example
     * // Delete a few EvidenceLinks
     * const { count } = await prisma.evidenceLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends EvidenceLinkDeleteManyArgs>(args?: SelectSubset<T, EvidenceLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvidenceLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EvidenceLinks
     * const evidenceLink = await prisma.evidenceLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends EvidenceLinkUpdateManyArgs>(args: SelectSubset<T, EvidenceLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EvidenceLinks and returns the data updated in the database.
     * @param {EvidenceLinkUpdateManyAndReturnArgs} args - Arguments to update many EvidenceLinks.
     * @example
     * // Update many EvidenceLinks
     * const evidenceLink = await prisma.evidenceLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more EvidenceLinks and only return the `id`
     * const evidenceLinkWithIdOnly = await prisma.evidenceLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends EvidenceLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, EvidenceLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EvidenceLink.
     * @param {EvidenceLinkUpsertArgs} args - Arguments to update or create a EvidenceLink.
     * @example
     * // Update or create a EvidenceLink
     * const evidenceLink = await prisma.evidenceLink.upsert({
     *   create: {
     *     // ... data to create a EvidenceLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EvidenceLink we want to update
     *   }
     * })
     */
    upsert<T extends EvidenceLinkUpsertArgs>(args: SelectSubset<T, EvidenceLinkUpsertArgs<ExtArgs>>): Prisma__EvidenceLinkClient<$Result.GetResult<Prisma.$EvidenceLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EvidenceLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceLinkCountArgs} args - Arguments to filter EvidenceLinks to count.
     * @example
     * // Count the number of EvidenceLinks
     * const count = await prisma.evidenceLink.count({
     *   where: {
     *     // ... the filter for the EvidenceLinks we want to count
     *   }
     * })
    **/
    count<T extends EvidenceLinkCountArgs>(
      args?: Subset<T, EvidenceLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvidenceLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EvidenceLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvidenceLinkAggregateArgs>(args: Subset<T, EvidenceLinkAggregateArgs>): Prisma.PrismaPromise<GetEvidenceLinkAggregateType<T>>

    /**
     * Group by EvidenceLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvidenceLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends EvidenceLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvidenceLinkGroupByArgs['orderBy'] }
        : { orderBy?: EvidenceLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvidenceLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvidenceLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EvidenceLink model
   */
  readonly fields: EvidenceLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EvidenceLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvidenceLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evidence<T extends AssuranceElementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElementDefaultArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    claim<T extends AssuranceElementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceElementDefaultArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EvidenceLink model
   */
  interface EvidenceLinkFieldRefs {
    readonly id: FieldRef<"EvidenceLink", 'String'>
    readonly evidenceId: FieldRef<"EvidenceLink", 'String'>
    readonly claimId: FieldRef<"EvidenceLink", 'String'>
    readonly createdAt: FieldRef<"EvidenceLink", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * EvidenceLink findUnique
   */
  export type EvidenceLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceLink to fetch.
     */
    where: EvidenceLinkWhereUniqueInput
  }

  /**
   * EvidenceLink findUniqueOrThrow
   */
  export type EvidenceLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceLink to fetch.
     */
    where: EvidenceLinkWhereUniqueInput
  }

  /**
   * EvidenceLink findFirst
   */
  export type EvidenceLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceLink to fetch.
     */
    where?: EvidenceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EvidenceLinks to fetch.
     */
    orderBy?: EvidenceLinkOrderByWithRelationInput | EvidenceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EvidenceLinks.
     */
    cursor?: EvidenceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EvidenceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EvidenceLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EvidenceLinks.
     */
    distinct?: EvidenceLinkScalarFieldEnum | EvidenceLinkScalarFieldEnum[]
  }

  /**
   * EvidenceLink findFirstOrThrow
   */
  export type EvidenceLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceLink to fetch.
     */
    where?: EvidenceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EvidenceLinks to fetch.
     */
    orderBy?: EvidenceLinkOrderByWithRelationInput | EvidenceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for EvidenceLinks.
     */
    cursor?: EvidenceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EvidenceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EvidenceLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of EvidenceLinks.
     */
    distinct?: EvidenceLinkScalarFieldEnum | EvidenceLinkScalarFieldEnum[]
  }

  /**
   * EvidenceLink findMany
   */
  export type EvidenceLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    /**
     * Filter, which EvidenceLinks to fetch.
     */
    where?: EvidenceLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of EvidenceLinks to fetch.
     */
    orderBy?: EvidenceLinkOrderByWithRelationInput | EvidenceLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing EvidenceLinks.
     */
    cursor?: EvidenceLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` EvidenceLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` EvidenceLinks.
     */
    skip?: number
    distinct?: EvidenceLinkScalarFieldEnum | EvidenceLinkScalarFieldEnum[]
  }

  /**
   * EvidenceLink create
   */
  export type EvidenceLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a EvidenceLink.
     */
    data: XOR<EvidenceLinkCreateInput, EvidenceLinkUncheckedCreateInput>
  }

  /**
   * EvidenceLink createMany
   */
  export type EvidenceLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EvidenceLinks.
     */
    data: EvidenceLinkCreateManyInput | EvidenceLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EvidenceLink createManyAndReturn
   */
  export type EvidenceLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * The data used to create many EvidenceLinks.
     */
    data: EvidenceLinkCreateManyInput | EvidenceLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvidenceLink update
   */
  export type EvidenceLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a EvidenceLink.
     */
    data: XOR<EvidenceLinkUpdateInput, EvidenceLinkUncheckedUpdateInput>
    /**
     * Choose, which EvidenceLink to update.
     */
    where: EvidenceLinkWhereUniqueInput
  }

  /**
   * EvidenceLink updateMany
   */
  export type EvidenceLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EvidenceLinks.
     */
    data: XOR<EvidenceLinkUpdateManyMutationInput, EvidenceLinkUncheckedUpdateManyInput>
    /**
     * Filter which EvidenceLinks to update
     */
    where?: EvidenceLinkWhereInput
    /**
     * Limit how many EvidenceLinks to update.
     */
    limit?: number
  }

  /**
   * EvidenceLink updateManyAndReturn
   */
  export type EvidenceLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * The data used to update EvidenceLinks.
     */
    data: XOR<EvidenceLinkUpdateManyMutationInput, EvidenceLinkUncheckedUpdateManyInput>
    /**
     * Filter which EvidenceLinks to update
     */
    where?: EvidenceLinkWhereInput
    /**
     * Limit how many EvidenceLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EvidenceLink upsert
   */
  export type EvidenceLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the EvidenceLink to update in case it exists.
     */
    where: EvidenceLinkWhereUniqueInput
    /**
     * In case the EvidenceLink found by the `where` argument doesn't exist, create a new EvidenceLink with this data.
     */
    create: XOR<EvidenceLinkCreateInput, EvidenceLinkUncheckedCreateInput>
    /**
     * In case the EvidenceLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvidenceLinkUpdateInput, EvidenceLinkUncheckedUpdateInput>
  }

  /**
   * EvidenceLink delete
   */
  export type EvidenceLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
    /**
     * Filter which EvidenceLink to delete.
     */
    where: EvidenceLinkWhereUniqueInput
  }

  /**
   * EvidenceLink deleteMany
   */
  export type EvidenceLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EvidenceLinks to delete
     */
    where?: EvidenceLinkWhereInput
    /**
     * Limit how many EvidenceLinks to delete.
     */
    limit?: number
  }

  /**
   * EvidenceLink without action
   */
  export type EvidenceLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EvidenceLink
     */
    select?: EvidenceLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EvidenceLink
     */
    omit?: EvidenceLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvidenceLinkInclude<ExtArgs> | null
  }


  /**
   * Model ArgumentPattern
   */

  export type AggregateArgumentPattern = {
    _count: ArgumentPatternCountAggregateOutputType | null
    _min: ArgumentPatternMinAggregateOutputType | null
    _max: ArgumentPatternMaxAggregateOutputType | null
  }

  export type ArgumentPatternMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    version: string | null
    category: string | null
    published: boolean | null
    publishedAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArgumentPatternMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    version: string | null
    category: string | null
    published: boolean | null
    publishedAt: Date | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ArgumentPatternCountAggregateOutputType = {
    id: number
    name: number
    description: number
    version: number
    category: number
    tags: number
    published: number
    publishedAt: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ArgumentPatternMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    category?: true
    published?: true
    publishedAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArgumentPatternMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    category?: true
    published?: true
    publishedAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ArgumentPatternCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    version?: true
    category?: true
    tags?: true
    published?: true
    publishedAt?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ArgumentPatternAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArgumentPattern to aggregate.
     */
    where?: ArgumentPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArgumentPatterns to fetch.
     */
    orderBy?: ArgumentPatternOrderByWithRelationInput | ArgumentPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ArgumentPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArgumentPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArgumentPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ArgumentPatterns
    **/
    _count?: true | ArgumentPatternCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: ArgumentPatternMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: ArgumentPatternMaxAggregateInputType
  }

  export type GetArgumentPatternAggregateType<T extends ArgumentPatternAggregateArgs> = {
        [P in keyof T & keyof AggregateArgumentPattern]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArgumentPattern[P]>
      : GetScalarType<T[P], AggregateArgumentPattern[P]>
  }




  export type ArgumentPatternGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArgumentPatternWhereInput
    orderBy?: ArgumentPatternOrderByWithAggregationInput | ArgumentPatternOrderByWithAggregationInput[]
    by: ArgumentPatternScalarFieldEnum[] | ArgumentPatternScalarFieldEnum
    having?: ArgumentPatternScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArgumentPatternCountAggregateInputType | true
    _min?: ArgumentPatternMinAggregateInputType
    _max?: ArgumentPatternMaxAggregateInputType
  }

  export type ArgumentPatternGroupByOutputType = {
    id: string
    name: string
    description: string
    version: string
    category: string | null
    tags: string[]
    published: boolean
    publishedAt: Date | null
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: ArgumentPatternCountAggregateOutputType | null
    _min: ArgumentPatternMinAggregateOutputType | null
    _max: ArgumentPatternMaxAggregateOutputType | null
  }

  type GetArgumentPatternGroupByPayload<T extends ArgumentPatternGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArgumentPatternGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArgumentPatternGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArgumentPatternGroupByOutputType[P]>
            : GetScalarType<T[P], ArgumentPatternGroupByOutputType[P]>
        }
      >
    >


  export type ArgumentPatternSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    category?: boolean
    tags?: boolean
    published?: boolean
    publishedAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    elements?: boolean | ArgumentPattern$elementsArgs<ExtArgs>
    userPermissions?: boolean | ArgumentPattern$userPermissionsArgs<ExtArgs>
    teamPermissions?: boolean | ArgumentPattern$teamPermissionsArgs<ExtArgs>
    derivedCases?: boolean | ArgumentPattern$derivedCasesArgs<ExtArgs>
    _count?: boolean | ArgumentPatternCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["argumentPattern"]>

  export type ArgumentPatternSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    category?: boolean
    tags?: boolean
    published?: boolean
    publishedAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["argumentPattern"]>

  export type ArgumentPatternSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    category?: boolean
    tags?: boolean
    published?: boolean
    publishedAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["argumentPattern"]>

  export type ArgumentPatternSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    version?: boolean
    category?: boolean
    tags?: boolean
    published?: boolean
    publishedAt?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ArgumentPatternOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "version" | "category" | "tags" | "published" | "publishedAt" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["argumentPattern"]>
  export type ArgumentPatternInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elements?: boolean | ArgumentPattern$elementsArgs<ExtArgs>
    userPermissions?: boolean | ArgumentPattern$userPermissionsArgs<ExtArgs>
    teamPermissions?: boolean | ArgumentPattern$teamPermissionsArgs<ExtArgs>
    derivedCases?: boolean | ArgumentPattern$derivedCasesArgs<ExtArgs>
    _count?: boolean | ArgumentPatternCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ArgumentPatternIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ArgumentPatternIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ArgumentPatternPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArgumentPattern"
    objects: {
      elements: Prisma.$PatternElementPayload<ExtArgs>[]
      userPermissions: Prisma.$PatternPermissionPayload<ExtArgs>[]
      teamPermissions: Prisma.$PatternTeamPermissionPayload<ExtArgs>[]
      derivedCases: Prisma.$AssuranceCasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string
      version: string
      category: string | null
      tags: string[]
      published: boolean
      publishedAt: Date | null
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["argumentPattern"]>
    composites: {}
  }

  type ArgumentPatternGetPayload<S extends boolean | null | undefined | ArgumentPatternDefaultArgs> = $Result.GetResult<Prisma.$ArgumentPatternPayload, S>

  type ArgumentPatternCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArgumentPatternFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArgumentPatternCountAggregateInputType | true
    }

  export interface ArgumentPatternDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArgumentPattern'], meta: { name: 'ArgumentPattern' } }
    /**
     * Find zero or one ArgumentPattern that matches the filter.
     * @param {ArgumentPatternFindUniqueArgs} args - Arguments to find a ArgumentPattern
     * @example
     * // Get one ArgumentPattern
     * const argumentPattern = await prisma.argumentPattern.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArgumentPatternFindUniqueArgs>(args: SelectSubset<T, ArgumentPatternFindUniqueArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArgumentPattern that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArgumentPatternFindUniqueOrThrowArgs} args - Arguments to find a ArgumentPattern
     * @example
     * // Get one ArgumentPattern
     * const argumentPattern = await prisma.argumentPattern.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArgumentPatternFindUniqueOrThrowArgs>(args: SelectSubset<T, ArgumentPatternFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArgumentPattern that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArgumentPatternFindFirstArgs} args - Arguments to find a ArgumentPattern
     * @example
     * // Get one ArgumentPattern
     * const argumentPattern = await prisma.argumentPattern.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArgumentPatternFindFirstArgs>(args?: SelectSubset<T, ArgumentPatternFindFirstArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArgumentPattern that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArgumentPatternFindFirstOrThrowArgs} args - Arguments to find a ArgumentPattern
     * @example
     * // Get one ArgumentPattern
     * const argumentPattern = await prisma.argumentPattern.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArgumentPatternFindFirstOrThrowArgs>(args?: SelectSubset<T, ArgumentPatternFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArgumentPatterns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArgumentPatternFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArgumentPatterns
     * const argumentPatterns = await prisma.argumentPattern.findMany()
     *
     * // Get first 10 ArgumentPatterns
     * const argumentPatterns = await prisma.argumentPattern.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const argumentPatternWithIdOnly = await prisma.argumentPattern.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ArgumentPatternFindManyArgs>(args?: SelectSubset<T, ArgumentPatternFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArgumentPattern.
     * @param {ArgumentPatternCreateArgs} args - Arguments to create a ArgumentPattern.
     * @example
     * // Create one ArgumentPattern
     * const ArgumentPattern = await prisma.argumentPattern.create({
     *   data: {
     *     // ... data to create a ArgumentPattern
     *   }
     * })
     *
     */
    create<T extends ArgumentPatternCreateArgs>(args: SelectSubset<T, ArgumentPatternCreateArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArgumentPatterns.
     * @param {ArgumentPatternCreateManyArgs} args - Arguments to create many ArgumentPatterns.
     * @example
     * // Create many ArgumentPatterns
     * const argumentPattern = await prisma.argumentPattern.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ArgumentPatternCreateManyArgs>(args?: SelectSubset<T, ArgumentPatternCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArgumentPatterns and returns the data saved in the database.
     * @param {ArgumentPatternCreateManyAndReturnArgs} args - Arguments to create many ArgumentPatterns.
     * @example
     * // Create many ArgumentPatterns
     * const argumentPattern = await prisma.argumentPattern.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ArgumentPatterns and only return the `id`
     * const argumentPatternWithIdOnly = await prisma.argumentPattern.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ArgumentPatternCreateManyAndReturnArgs>(args?: SelectSubset<T, ArgumentPatternCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArgumentPattern.
     * @param {ArgumentPatternDeleteArgs} args - Arguments to delete one ArgumentPattern.
     * @example
     * // Delete one ArgumentPattern
     * const ArgumentPattern = await prisma.argumentPattern.delete({
     *   where: {
     *     // ... filter to delete one ArgumentPattern
     *   }
     * })
     *
     */
    delete<T extends ArgumentPatternDeleteArgs>(args: SelectSubset<T, ArgumentPatternDeleteArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArgumentPattern.
     * @param {ArgumentPatternUpdateArgs} args - Arguments to update one ArgumentPattern.
     * @example
     * // Update one ArgumentPattern
     * const argumentPattern = await prisma.argumentPattern.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ArgumentPatternUpdateArgs>(args: SelectSubset<T, ArgumentPatternUpdateArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArgumentPatterns.
     * @param {ArgumentPatternDeleteManyArgs} args - Arguments to filter ArgumentPatterns to delete.
     * @example
     * // Delete a few ArgumentPatterns
     * const { count } = await prisma.argumentPattern.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ArgumentPatternDeleteManyArgs>(args?: SelectSubset<T, ArgumentPatternDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArgumentPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArgumentPatternUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArgumentPatterns
     * const argumentPattern = await prisma.argumentPattern.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ArgumentPatternUpdateManyArgs>(args: SelectSubset<T, ArgumentPatternUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArgumentPatterns and returns the data updated in the database.
     * @param {ArgumentPatternUpdateManyAndReturnArgs} args - Arguments to update many ArgumentPatterns.
     * @example
     * // Update many ArgumentPatterns
     * const argumentPattern = await prisma.argumentPattern.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ArgumentPatterns and only return the `id`
     * const argumentPatternWithIdOnly = await prisma.argumentPattern.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ArgumentPatternUpdateManyAndReturnArgs>(args: SelectSubset<T, ArgumentPatternUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArgumentPattern.
     * @param {ArgumentPatternUpsertArgs} args - Arguments to update or create a ArgumentPattern.
     * @example
     * // Update or create a ArgumentPattern
     * const argumentPattern = await prisma.argumentPattern.upsert({
     *   create: {
     *     // ... data to create a ArgumentPattern
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArgumentPattern we want to update
     *   }
     * })
     */
    upsert<T extends ArgumentPatternUpsertArgs>(args: SelectSubset<T, ArgumentPatternUpsertArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArgumentPatterns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArgumentPatternCountArgs} args - Arguments to filter ArgumentPatterns to count.
     * @example
     * // Count the number of ArgumentPatterns
     * const count = await prisma.argumentPattern.count({
     *   where: {
     *     // ... the filter for the ArgumentPatterns we want to count
     *   }
     * })
    **/
    count<T extends ArgumentPatternCountArgs>(
      args?: Subset<T, ArgumentPatternCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArgumentPatternCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArgumentPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArgumentPatternAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArgumentPatternAggregateArgs>(args: Subset<T, ArgumentPatternAggregateArgs>): Prisma.PrismaPromise<GetArgumentPatternAggregateType<T>>

    /**
     * Group by ArgumentPattern.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArgumentPatternGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends ArgumentPatternGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArgumentPatternGroupByArgs['orderBy'] }
        : { orderBy?: ArgumentPatternGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArgumentPatternGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArgumentPatternGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArgumentPattern model
   */
  readonly fields: ArgumentPatternFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArgumentPattern.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArgumentPatternClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    elements<T extends ArgumentPattern$elementsArgs<ExtArgs> = {}>(args?: Subset<T, ArgumentPattern$elementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPermissions<T extends ArgumentPattern$userPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, ArgumentPattern$userPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teamPermissions<T extends ArgumentPattern$teamPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, ArgumentPattern$teamPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    derivedCases<T extends ArgumentPattern$derivedCasesArgs<ExtArgs> = {}>(args?: Subset<T, ArgumentPattern$derivedCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArgumentPattern model
   */
  interface ArgumentPatternFieldRefs {
    readonly id: FieldRef<"ArgumentPattern", 'String'>
    readonly name: FieldRef<"ArgumentPattern", 'String'>
    readonly description: FieldRef<"ArgumentPattern", 'String'>
    readonly version: FieldRef<"ArgumentPattern", 'String'>
    readonly category: FieldRef<"ArgumentPattern", 'String'>
    readonly tags: FieldRef<"ArgumentPattern", 'String[]'>
    readonly published: FieldRef<"ArgumentPattern", 'Boolean'>
    readonly publishedAt: FieldRef<"ArgumentPattern", 'DateTime'>
    readonly createdById: FieldRef<"ArgumentPattern", 'String'>
    readonly createdAt: FieldRef<"ArgumentPattern", 'DateTime'>
    readonly updatedAt: FieldRef<"ArgumentPattern", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * ArgumentPattern findUnique
   */
  export type ArgumentPatternFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    /**
     * Filter, which ArgumentPattern to fetch.
     */
    where: ArgumentPatternWhereUniqueInput
  }

  /**
   * ArgumentPattern findUniqueOrThrow
   */
  export type ArgumentPatternFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    /**
     * Filter, which ArgumentPattern to fetch.
     */
    where: ArgumentPatternWhereUniqueInput
  }

  /**
   * ArgumentPattern findFirst
   */
  export type ArgumentPatternFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    /**
     * Filter, which ArgumentPattern to fetch.
     */
    where?: ArgumentPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArgumentPatterns to fetch.
     */
    orderBy?: ArgumentPatternOrderByWithRelationInput | ArgumentPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ArgumentPatterns.
     */
    cursor?: ArgumentPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArgumentPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArgumentPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ArgumentPatterns.
     */
    distinct?: ArgumentPatternScalarFieldEnum | ArgumentPatternScalarFieldEnum[]
  }

  /**
   * ArgumentPattern findFirstOrThrow
   */
  export type ArgumentPatternFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    /**
     * Filter, which ArgumentPattern to fetch.
     */
    where?: ArgumentPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArgumentPatterns to fetch.
     */
    orderBy?: ArgumentPatternOrderByWithRelationInput | ArgumentPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ArgumentPatterns.
     */
    cursor?: ArgumentPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArgumentPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArgumentPatterns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ArgumentPatterns.
     */
    distinct?: ArgumentPatternScalarFieldEnum | ArgumentPatternScalarFieldEnum[]
  }

  /**
   * ArgumentPattern findMany
   */
  export type ArgumentPatternFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    /**
     * Filter, which ArgumentPatterns to fetch.
     */
    where?: ArgumentPatternWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ArgumentPatterns to fetch.
     */
    orderBy?: ArgumentPatternOrderByWithRelationInput | ArgumentPatternOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ArgumentPatterns.
     */
    cursor?: ArgumentPatternWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ArgumentPatterns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ArgumentPatterns.
     */
    skip?: number
    distinct?: ArgumentPatternScalarFieldEnum | ArgumentPatternScalarFieldEnum[]
  }

  /**
   * ArgumentPattern create
   */
  export type ArgumentPatternCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    /**
     * The data needed to create a ArgumentPattern.
     */
    data: XOR<ArgumentPatternCreateInput, ArgumentPatternUncheckedCreateInput>
  }

  /**
   * ArgumentPattern createMany
   */
  export type ArgumentPatternCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArgumentPatterns.
     */
    data: ArgumentPatternCreateManyInput | ArgumentPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArgumentPattern createManyAndReturn
   */
  export type ArgumentPatternCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * The data used to create many ArgumentPatterns.
     */
    data: ArgumentPatternCreateManyInput | ArgumentPatternCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArgumentPattern update
   */
  export type ArgumentPatternUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    /**
     * The data needed to update a ArgumentPattern.
     */
    data: XOR<ArgumentPatternUpdateInput, ArgumentPatternUncheckedUpdateInput>
    /**
     * Choose, which ArgumentPattern to update.
     */
    where: ArgumentPatternWhereUniqueInput
  }

  /**
   * ArgumentPattern updateMany
   */
  export type ArgumentPatternUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArgumentPatterns.
     */
    data: XOR<ArgumentPatternUpdateManyMutationInput, ArgumentPatternUncheckedUpdateManyInput>
    /**
     * Filter which ArgumentPatterns to update
     */
    where?: ArgumentPatternWhereInput
    /**
     * Limit how many ArgumentPatterns to update.
     */
    limit?: number
  }

  /**
   * ArgumentPattern updateManyAndReturn
   */
  export type ArgumentPatternUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * The data used to update ArgumentPatterns.
     */
    data: XOR<ArgumentPatternUpdateManyMutationInput, ArgumentPatternUncheckedUpdateManyInput>
    /**
     * Filter which ArgumentPatterns to update
     */
    where?: ArgumentPatternWhereInput
    /**
     * Limit how many ArgumentPatterns to update.
     */
    limit?: number
  }

  /**
   * ArgumentPattern upsert
   */
  export type ArgumentPatternUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    /**
     * The filter to search for the ArgumentPattern to update in case it exists.
     */
    where: ArgumentPatternWhereUniqueInput
    /**
     * In case the ArgumentPattern found by the `where` argument doesn't exist, create a new ArgumentPattern with this data.
     */
    create: XOR<ArgumentPatternCreateInput, ArgumentPatternUncheckedCreateInput>
    /**
     * In case the ArgumentPattern was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArgumentPatternUpdateInput, ArgumentPatternUncheckedUpdateInput>
  }

  /**
   * ArgumentPattern delete
   */
  export type ArgumentPatternDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
    /**
     * Filter which ArgumentPattern to delete.
     */
    where: ArgumentPatternWhereUniqueInput
  }

  /**
   * ArgumentPattern deleteMany
   */
  export type ArgumentPatternDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArgumentPatterns to delete
     */
    where?: ArgumentPatternWhereInput
    /**
     * Limit how many ArgumentPatterns to delete.
     */
    limit?: number
  }

  /**
   * ArgumentPattern.elements
   */
  export type ArgumentPattern$elementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    where?: PatternElementWhereInput
    orderBy?: PatternElementOrderByWithRelationInput | PatternElementOrderByWithRelationInput[]
    cursor?: PatternElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternElementScalarFieldEnum | PatternElementScalarFieldEnum[]
  }

  /**
   * ArgumentPattern.userPermissions
   */
  export type ArgumentPattern$userPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    where?: PatternPermissionWhereInput
    orderBy?: PatternPermissionOrderByWithRelationInput | PatternPermissionOrderByWithRelationInput[]
    cursor?: PatternPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternPermissionScalarFieldEnum | PatternPermissionScalarFieldEnum[]
  }

  /**
   * ArgumentPattern.teamPermissions
   */
  export type ArgumentPattern$teamPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    where?: PatternTeamPermissionWhereInput
    orderBy?: PatternTeamPermissionOrderByWithRelationInput | PatternTeamPermissionOrderByWithRelationInput[]
    cursor?: PatternTeamPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternTeamPermissionScalarFieldEnum | PatternTeamPermissionScalarFieldEnum[]
  }

  /**
   * ArgumentPattern.derivedCases
   */
  export type ArgumentPattern$derivedCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    where?: AssuranceCaseWhereInput
    orderBy?: AssuranceCaseOrderByWithRelationInput | AssuranceCaseOrderByWithRelationInput[]
    cursor?: AssuranceCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssuranceCaseScalarFieldEnum | AssuranceCaseScalarFieldEnum[]
  }

  /**
   * ArgumentPattern without action
   */
  export type ArgumentPatternDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArgumentPattern
     */
    select?: ArgumentPatternSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArgumentPattern
     */
    omit?: ArgumentPatternOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArgumentPatternInclude<ExtArgs> | null
  }


  /**
   * Model PatternElement
   */

  export type AggregatePatternElement = {
    _count: PatternElementCountAggregateOutputType | null
    _avg: PatternElementAvgAggregateOutputType | null
    _sum: PatternElementSumAggregateOutputType | null
    _min: PatternElementMinAggregateOutputType | null
    _max: PatternElementMaxAggregateOutputType | null
  }

  export type PatternElementAvgAggregateOutputType = {
    displayOrder: number | null
  }

  export type PatternElementSumAggregateOutputType = {
    displayOrder: number | null
  }

  export type PatternElementMinAggregateOutputType = {
    id: string | null
    patternId: string | null
    elementType: $Enums.ElementType | null
    role: $Enums.ElementRole | null
    parentId: string | null
    name: string | null
    description: string | null
    assumption: string | null
    justification: string | null
    url: string | null
    isPlaceholder: boolean | null
    placeholderHint: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatternElementMaxAggregateOutputType = {
    id: string | null
    patternId: string | null
    elementType: $Enums.ElementType | null
    role: $Enums.ElementRole | null
    parentId: string | null
    name: string | null
    description: string | null
    assumption: string | null
    justification: string | null
    url: string | null
    isPlaceholder: boolean | null
    placeholderHint: string | null
    displayOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatternElementCountAggregateOutputType = {
    id: number
    patternId: number
    elementType: number
    role: number
    parentId: number
    name: number
    description: number
    assumption: number
    justification: number
    url: number
    isPlaceholder: number
    placeholderHint: number
    displayOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatternElementAvgAggregateInputType = {
    displayOrder?: true
  }

  export type PatternElementSumAggregateInputType = {
    displayOrder?: true
  }

  export type PatternElementMinAggregateInputType = {
    id?: true
    patternId?: true
    elementType?: true
    role?: true
    parentId?: true
    name?: true
    description?: true
    assumption?: true
    justification?: true
    url?: true
    isPlaceholder?: true
    placeholderHint?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatternElementMaxAggregateInputType = {
    id?: true
    patternId?: true
    elementType?: true
    role?: true
    parentId?: true
    name?: true
    description?: true
    assumption?: true
    justification?: true
    url?: true
    isPlaceholder?: true
    placeholderHint?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatternElementCountAggregateInputType = {
    id?: true
    patternId?: true
    elementType?: true
    role?: true
    parentId?: true
    name?: true
    description?: true
    assumption?: true
    justification?: true
    url?: true
    isPlaceholder?: true
    placeholderHint?: true
    displayOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatternElementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternElement to aggregate.
     */
    where?: PatternElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternElements to fetch.
     */
    orderBy?: PatternElementOrderByWithRelationInput | PatternElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PatternElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PatternElements
    **/
    _count?: true | PatternElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: PatternElementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: PatternElementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: PatternElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: PatternElementMaxAggregateInputType
  }

  export type GetPatternElementAggregateType<T extends PatternElementAggregateArgs> = {
        [P in keyof T & keyof AggregatePatternElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatternElement[P]>
      : GetScalarType<T[P], AggregatePatternElement[P]>
  }




  export type PatternElementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternElementWhereInput
    orderBy?: PatternElementOrderByWithAggregationInput | PatternElementOrderByWithAggregationInput[]
    by: PatternElementScalarFieldEnum[] | PatternElementScalarFieldEnum
    having?: PatternElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatternElementCountAggregateInputType | true
    _avg?: PatternElementAvgAggregateInputType
    _sum?: PatternElementSumAggregateInputType
    _min?: PatternElementMinAggregateInputType
    _max?: PatternElementMaxAggregateInputType
  }

  export type PatternElementGroupByOutputType = {
    id: string
    patternId: string
    elementType: $Enums.ElementType
    role: $Enums.ElementRole | null
    parentId: string | null
    name: string | null
    description: string
    assumption: string | null
    justification: string | null
    url: string | null
    isPlaceholder: boolean
    placeholderHint: string | null
    displayOrder: number
    createdAt: Date
    updatedAt: Date
    _count: PatternElementCountAggregateOutputType | null
    _avg: PatternElementAvgAggregateOutputType | null
    _sum: PatternElementSumAggregateOutputType | null
    _min: PatternElementMinAggregateOutputType | null
    _max: PatternElementMaxAggregateOutputType | null
  }

  type GetPatternElementGroupByPayload<T extends PatternElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatternElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatternElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatternElementGroupByOutputType[P]>
            : GetScalarType<T[P], PatternElementGroupByOutputType[P]>
        }
      >
    >


  export type PatternElementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    elementType?: boolean
    role?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    assumption?: boolean
    justification?: boolean
    url?: boolean
    isPlaceholder?: boolean
    placeholderHint?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    parent?: boolean | PatternElement$parentArgs<ExtArgs>
    children?: boolean | PatternElement$childrenArgs<ExtArgs>
    _count?: boolean | PatternElementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternElement"]>

  export type PatternElementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    elementType?: boolean
    role?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    assumption?: boolean
    justification?: boolean
    url?: boolean
    isPlaceholder?: boolean
    placeholderHint?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    parent?: boolean | PatternElement$parentArgs<ExtArgs>
  }, ExtArgs["result"]["patternElement"]>

  export type PatternElementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    elementType?: boolean
    role?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    assumption?: boolean
    justification?: boolean
    url?: boolean
    isPlaceholder?: boolean
    placeholderHint?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    parent?: boolean | PatternElement$parentArgs<ExtArgs>
  }, ExtArgs["result"]["patternElement"]>

  export type PatternElementSelectScalar = {
    id?: boolean
    patternId?: boolean
    elementType?: boolean
    role?: boolean
    parentId?: boolean
    name?: boolean
    description?: boolean
    assumption?: boolean
    justification?: boolean
    url?: boolean
    isPlaceholder?: boolean
    placeholderHint?: boolean
    displayOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatternElementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patternId" | "elementType" | "role" | "parentId" | "name" | "description" | "assumption" | "justification" | "url" | "isPlaceholder" | "placeholderHint" | "displayOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["patternElement"]>
  export type PatternElementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    parent?: boolean | PatternElement$parentArgs<ExtArgs>
    children?: boolean | PatternElement$childrenArgs<ExtArgs>
    _count?: boolean | PatternElementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatternElementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    parent?: boolean | PatternElement$parentArgs<ExtArgs>
  }
  export type PatternElementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    parent?: boolean | PatternElement$parentArgs<ExtArgs>
  }

  export type $PatternElementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatternElement"
    objects: {
      pattern: Prisma.$ArgumentPatternPayload<ExtArgs>
      parent: Prisma.$PatternElementPayload<ExtArgs> | null
      children: Prisma.$PatternElementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patternId: string
      elementType: $Enums.ElementType
      role: $Enums.ElementRole | null
      parentId: string | null
      name: string | null
      description: string
      assumption: string | null
      justification: string | null
      url: string | null
      isPlaceholder: boolean
      placeholderHint: string | null
      displayOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patternElement"]>
    composites: {}
  }

  type PatternElementGetPayload<S extends boolean | null | undefined | PatternElementDefaultArgs> = $Result.GetResult<Prisma.$PatternElementPayload, S>

  type PatternElementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatternElementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatternElementCountAggregateInputType | true
    }

  export interface PatternElementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatternElement'], meta: { name: 'PatternElement' } }
    /**
     * Find zero or one PatternElement that matches the filter.
     * @param {PatternElementFindUniqueArgs} args - Arguments to find a PatternElement
     * @example
     * // Get one PatternElement
     * const patternElement = await prisma.patternElement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatternElementFindUniqueArgs>(args: SelectSubset<T, PatternElementFindUniqueArgs<ExtArgs>>): Prisma__PatternElementClient<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatternElement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatternElementFindUniqueOrThrowArgs} args - Arguments to find a PatternElement
     * @example
     * // Get one PatternElement
     * const patternElement = await prisma.patternElement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatternElementFindUniqueOrThrowArgs>(args: SelectSubset<T, PatternElementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatternElementClient<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatternElement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternElementFindFirstArgs} args - Arguments to find a PatternElement
     * @example
     * // Get one PatternElement
     * const patternElement = await prisma.patternElement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatternElementFindFirstArgs>(args?: SelectSubset<T, PatternElementFindFirstArgs<ExtArgs>>): Prisma__PatternElementClient<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatternElement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternElementFindFirstOrThrowArgs} args - Arguments to find a PatternElement
     * @example
     * // Get one PatternElement
     * const patternElement = await prisma.patternElement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatternElementFindFirstOrThrowArgs>(args?: SelectSubset<T, PatternElementFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatternElementClient<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatternElements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternElementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatternElements
     * const patternElements = await prisma.patternElement.findMany()
     *
     * // Get first 10 PatternElements
     * const patternElements = await prisma.patternElement.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const patternElementWithIdOnly = await prisma.patternElement.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PatternElementFindManyArgs>(args?: SelectSubset<T, PatternElementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatternElement.
     * @param {PatternElementCreateArgs} args - Arguments to create a PatternElement.
     * @example
     * // Create one PatternElement
     * const PatternElement = await prisma.patternElement.create({
     *   data: {
     *     // ... data to create a PatternElement
     *   }
     * })
     *
     */
    create<T extends PatternElementCreateArgs>(args: SelectSubset<T, PatternElementCreateArgs<ExtArgs>>): Prisma__PatternElementClient<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatternElements.
     * @param {PatternElementCreateManyArgs} args - Arguments to create many PatternElements.
     * @example
     * // Create many PatternElements
     * const patternElement = await prisma.patternElement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PatternElementCreateManyArgs>(args?: SelectSubset<T, PatternElementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatternElements and returns the data saved in the database.
     * @param {PatternElementCreateManyAndReturnArgs} args - Arguments to create many PatternElements.
     * @example
     * // Create many PatternElements
     * const patternElement = await prisma.patternElement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PatternElements and only return the `id`
     * const patternElementWithIdOnly = await prisma.patternElement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PatternElementCreateManyAndReturnArgs>(args?: SelectSubset<T, PatternElementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatternElement.
     * @param {PatternElementDeleteArgs} args - Arguments to delete one PatternElement.
     * @example
     * // Delete one PatternElement
     * const PatternElement = await prisma.patternElement.delete({
     *   where: {
     *     // ... filter to delete one PatternElement
     *   }
     * })
     *
     */
    delete<T extends PatternElementDeleteArgs>(args: SelectSubset<T, PatternElementDeleteArgs<ExtArgs>>): Prisma__PatternElementClient<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatternElement.
     * @param {PatternElementUpdateArgs} args - Arguments to update one PatternElement.
     * @example
     * // Update one PatternElement
     * const patternElement = await prisma.patternElement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PatternElementUpdateArgs>(args: SelectSubset<T, PatternElementUpdateArgs<ExtArgs>>): Prisma__PatternElementClient<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatternElements.
     * @param {PatternElementDeleteManyArgs} args - Arguments to filter PatternElements to delete.
     * @example
     * // Delete a few PatternElements
     * const { count } = await prisma.patternElement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PatternElementDeleteManyArgs>(args?: SelectSubset<T, PatternElementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatternElements
     * const patternElement = await prisma.patternElement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PatternElementUpdateManyArgs>(args: SelectSubset<T, PatternElementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternElements and returns the data updated in the database.
     * @param {PatternElementUpdateManyAndReturnArgs} args - Arguments to update many PatternElements.
     * @example
     * // Update many PatternElements
     * const patternElement = await prisma.patternElement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PatternElements and only return the `id`
     * const patternElementWithIdOnly = await prisma.patternElement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PatternElementUpdateManyAndReturnArgs>(args: SelectSubset<T, PatternElementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatternElement.
     * @param {PatternElementUpsertArgs} args - Arguments to update or create a PatternElement.
     * @example
     * // Update or create a PatternElement
     * const patternElement = await prisma.patternElement.upsert({
     *   create: {
     *     // ... data to create a PatternElement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatternElement we want to update
     *   }
     * })
     */
    upsert<T extends PatternElementUpsertArgs>(args: SelectSubset<T, PatternElementUpsertArgs<ExtArgs>>): Prisma__PatternElementClient<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatternElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternElementCountArgs} args - Arguments to filter PatternElements to count.
     * @example
     * // Count the number of PatternElements
     * const count = await prisma.patternElement.count({
     *   where: {
     *     // ... the filter for the PatternElements we want to count
     *   }
     * })
    **/
    count<T extends PatternElementCountArgs>(
      args?: Subset<T, PatternElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatternElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatternElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatternElementAggregateArgs>(args: Subset<T, PatternElementAggregateArgs>): Prisma.PrismaPromise<GetPatternElementAggregateType<T>>

    /**
     * Group by PatternElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends PatternElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatternElementGroupByArgs['orderBy'] }
        : { orderBy?: PatternElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatternElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatternElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatternElement model
   */
  readonly fields: PatternElementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatternElement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatternElementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pattern<T extends ArgumentPatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArgumentPatternDefaultArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends PatternElement$parentArgs<ExtArgs> = {}>(args?: Subset<T, PatternElement$parentArgs<ExtArgs>>): Prisma__PatternElementClient<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends PatternElement$childrenArgs<ExtArgs> = {}>(args?: Subset<T, PatternElement$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatternElement model
   */
  interface PatternElementFieldRefs {
    readonly id: FieldRef<"PatternElement", 'String'>
    readonly patternId: FieldRef<"PatternElement", 'String'>
    readonly elementType: FieldRef<"PatternElement", 'ElementType'>
    readonly role: FieldRef<"PatternElement", 'ElementRole'>
    readonly parentId: FieldRef<"PatternElement", 'String'>
    readonly name: FieldRef<"PatternElement", 'String'>
    readonly description: FieldRef<"PatternElement", 'String'>
    readonly assumption: FieldRef<"PatternElement", 'String'>
    readonly justification: FieldRef<"PatternElement", 'String'>
    readonly url: FieldRef<"PatternElement", 'String'>
    readonly isPlaceholder: FieldRef<"PatternElement", 'Boolean'>
    readonly placeholderHint: FieldRef<"PatternElement", 'String'>
    readonly displayOrder: FieldRef<"PatternElement", 'Int'>
    readonly createdAt: FieldRef<"PatternElement", 'DateTime'>
    readonly updatedAt: FieldRef<"PatternElement", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * PatternElement findUnique
   */
  export type PatternElementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    /**
     * Filter, which PatternElement to fetch.
     */
    where: PatternElementWhereUniqueInput
  }

  /**
   * PatternElement findUniqueOrThrow
   */
  export type PatternElementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    /**
     * Filter, which PatternElement to fetch.
     */
    where: PatternElementWhereUniqueInput
  }

  /**
   * PatternElement findFirst
   */
  export type PatternElementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    /**
     * Filter, which PatternElement to fetch.
     */
    where?: PatternElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternElements to fetch.
     */
    orderBy?: PatternElementOrderByWithRelationInput | PatternElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PatternElements.
     */
    cursor?: PatternElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PatternElements.
     */
    distinct?: PatternElementScalarFieldEnum | PatternElementScalarFieldEnum[]
  }

  /**
   * PatternElement findFirstOrThrow
   */
  export type PatternElementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    /**
     * Filter, which PatternElement to fetch.
     */
    where?: PatternElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternElements to fetch.
     */
    orderBy?: PatternElementOrderByWithRelationInput | PatternElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PatternElements.
     */
    cursor?: PatternElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PatternElements.
     */
    distinct?: PatternElementScalarFieldEnum | PatternElementScalarFieldEnum[]
  }

  /**
   * PatternElement findMany
   */
  export type PatternElementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    /**
     * Filter, which PatternElements to fetch.
     */
    where?: PatternElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternElements to fetch.
     */
    orderBy?: PatternElementOrderByWithRelationInput | PatternElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PatternElements.
     */
    cursor?: PatternElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternElements.
     */
    skip?: number
    distinct?: PatternElementScalarFieldEnum | PatternElementScalarFieldEnum[]
  }

  /**
   * PatternElement create
   */
  export type PatternElementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    /**
     * The data needed to create a PatternElement.
     */
    data: XOR<PatternElementCreateInput, PatternElementUncheckedCreateInput>
  }

  /**
   * PatternElement createMany
   */
  export type PatternElementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatternElements.
     */
    data: PatternElementCreateManyInput | PatternElementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatternElement createManyAndReturn
   */
  export type PatternElementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * The data used to create many PatternElements.
     */
    data: PatternElementCreateManyInput | PatternElementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternElement update
   */
  export type PatternElementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    /**
     * The data needed to update a PatternElement.
     */
    data: XOR<PatternElementUpdateInput, PatternElementUncheckedUpdateInput>
    /**
     * Choose, which PatternElement to update.
     */
    where: PatternElementWhereUniqueInput
  }

  /**
   * PatternElement updateMany
   */
  export type PatternElementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatternElements.
     */
    data: XOR<PatternElementUpdateManyMutationInput, PatternElementUncheckedUpdateManyInput>
    /**
     * Filter which PatternElements to update
     */
    where?: PatternElementWhereInput
    /**
     * Limit how many PatternElements to update.
     */
    limit?: number
  }

  /**
   * PatternElement updateManyAndReturn
   */
  export type PatternElementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * The data used to update PatternElements.
     */
    data: XOR<PatternElementUpdateManyMutationInput, PatternElementUncheckedUpdateManyInput>
    /**
     * Filter which PatternElements to update
     */
    where?: PatternElementWhereInput
    /**
     * Limit how many PatternElements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternElement upsert
   */
  export type PatternElementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    /**
     * The filter to search for the PatternElement to update in case it exists.
     */
    where: PatternElementWhereUniqueInput
    /**
     * In case the PatternElement found by the `where` argument doesn't exist, create a new PatternElement with this data.
     */
    create: XOR<PatternElementCreateInput, PatternElementUncheckedCreateInput>
    /**
     * In case the PatternElement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatternElementUpdateInput, PatternElementUncheckedUpdateInput>
  }

  /**
   * PatternElement delete
   */
  export type PatternElementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    /**
     * Filter which PatternElement to delete.
     */
    where: PatternElementWhereUniqueInput
  }

  /**
   * PatternElement deleteMany
   */
  export type PatternElementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternElements to delete
     */
    where?: PatternElementWhereInput
    /**
     * Limit how many PatternElements to delete.
     */
    limit?: number
  }

  /**
   * PatternElement.parent
   */
  export type PatternElement$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    where?: PatternElementWhereInput
  }

  /**
   * PatternElement.children
   */
  export type PatternElement$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
    where?: PatternElementWhereInput
    orderBy?: PatternElementOrderByWithRelationInput | PatternElementOrderByWithRelationInput[]
    cursor?: PatternElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatternElementScalarFieldEnum | PatternElementScalarFieldEnum[]
  }

  /**
   * PatternElement without action
   */
  export type PatternElementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternElement
     */
    select?: PatternElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternElement
     */
    omit?: PatternElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternElementInclude<ExtArgs> | null
  }


  /**
   * Model PatternPermission
   */

  export type AggregatePatternPermission = {
    _count: PatternPermissionCountAggregateOutputType | null
    _min: PatternPermissionMinAggregateOutputType | null
    _max: PatternPermissionMaxAggregateOutputType | null
  }

  export type PatternPermissionMinAggregateOutputType = {
    id: string | null
    patternId: string | null
    userId: string | null
    permission: $Enums.PermissionLevel | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type PatternPermissionMaxAggregateOutputType = {
    id: string | null
    patternId: string | null
    userId: string | null
    permission: $Enums.PermissionLevel | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type PatternPermissionCountAggregateOutputType = {
    id: number
    patternId: number
    userId: number
    permission: number
    grantedById: number
    grantedAt: number
    _all: number
  }


  export type PatternPermissionMinAggregateInputType = {
    id?: true
    patternId?: true
    userId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
  }

  export type PatternPermissionMaxAggregateInputType = {
    id?: true
    patternId?: true
    userId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
  }

  export type PatternPermissionCountAggregateInputType = {
    id?: true
    patternId?: true
    userId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
    _all?: true
  }

  export type PatternPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternPermission to aggregate.
     */
    where?: PatternPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternPermissions to fetch.
     */
    orderBy?: PatternPermissionOrderByWithRelationInput | PatternPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PatternPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PatternPermissions
    **/
    _count?: true | PatternPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: PatternPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: PatternPermissionMaxAggregateInputType
  }

  export type GetPatternPermissionAggregateType<T extends PatternPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePatternPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatternPermission[P]>
      : GetScalarType<T[P], AggregatePatternPermission[P]>
  }




  export type PatternPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternPermissionWhereInput
    orderBy?: PatternPermissionOrderByWithAggregationInput | PatternPermissionOrderByWithAggregationInput[]
    by: PatternPermissionScalarFieldEnum[] | PatternPermissionScalarFieldEnum
    having?: PatternPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatternPermissionCountAggregateInputType | true
    _min?: PatternPermissionMinAggregateInputType
    _max?: PatternPermissionMaxAggregateInputType
  }

  export type PatternPermissionGroupByOutputType = {
    id: string
    patternId: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt: Date
    _count: PatternPermissionCountAggregateOutputType | null
    _min: PatternPermissionMinAggregateOutputType | null
    _max: PatternPermissionMaxAggregateOutputType | null
  }

  type GetPatternPermissionGroupByPayload<T extends PatternPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatternPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatternPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatternPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PatternPermissionGroupByOutputType[P]>
        }
      >
    >


  export type PatternPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    userId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternPermission"]>

  export type PatternPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    userId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternPermission"]>

  export type PatternPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    userId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternPermission"]>

  export type PatternPermissionSelectScalar = {
    id?: boolean
    patternId?: boolean
    userId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
  }

  export type PatternPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patternId" | "userId" | "permission" | "grantedById" | "grantedAt", ExtArgs["result"]["patternPermission"]>
  export type PatternPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
  }
  export type PatternPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
  }
  export type PatternPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
  }

  export type $PatternPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatternPermission"
    objects: {
      pattern: Prisma.$ArgumentPatternPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patternId: string
      userId: string
      permission: $Enums.PermissionLevel
      grantedById: string
      grantedAt: Date
    }, ExtArgs["result"]["patternPermission"]>
    composites: {}
  }

  type PatternPermissionGetPayload<S extends boolean | null | undefined | PatternPermissionDefaultArgs> = $Result.GetResult<Prisma.$PatternPermissionPayload, S>

  type PatternPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatternPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatternPermissionCountAggregateInputType | true
    }

  export interface PatternPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatternPermission'], meta: { name: 'PatternPermission' } }
    /**
     * Find zero or one PatternPermission that matches the filter.
     * @param {PatternPermissionFindUniqueArgs} args - Arguments to find a PatternPermission
     * @example
     * // Get one PatternPermission
     * const patternPermission = await prisma.patternPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatternPermissionFindUniqueArgs>(args: SelectSubset<T, PatternPermissionFindUniqueArgs<ExtArgs>>): Prisma__PatternPermissionClient<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatternPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatternPermissionFindUniqueOrThrowArgs} args - Arguments to find a PatternPermission
     * @example
     * // Get one PatternPermission
     * const patternPermission = await prisma.patternPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatternPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PatternPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatternPermissionClient<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatternPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternPermissionFindFirstArgs} args - Arguments to find a PatternPermission
     * @example
     * // Get one PatternPermission
     * const patternPermission = await prisma.patternPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatternPermissionFindFirstArgs>(args?: SelectSubset<T, PatternPermissionFindFirstArgs<ExtArgs>>): Prisma__PatternPermissionClient<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatternPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternPermissionFindFirstOrThrowArgs} args - Arguments to find a PatternPermission
     * @example
     * // Get one PatternPermission
     * const patternPermission = await prisma.patternPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatternPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PatternPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatternPermissionClient<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatternPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatternPermissions
     * const patternPermissions = await prisma.patternPermission.findMany()
     *
     * // Get first 10 PatternPermissions
     * const patternPermissions = await prisma.patternPermission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const patternPermissionWithIdOnly = await prisma.patternPermission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PatternPermissionFindManyArgs>(args?: SelectSubset<T, PatternPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatternPermission.
     * @param {PatternPermissionCreateArgs} args - Arguments to create a PatternPermission.
     * @example
     * // Create one PatternPermission
     * const PatternPermission = await prisma.patternPermission.create({
     *   data: {
     *     // ... data to create a PatternPermission
     *   }
     * })
     *
     */
    create<T extends PatternPermissionCreateArgs>(args: SelectSubset<T, PatternPermissionCreateArgs<ExtArgs>>): Prisma__PatternPermissionClient<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatternPermissions.
     * @param {PatternPermissionCreateManyArgs} args - Arguments to create many PatternPermissions.
     * @example
     * // Create many PatternPermissions
     * const patternPermission = await prisma.patternPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PatternPermissionCreateManyArgs>(args?: SelectSubset<T, PatternPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatternPermissions and returns the data saved in the database.
     * @param {PatternPermissionCreateManyAndReturnArgs} args - Arguments to create many PatternPermissions.
     * @example
     * // Create many PatternPermissions
     * const patternPermission = await prisma.patternPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PatternPermissions and only return the `id`
     * const patternPermissionWithIdOnly = await prisma.patternPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PatternPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PatternPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatternPermission.
     * @param {PatternPermissionDeleteArgs} args - Arguments to delete one PatternPermission.
     * @example
     * // Delete one PatternPermission
     * const PatternPermission = await prisma.patternPermission.delete({
     *   where: {
     *     // ... filter to delete one PatternPermission
     *   }
     * })
     *
     */
    delete<T extends PatternPermissionDeleteArgs>(args: SelectSubset<T, PatternPermissionDeleteArgs<ExtArgs>>): Prisma__PatternPermissionClient<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatternPermission.
     * @param {PatternPermissionUpdateArgs} args - Arguments to update one PatternPermission.
     * @example
     * // Update one PatternPermission
     * const patternPermission = await prisma.patternPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PatternPermissionUpdateArgs>(args: SelectSubset<T, PatternPermissionUpdateArgs<ExtArgs>>): Prisma__PatternPermissionClient<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatternPermissions.
     * @param {PatternPermissionDeleteManyArgs} args - Arguments to filter PatternPermissions to delete.
     * @example
     * // Delete a few PatternPermissions
     * const { count } = await prisma.patternPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PatternPermissionDeleteManyArgs>(args?: SelectSubset<T, PatternPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatternPermissions
     * const patternPermission = await prisma.patternPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PatternPermissionUpdateManyArgs>(args: SelectSubset<T, PatternPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternPermissions and returns the data updated in the database.
     * @param {PatternPermissionUpdateManyAndReturnArgs} args - Arguments to update many PatternPermissions.
     * @example
     * // Update many PatternPermissions
     * const patternPermission = await prisma.patternPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PatternPermissions and only return the `id`
     * const patternPermissionWithIdOnly = await prisma.patternPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PatternPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PatternPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatternPermission.
     * @param {PatternPermissionUpsertArgs} args - Arguments to update or create a PatternPermission.
     * @example
     * // Update or create a PatternPermission
     * const patternPermission = await prisma.patternPermission.upsert({
     *   create: {
     *     // ... data to create a PatternPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatternPermission we want to update
     *   }
     * })
     */
    upsert<T extends PatternPermissionUpsertArgs>(args: SelectSubset<T, PatternPermissionUpsertArgs<ExtArgs>>): Prisma__PatternPermissionClient<$Result.GetResult<Prisma.$PatternPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatternPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternPermissionCountArgs} args - Arguments to filter PatternPermissions to count.
     * @example
     * // Count the number of PatternPermissions
     * const count = await prisma.patternPermission.count({
     *   where: {
     *     // ... the filter for the PatternPermissions we want to count
     *   }
     * })
    **/
    count<T extends PatternPermissionCountArgs>(
      args?: Subset<T, PatternPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatternPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatternPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatternPermissionAggregateArgs>(args: Subset<T, PatternPermissionAggregateArgs>): Prisma.PrismaPromise<GetPatternPermissionAggregateType<T>>

    /**
     * Group by PatternPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends PatternPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatternPermissionGroupByArgs['orderBy'] }
        : { orderBy?: PatternPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatternPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatternPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatternPermission model
   */
  readonly fields: PatternPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatternPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatternPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pattern<T extends ArgumentPatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArgumentPatternDefaultArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatternPermission model
   */
  interface PatternPermissionFieldRefs {
    readonly id: FieldRef<"PatternPermission", 'String'>
    readonly patternId: FieldRef<"PatternPermission", 'String'>
    readonly userId: FieldRef<"PatternPermission", 'String'>
    readonly permission: FieldRef<"PatternPermission", 'PermissionLevel'>
    readonly grantedById: FieldRef<"PatternPermission", 'String'>
    readonly grantedAt: FieldRef<"PatternPermission", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * PatternPermission findUnique
   */
  export type PatternPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternPermission to fetch.
     */
    where: PatternPermissionWhereUniqueInput
  }

  /**
   * PatternPermission findUniqueOrThrow
   */
  export type PatternPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternPermission to fetch.
     */
    where: PatternPermissionWhereUniqueInput
  }

  /**
   * PatternPermission findFirst
   */
  export type PatternPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternPermission to fetch.
     */
    where?: PatternPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternPermissions to fetch.
     */
    orderBy?: PatternPermissionOrderByWithRelationInput | PatternPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PatternPermissions.
     */
    cursor?: PatternPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PatternPermissions.
     */
    distinct?: PatternPermissionScalarFieldEnum | PatternPermissionScalarFieldEnum[]
  }

  /**
   * PatternPermission findFirstOrThrow
   */
  export type PatternPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternPermission to fetch.
     */
    where?: PatternPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternPermissions to fetch.
     */
    orderBy?: PatternPermissionOrderByWithRelationInput | PatternPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PatternPermissions.
     */
    cursor?: PatternPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PatternPermissions.
     */
    distinct?: PatternPermissionScalarFieldEnum | PatternPermissionScalarFieldEnum[]
  }

  /**
   * PatternPermission findMany
   */
  export type PatternPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternPermissions to fetch.
     */
    where?: PatternPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternPermissions to fetch.
     */
    orderBy?: PatternPermissionOrderByWithRelationInput | PatternPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PatternPermissions.
     */
    cursor?: PatternPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternPermissions.
     */
    skip?: number
    distinct?: PatternPermissionScalarFieldEnum | PatternPermissionScalarFieldEnum[]
  }

  /**
   * PatternPermission create
   */
  export type PatternPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a PatternPermission.
     */
    data: XOR<PatternPermissionCreateInput, PatternPermissionUncheckedCreateInput>
  }

  /**
   * PatternPermission createMany
   */
  export type PatternPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatternPermissions.
     */
    data: PatternPermissionCreateManyInput | PatternPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatternPermission createManyAndReturn
   */
  export type PatternPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many PatternPermissions.
     */
    data: PatternPermissionCreateManyInput | PatternPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternPermission update
   */
  export type PatternPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a PatternPermission.
     */
    data: XOR<PatternPermissionUpdateInput, PatternPermissionUncheckedUpdateInput>
    /**
     * Choose, which PatternPermission to update.
     */
    where: PatternPermissionWhereUniqueInput
  }

  /**
   * PatternPermission updateMany
   */
  export type PatternPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatternPermissions.
     */
    data: XOR<PatternPermissionUpdateManyMutationInput, PatternPermissionUncheckedUpdateManyInput>
    /**
     * Filter which PatternPermissions to update
     */
    where?: PatternPermissionWhereInput
    /**
     * Limit how many PatternPermissions to update.
     */
    limit?: number
  }

  /**
   * PatternPermission updateManyAndReturn
   */
  export type PatternPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * The data used to update PatternPermissions.
     */
    data: XOR<PatternPermissionUpdateManyMutationInput, PatternPermissionUncheckedUpdateManyInput>
    /**
     * Filter which PatternPermissions to update
     */
    where?: PatternPermissionWhereInput
    /**
     * Limit how many PatternPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternPermission upsert
   */
  export type PatternPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the PatternPermission to update in case it exists.
     */
    where: PatternPermissionWhereUniqueInput
    /**
     * In case the PatternPermission found by the `where` argument doesn't exist, create a new PatternPermission with this data.
     */
    create: XOR<PatternPermissionCreateInput, PatternPermissionUncheckedCreateInput>
    /**
     * In case the PatternPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatternPermissionUpdateInput, PatternPermissionUncheckedUpdateInput>
  }

  /**
   * PatternPermission delete
   */
  export type PatternPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
    /**
     * Filter which PatternPermission to delete.
     */
    where: PatternPermissionWhereUniqueInput
  }

  /**
   * PatternPermission deleteMany
   */
  export type PatternPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternPermissions to delete
     */
    where?: PatternPermissionWhereInput
    /**
     * Limit how many PatternPermissions to delete.
     */
    limit?: number
  }

  /**
   * PatternPermission without action
   */
  export type PatternPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternPermission
     */
    select?: PatternPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternPermission
     */
    omit?: PatternPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternPermissionInclude<ExtArgs> | null
  }


  /**
   * Model PatternTeamPermission
   */

  export type AggregatePatternTeamPermission = {
    _count: PatternTeamPermissionCountAggregateOutputType | null
    _min: PatternTeamPermissionMinAggregateOutputType | null
    _max: PatternTeamPermissionMaxAggregateOutputType | null
  }

  export type PatternTeamPermissionMinAggregateOutputType = {
    id: string | null
    patternId: string | null
    teamId: string | null
    permission: $Enums.PermissionLevel | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type PatternTeamPermissionMaxAggregateOutputType = {
    id: string | null
    patternId: string | null
    teamId: string | null
    permission: $Enums.PermissionLevel | null
    grantedById: string | null
    grantedAt: Date | null
  }

  export type PatternTeamPermissionCountAggregateOutputType = {
    id: number
    patternId: number
    teamId: number
    permission: number
    grantedById: number
    grantedAt: number
    _all: number
  }


  export type PatternTeamPermissionMinAggregateInputType = {
    id?: true
    patternId?: true
    teamId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
  }

  export type PatternTeamPermissionMaxAggregateInputType = {
    id?: true
    patternId?: true
    teamId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
  }

  export type PatternTeamPermissionCountAggregateInputType = {
    id?: true
    patternId?: true
    teamId?: true
    permission?: true
    grantedById?: true
    grantedAt?: true
    _all?: true
  }

  export type PatternTeamPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternTeamPermission to aggregate.
     */
    where?: PatternTeamPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternTeamPermissions to fetch.
     */
    orderBy?: PatternTeamPermissionOrderByWithRelationInput | PatternTeamPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PatternTeamPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternTeamPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternTeamPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PatternTeamPermissions
    **/
    _count?: true | PatternTeamPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: PatternTeamPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: PatternTeamPermissionMaxAggregateInputType
  }

  export type GetPatternTeamPermissionAggregateType<T extends PatternTeamPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePatternTeamPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatternTeamPermission[P]>
      : GetScalarType<T[P], AggregatePatternTeamPermission[P]>
  }




  export type PatternTeamPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatternTeamPermissionWhereInput
    orderBy?: PatternTeamPermissionOrderByWithAggregationInput | PatternTeamPermissionOrderByWithAggregationInput[]
    by: PatternTeamPermissionScalarFieldEnum[] | PatternTeamPermissionScalarFieldEnum
    having?: PatternTeamPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatternTeamPermissionCountAggregateInputType | true
    _min?: PatternTeamPermissionMinAggregateInputType
    _max?: PatternTeamPermissionMaxAggregateInputType
  }

  export type PatternTeamPermissionGroupByOutputType = {
    id: string
    patternId: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt: Date
    _count: PatternTeamPermissionCountAggregateOutputType | null
    _min: PatternTeamPermissionMinAggregateOutputType | null
    _max: PatternTeamPermissionMaxAggregateOutputType | null
  }

  type GetPatternTeamPermissionGroupByPayload<T extends PatternTeamPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatternTeamPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatternTeamPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatternTeamPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PatternTeamPermissionGroupByOutputType[P]>
        }
      >
    >


  export type PatternTeamPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    teamId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternTeamPermission"]>

  export type PatternTeamPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    teamId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternTeamPermission"]>

  export type PatternTeamPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patternId?: boolean
    teamId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patternTeamPermission"]>

  export type PatternTeamPermissionSelectScalar = {
    id?: boolean
    patternId?: boolean
    teamId?: boolean
    permission?: boolean
    grantedById?: boolean
    grantedAt?: boolean
  }

  export type PatternTeamPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patternId" | "teamId" | "permission" | "grantedById" | "grantedAt", ExtArgs["result"]["patternTeamPermission"]>
  export type PatternTeamPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type PatternTeamPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }
  export type PatternTeamPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pattern?: boolean | ArgumentPatternDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
  }

  export type $PatternTeamPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatternTeamPermission"
    objects: {
      pattern: Prisma.$ArgumentPatternPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patternId: string
      teamId: string
      permission: $Enums.PermissionLevel
      grantedById: string
      grantedAt: Date
    }, ExtArgs["result"]["patternTeamPermission"]>
    composites: {}
  }

  type PatternTeamPermissionGetPayload<S extends boolean | null | undefined | PatternTeamPermissionDefaultArgs> = $Result.GetResult<Prisma.$PatternTeamPermissionPayload, S>

  type PatternTeamPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PatternTeamPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatternTeamPermissionCountAggregateInputType | true
    }

  export interface PatternTeamPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatternTeamPermission'], meta: { name: 'PatternTeamPermission' } }
    /**
     * Find zero or one PatternTeamPermission that matches the filter.
     * @param {PatternTeamPermissionFindUniqueArgs} args - Arguments to find a PatternTeamPermission
     * @example
     * // Get one PatternTeamPermission
     * const patternTeamPermission = await prisma.patternTeamPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatternTeamPermissionFindUniqueArgs>(args: SelectSubset<T, PatternTeamPermissionFindUniqueArgs<ExtArgs>>): Prisma__PatternTeamPermissionClient<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PatternTeamPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PatternTeamPermissionFindUniqueOrThrowArgs} args - Arguments to find a PatternTeamPermission
     * @example
     * // Get one PatternTeamPermission
     * const patternTeamPermission = await prisma.patternTeamPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatternTeamPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PatternTeamPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatternTeamPermissionClient<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatternTeamPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTeamPermissionFindFirstArgs} args - Arguments to find a PatternTeamPermission
     * @example
     * // Get one PatternTeamPermission
     * const patternTeamPermission = await prisma.patternTeamPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatternTeamPermissionFindFirstArgs>(args?: SelectSubset<T, PatternTeamPermissionFindFirstArgs<ExtArgs>>): Prisma__PatternTeamPermissionClient<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PatternTeamPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTeamPermissionFindFirstOrThrowArgs} args - Arguments to find a PatternTeamPermission
     * @example
     * // Get one PatternTeamPermission
     * const patternTeamPermission = await prisma.patternTeamPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatternTeamPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PatternTeamPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatternTeamPermissionClient<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PatternTeamPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTeamPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatternTeamPermissions
     * const patternTeamPermissions = await prisma.patternTeamPermission.findMany()
     *
     * // Get first 10 PatternTeamPermissions
     * const patternTeamPermissions = await prisma.patternTeamPermission.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const patternTeamPermissionWithIdOnly = await prisma.patternTeamPermission.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PatternTeamPermissionFindManyArgs>(args?: SelectSubset<T, PatternTeamPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PatternTeamPermission.
     * @param {PatternTeamPermissionCreateArgs} args - Arguments to create a PatternTeamPermission.
     * @example
     * // Create one PatternTeamPermission
     * const PatternTeamPermission = await prisma.patternTeamPermission.create({
     *   data: {
     *     // ... data to create a PatternTeamPermission
     *   }
     * })
     *
     */
    create<T extends PatternTeamPermissionCreateArgs>(args: SelectSubset<T, PatternTeamPermissionCreateArgs<ExtArgs>>): Prisma__PatternTeamPermissionClient<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PatternTeamPermissions.
     * @param {PatternTeamPermissionCreateManyArgs} args - Arguments to create many PatternTeamPermissions.
     * @example
     * // Create many PatternTeamPermissions
     * const patternTeamPermission = await prisma.patternTeamPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PatternTeamPermissionCreateManyArgs>(args?: SelectSubset<T, PatternTeamPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatternTeamPermissions and returns the data saved in the database.
     * @param {PatternTeamPermissionCreateManyAndReturnArgs} args - Arguments to create many PatternTeamPermissions.
     * @example
     * // Create many PatternTeamPermissions
     * const patternTeamPermission = await prisma.patternTeamPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PatternTeamPermissions and only return the `id`
     * const patternTeamPermissionWithIdOnly = await prisma.patternTeamPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PatternTeamPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, PatternTeamPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PatternTeamPermission.
     * @param {PatternTeamPermissionDeleteArgs} args - Arguments to delete one PatternTeamPermission.
     * @example
     * // Delete one PatternTeamPermission
     * const PatternTeamPermission = await prisma.patternTeamPermission.delete({
     *   where: {
     *     // ... filter to delete one PatternTeamPermission
     *   }
     * })
     *
     */
    delete<T extends PatternTeamPermissionDeleteArgs>(args: SelectSubset<T, PatternTeamPermissionDeleteArgs<ExtArgs>>): Prisma__PatternTeamPermissionClient<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PatternTeamPermission.
     * @param {PatternTeamPermissionUpdateArgs} args - Arguments to update one PatternTeamPermission.
     * @example
     * // Update one PatternTeamPermission
     * const patternTeamPermission = await prisma.patternTeamPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PatternTeamPermissionUpdateArgs>(args: SelectSubset<T, PatternTeamPermissionUpdateArgs<ExtArgs>>): Prisma__PatternTeamPermissionClient<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PatternTeamPermissions.
     * @param {PatternTeamPermissionDeleteManyArgs} args - Arguments to filter PatternTeamPermissions to delete.
     * @example
     * // Delete a few PatternTeamPermissions
     * const { count } = await prisma.patternTeamPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PatternTeamPermissionDeleteManyArgs>(args?: SelectSubset<T, PatternTeamPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternTeamPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTeamPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatternTeamPermissions
     * const patternTeamPermission = await prisma.patternTeamPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PatternTeamPermissionUpdateManyArgs>(args: SelectSubset<T, PatternTeamPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatternTeamPermissions and returns the data updated in the database.
     * @param {PatternTeamPermissionUpdateManyAndReturnArgs} args - Arguments to update many PatternTeamPermissions.
     * @example
     * // Update many PatternTeamPermissions
     * const patternTeamPermission = await prisma.patternTeamPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PatternTeamPermissions and only return the `id`
     * const patternTeamPermissionWithIdOnly = await prisma.patternTeamPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PatternTeamPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, PatternTeamPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PatternTeamPermission.
     * @param {PatternTeamPermissionUpsertArgs} args - Arguments to update or create a PatternTeamPermission.
     * @example
     * // Update or create a PatternTeamPermission
     * const patternTeamPermission = await prisma.patternTeamPermission.upsert({
     *   create: {
     *     // ... data to create a PatternTeamPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatternTeamPermission we want to update
     *   }
     * })
     */
    upsert<T extends PatternTeamPermissionUpsertArgs>(args: SelectSubset<T, PatternTeamPermissionUpsertArgs<ExtArgs>>): Prisma__PatternTeamPermissionClient<$Result.GetResult<Prisma.$PatternTeamPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PatternTeamPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTeamPermissionCountArgs} args - Arguments to filter PatternTeamPermissions to count.
     * @example
     * // Count the number of PatternTeamPermissions
     * const count = await prisma.patternTeamPermission.count({
     *   where: {
     *     // ... the filter for the PatternTeamPermissions we want to count
     *   }
     * })
    **/
    count<T extends PatternTeamPermissionCountArgs>(
      args?: Subset<T, PatternTeamPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatternTeamPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatternTeamPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTeamPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatternTeamPermissionAggregateArgs>(args: Subset<T, PatternTeamPermissionAggregateArgs>): Prisma.PrismaPromise<GetPatternTeamPermissionAggregateType<T>>

    /**
     * Group by PatternTeamPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatternTeamPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends PatternTeamPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatternTeamPermissionGroupByArgs['orderBy'] }
        : { orderBy?: PatternTeamPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatternTeamPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatternTeamPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatternTeamPermission model
   */
  readonly fields: PatternTeamPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatternTeamPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatternTeamPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pattern<T extends ArgumentPatternDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ArgumentPatternDefaultArgs<ExtArgs>>): Prisma__ArgumentPatternClient<$Result.GetResult<Prisma.$ArgumentPatternPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatternTeamPermission model
   */
  interface PatternTeamPermissionFieldRefs {
    readonly id: FieldRef<"PatternTeamPermission", 'String'>
    readonly patternId: FieldRef<"PatternTeamPermission", 'String'>
    readonly teamId: FieldRef<"PatternTeamPermission", 'String'>
    readonly permission: FieldRef<"PatternTeamPermission", 'PermissionLevel'>
    readonly grantedById: FieldRef<"PatternTeamPermission", 'String'>
    readonly grantedAt: FieldRef<"PatternTeamPermission", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * PatternTeamPermission findUnique
   */
  export type PatternTeamPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternTeamPermission to fetch.
     */
    where: PatternTeamPermissionWhereUniqueInput
  }

  /**
   * PatternTeamPermission findUniqueOrThrow
   */
  export type PatternTeamPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternTeamPermission to fetch.
     */
    where: PatternTeamPermissionWhereUniqueInput
  }

  /**
   * PatternTeamPermission findFirst
   */
  export type PatternTeamPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternTeamPermission to fetch.
     */
    where?: PatternTeamPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternTeamPermissions to fetch.
     */
    orderBy?: PatternTeamPermissionOrderByWithRelationInput | PatternTeamPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PatternTeamPermissions.
     */
    cursor?: PatternTeamPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternTeamPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternTeamPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PatternTeamPermissions.
     */
    distinct?: PatternTeamPermissionScalarFieldEnum | PatternTeamPermissionScalarFieldEnum[]
  }

  /**
   * PatternTeamPermission findFirstOrThrow
   */
  export type PatternTeamPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternTeamPermission to fetch.
     */
    where?: PatternTeamPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternTeamPermissions to fetch.
     */
    orderBy?: PatternTeamPermissionOrderByWithRelationInput | PatternTeamPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PatternTeamPermissions.
     */
    cursor?: PatternTeamPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternTeamPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternTeamPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PatternTeamPermissions.
     */
    distinct?: PatternTeamPermissionScalarFieldEnum | PatternTeamPermissionScalarFieldEnum[]
  }

  /**
   * PatternTeamPermission findMany
   */
  export type PatternTeamPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter, which PatternTeamPermissions to fetch.
     */
    where?: PatternTeamPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PatternTeamPermissions to fetch.
     */
    orderBy?: PatternTeamPermissionOrderByWithRelationInput | PatternTeamPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PatternTeamPermissions.
     */
    cursor?: PatternTeamPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PatternTeamPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PatternTeamPermissions.
     */
    skip?: number
    distinct?: PatternTeamPermissionScalarFieldEnum | PatternTeamPermissionScalarFieldEnum[]
  }

  /**
   * PatternTeamPermission create
   */
  export type PatternTeamPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a PatternTeamPermission.
     */
    data: XOR<PatternTeamPermissionCreateInput, PatternTeamPermissionUncheckedCreateInput>
  }

  /**
   * PatternTeamPermission createMany
   */
  export type PatternTeamPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatternTeamPermissions.
     */
    data: PatternTeamPermissionCreateManyInput | PatternTeamPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatternTeamPermission createManyAndReturn
   */
  export type PatternTeamPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many PatternTeamPermissions.
     */
    data: PatternTeamPermissionCreateManyInput | PatternTeamPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternTeamPermission update
   */
  export type PatternTeamPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a PatternTeamPermission.
     */
    data: XOR<PatternTeamPermissionUpdateInput, PatternTeamPermissionUncheckedUpdateInput>
    /**
     * Choose, which PatternTeamPermission to update.
     */
    where: PatternTeamPermissionWhereUniqueInput
  }

  /**
   * PatternTeamPermission updateMany
   */
  export type PatternTeamPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatternTeamPermissions.
     */
    data: XOR<PatternTeamPermissionUpdateManyMutationInput, PatternTeamPermissionUncheckedUpdateManyInput>
    /**
     * Filter which PatternTeamPermissions to update
     */
    where?: PatternTeamPermissionWhereInput
    /**
     * Limit how many PatternTeamPermissions to update.
     */
    limit?: number
  }

  /**
   * PatternTeamPermission updateManyAndReturn
   */
  export type PatternTeamPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * The data used to update PatternTeamPermissions.
     */
    data: XOR<PatternTeamPermissionUpdateManyMutationInput, PatternTeamPermissionUncheckedUpdateManyInput>
    /**
     * Filter which PatternTeamPermissions to update
     */
    where?: PatternTeamPermissionWhereInput
    /**
     * Limit how many PatternTeamPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatternTeamPermission upsert
   */
  export type PatternTeamPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the PatternTeamPermission to update in case it exists.
     */
    where: PatternTeamPermissionWhereUniqueInput
    /**
     * In case the PatternTeamPermission found by the `where` argument doesn't exist, create a new PatternTeamPermission with this data.
     */
    create: XOR<PatternTeamPermissionCreateInput, PatternTeamPermissionUncheckedCreateInput>
    /**
     * In case the PatternTeamPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatternTeamPermissionUpdateInput, PatternTeamPermissionUncheckedUpdateInput>
  }

  /**
   * PatternTeamPermission delete
   */
  export type PatternTeamPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
    /**
     * Filter which PatternTeamPermission to delete.
     */
    where: PatternTeamPermissionWhereUniqueInput
  }

  /**
   * PatternTeamPermission deleteMany
   */
  export type PatternTeamPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatternTeamPermissions to delete
     */
    where?: PatternTeamPermissionWhereInput
    /**
     * Limit how many PatternTeamPermissions to delete.
     */
    limit?: number
  }

  /**
   * PatternTeamPermission without action
   */
  export type PatternTeamPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatternTeamPermission
     */
    select?: PatternTeamPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PatternTeamPermission
     */
    omit?: PatternTeamPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatternTeamPermissionInclude<ExtArgs> | null
  }


  /**
   * Model Release
   */

  export type AggregateRelease = {
    _count: ReleaseCountAggregateOutputType | null
    _avg: ReleaseAvgAggregateOutputType | null
    _sum: ReleaseSumAggregateOutputType | null
    _min: ReleaseMinAggregateOutputType | null
    _max: ReleaseMaxAggregateOutputType | null
  }

  export type ReleaseAvgAggregateOutputType = {
    currentVersion: number | null
  }

  export type ReleaseSumAggregateOutputType = {
    currentVersion: number | null
  }

  export type ReleaseMinAggregateOutputType = {
    id: string | null
    sourceCaseId: string | null
    publishedCaseId: string | null
    title: string | null
    description: string | null
    currentVersion: number | null
    authors: string | null
    contactEmail: string | null
    category: string | null
    sector: string | null
    status: $Enums.ReleaseStatus | null
    firstPublishedAt: Date | null
    lastUpdatedAt: Date | null
    allowComments: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseMaxAggregateOutputType = {
    id: string | null
    sourceCaseId: string | null
    publishedCaseId: string | null
    title: string | null
    description: string | null
    currentVersion: number | null
    authors: string | null
    contactEmail: string | null
    category: string | null
    sector: string | null
    status: $Enums.ReleaseStatus | null
    firstPublishedAt: Date | null
    lastUpdatedAt: Date | null
    allowComments: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseCountAggregateOutputType = {
    id: number
    sourceCaseId: number
    publishedCaseId: number
    title: number
    description: number
    currentVersion: number
    authors: number
    contactEmail: number
    category: number
    sector: number
    tags: number
    status: number
    firstPublishedAt: number
    lastUpdatedAt: number
    allowComments: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReleaseAvgAggregateInputType = {
    currentVersion?: true
  }

  export type ReleaseSumAggregateInputType = {
    currentVersion?: true
  }

  export type ReleaseMinAggregateInputType = {
    id?: true
    sourceCaseId?: true
    publishedCaseId?: true
    title?: true
    description?: true
    currentVersion?: true
    authors?: true
    contactEmail?: true
    category?: true
    sector?: true
    status?: true
    firstPublishedAt?: true
    lastUpdatedAt?: true
    allowComments?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseMaxAggregateInputType = {
    id?: true
    sourceCaseId?: true
    publishedCaseId?: true
    title?: true
    description?: true
    currentVersion?: true
    authors?: true
    contactEmail?: true
    category?: true
    sector?: true
    status?: true
    firstPublishedAt?: true
    lastUpdatedAt?: true
    allowComments?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseCountAggregateInputType = {
    id?: true
    sourceCaseId?: true
    publishedCaseId?: true
    title?: true
    description?: true
    currentVersion?: true
    authors?: true
    contactEmail?: true
    category?: true
    sector?: true
    tags?: true
    status?: true
    firstPublishedAt?: true
    lastUpdatedAt?: true
    allowComments?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReleaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Release to aggregate.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Releases
    **/
    _count?: true | ReleaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: ReleaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: ReleaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: ReleaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: ReleaseMaxAggregateInputType
  }

  export type GetReleaseAggregateType<T extends ReleaseAggregateArgs> = {
        [P in keyof T & keyof AggregateRelease]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRelease[P]>
      : GetScalarType<T[P], AggregateRelease[P]>
  }




  export type ReleaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseWhereInput
    orderBy?: ReleaseOrderByWithAggregationInput | ReleaseOrderByWithAggregationInput[]
    by: ReleaseScalarFieldEnum[] | ReleaseScalarFieldEnum
    having?: ReleaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleaseCountAggregateInputType | true
    _avg?: ReleaseAvgAggregateInputType
    _sum?: ReleaseSumAggregateInputType
    _min?: ReleaseMinAggregateInputType
    _max?: ReleaseMaxAggregateInputType
  }

  export type ReleaseGroupByOutputType = {
    id: string
    sourceCaseId: string
    publishedCaseId: string | null
    title: string
    description: string
    currentVersion: number
    authors: string
    contactEmail: string | null
    category: string | null
    sector: string | null
    tags: string[]
    status: $Enums.ReleaseStatus
    firstPublishedAt: Date | null
    lastUpdatedAt: Date | null
    allowComments: boolean
    createdById: string
    createdAt: Date
    updatedAt: Date
    _count: ReleaseCountAggregateOutputType | null
    _avg: ReleaseAvgAggregateOutputType | null
    _sum: ReleaseSumAggregateOutputType | null
    _min: ReleaseMinAggregateOutputType | null
    _max: ReleaseMaxAggregateOutputType | null
  }

  type GetReleaseGroupByPayload<T extends ReleaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleaseGroupByOutputType[P]>
            : GetScalarType<T[P], ReleaseGroupByOutputType[P]>
        }
      >
    >


  export type ReleaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceCaseId?: boolean
    publishedCaseId?: boolean
    title?: boolean
    description?: boolean
    currentVersion?: boolean
    authors?: boolean
    contactEmail?: boolean
    category?: boolean
    sector?: boolean
    tags?: boolean
    status?: boolean
    firstPublishedAt?: boolean
    lastUpdatedAt?: boolean
    allowComments?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    publishedCase?: boolean | Release$publishedCaseArgs<ExtArgs>
    snapshots?: boolean | Release$snapshotsArgs<ExtArgs>
    comments?: boolean | Release$commentsArgs<ExtArgs>
    image?: boolean | Release$imageArgs<ExtArgs>
    _count?: boolean | ReleaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["release"]>

  export type ReleaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceCaseId?: boolean
    publishedCaseId?: boolean
    title?: boolean
    description?: boolean
    currentVersion?: boolean
    authors?: boolean
    contactEmail?: boolean
    category?: boolean
    sector?: boolean
    tags?: boolean
    status?: boolean
    firstPublishedAt?: boolean
    lastUpdatedAt?: boolean
    allowComments?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    publishedCase?: boolean | Release$publishedCaseArgs<ExtArgs>
  }, ExtArgs["result"]["release"]>

  export type ReleaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sourceCaseId?: boolean
    publishedCaseId?: boolean
    title?: boolean
    description?: boolean
    currentVersion?: boolean
    authors?: boolean
    contactEmail?: boolean
    category?: boolean
    sector?: boolean
    tags?: boolean
    status?: boolean
    firstPublishedAt?: boolean
    lastUpdatedAt?: boolean
    allowComments?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sourceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    publishedCase?: boolean | Release$publishedCaseArgs<ExtArgs>
  }, ExtArgs["result"]["release"]>

  export type ReleaseSelectScalar = {
    id?: boolean
    sourceCaseId?: boolean
    publishedCaseId?: boolean
    title?: boolean
    description?: boolean
    currentVersion?: boolean
    authors?: boolean
    contactEmail?: boolean
    category?: boolean
    sector?: boolean
    tags?: boolean
    status?: boolean
    firstPublishedAt?: boolean
    lastUpdatedAt?: boolean
    allowComments?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReleaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sourceCaseId" | "publishedCaseId" | "title" | "description" | "currentVersion" | "authors" | "contactEmail" | "category" | "sector" | "tags" | "status" | "firstPublishedAt" | "lastUpdatedAt" | "allowComments" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["release"]>
  export type ReleaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    publishedCase?: boolean | Release$publishedCaseArgs<ExtArgs>
    snapshots?: boolean | Release$snapshotsArgs<ExtArgs>
    comments?: boolean | Release$commentsArgs<ExtArgs>
    image?: boolean | Release$imageArgs<ExtArgs>
    _count?: boolean | ReleaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReleaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    publishedCase?: boolean | Release$publishedCaseArgs<ExtArgs>
  }
  export type ReleaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    publishedCase?: boolean | Release$publishedCaseArgs<ExtArgs>
  }

  export type $ReleasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Release"
    objects: {
      sourceCase: Prisma.$AssuranceCasePayload<ExtArgs>
      publishedCase: Prisma.$AssuranceCasePayload<ExtArgs> | null
      snapshots: Prisma.$ReleaseSnapshotPayload<ExtArgs>[]
      comments: Prisma.$ReleaseCommentPayload<ExtArgs>[]
      image: Prisma.$ReleaseImagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sourceCaseId: string
      publishedCaseId: string | null
      title: string
      description: string
      currentVersion: number
      authors: string
      contactEmail: string | null
      category: string | null
      sector: string | null
      tags: string[]
      status: $Enums.ReleaseStatus
      firstPublishedAt: Date | null
      lastUpdatedAt: Date | null
      allowComments: boolean
      createdById: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["release"]>
    composites: {}
  }

  type ReleaseGetPayload<S extends boolean | null | undefined | ReleaseDefaultArgs> = $Result.GetResult<Prisma.$ReleasePayload, S>

  type ReleaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReleaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReleaseCountAggregateInputType | true
    }

  export interface ReleaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Release'], meta: { name: 'Release' } }
    /**
     * Find zero or one Release that matches the filter.
     * @param {ReleaseFindUniqueArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReleaseFindUniqueArgs>(args: SelectSubset<T, ReleaseFindUniqueArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Release that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReleaseFindUniqueOrThrowArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReleaseFindUniqueOrThrowArgs>(args: SelectSubset<T, ReleaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Release that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseFindFirstArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReleaseFindFirstArgs>(args?: SelectSubset<T, ReleaseFindFirstArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Release that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseFindFirstOrThrowArgs} args - Arguments to find a Release
     * @example
     * // Get one Release
     * const release = await prisma.release.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReleaseFindFirstOrThrowArgs>(args?: SelectSubset<T, ReleaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Releases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Releases
     * const releases = await prisma.release.findMany()
     *
     * // Get first 10 Releases
     * const releases = await prisma.release.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const releaseWithIdOnly = await prisma.release.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReleaseFindManyArgs>(args?: SelectSubset<T, ReleaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Release.
     * @param {ReleaseCreateArgs} args - Arguments to create a Release.
     * @example
     * // Create one Release
     * const Release = await prisma.release.create({
     *   data: {
     *     // ... data to create a Release
     *   }
     * })
     *
     */
    create<T extends ReleaseCreateArgs>(args: SelectSubset<T, ReleaseCreateArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Releases.
     * @param {ReleaseCreateManyArgs} args - Arguments to create many Releases.
     * @example
     * // Create many Releases
     * const release = await prisma.release.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReleaseCreateManyArgs>(args?: SelectSubset<T, ReleaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Releases and returns the data saved in the database.
     * @param {ReleaseCreateManyAndReturnArgs} args - Arguments to create many Releases.
     * @example
     * // Create many Releases
     * const release = await prisma.release.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Releases and only return the `id`
     * const releaseWithIdOnly = await prisma.release.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReleaseCreateManyAndReturnArgs>(args?: SelectSubset<T, ReleaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Release.
     * @param {ReleaseDeleteArgs} args - Arguments to delete one Release.
     * @example
     * // Delete one Release
     * const Release = await prisma.release.delete({
     *   where: {
     *     // ... filter to delete one Release
     *   }
     * })
     *
     */
    delete<T extends ReleaseDeleteArgs>(args: SelectSubset<T, ReleaseDeleteArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Release.
     * @param {ReleaseUpdateArgs} args - Arguments to update one Release.
     * @example
     * // Update one Release
     * const release = await prisma.release.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReleaseUpdateArgs>(args: SelectSubset<T, ReleaseUpdateArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Releases.
     * @param {ReleaseDeleteManyArgs} args - Arguments to filter Releases to delete.
     * @example
     * // Delete a few Releases
     * const { count } = await prisma.release.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReleaseDeleteManyArgs>(args?: SelectSubset<T, ReleaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Releases
     * const release = await prisma.release.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReleaseUpdateManyArgs>(args: SelectSubset<T, ReleaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Releases and returns the data updated in the database.
     * @param {ReleaseUpdateManyAndReturnArgs} args - Arguments to update many Releases.
     * @example
     * // Update many Releases
     * const release = await prisma.release.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Releases and only return the `id`
     * const releaseWithIdOnly = await prisma.release.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReleaseUpdateManyAndReturnArgs>(args: SelectSubset<T, ReleaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Release.
     * @param {ReleaseUpsertArgs} args - Arguments to update or create a Release.
     * @example
     * // Update or create a Release
     * const release = await prisma.release.upsert({
     *   create: {
     *     // ... data to create a Release
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Release we want to update
     *   }
     * })
     */
    upsert<T extends ReleaseUpsertArgs>(args: SelectSubset<T, ReleaseUpsertArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Releases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCountArgs} args - Arguments to filter Releases to count.
     * @example
     * // Count the number of Releases
     * const count = await prisma.release.count({
     *   where: {
     *     // ... the filter for the Releases we want to count
     *   }
     * })
    **/
    count<T extends ReleaseCountArgs>(
      args?: Subset<T, ReleaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Release.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleaseAggregateArgs>(args: Subset<T, ReleaseAggregateArgs>): Prisma.PrismaPromise<GetReleaseAggregateType<T>>

    /**
     * Group by Release.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends ReleaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReleaseGroupByArgs['orderBy'] }
        : { orderBy?: ReleaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReleaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Release model
   */
  readonly fields: ReleaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Release.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReleaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sourceCase<T extends AssuranceCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCaseDefaultArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publishedCase<T extends Release$publishedCaseArgs<ExtArgs> = {}>(args?: Subset<T, Release$publishedCaseArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    snapshots<T extends Release$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Release$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Release$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Release$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    image<T extends Release$imageArgs<ExtArgs> = {}>(args?: Subset<T, Release$imageArgs<ExtArgs>>): Prisma__ReleaseImageClient<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Release model
   */
  interface ReleaseFieldRefs {
    readonly id: FieldRef<"Release", 'String'>
    readonly sourceCaseId: FieldRef<"Release", 'String'>
    readonly publishedCaseId: FieldRef<"Release", 'String'>
    readonly title: FieldRef<"Release", 'String'>
    readonly description: FieldRef<"Release", 'String'>
    readonly currentVersion: FieldRef<"Release", 'Int'>
    readonly authors: FieldRef<"Release", 'String'>
    readonly contactEmail: FieldRef<"Release", 'String'>
    readonly category: FieldRef<"Release", 'String'>
    readonly sector: FieldRef<"Release", 'String'>
    readonly tags: FieldRef<"Release", 'String[]'>
    readonly status: FieldRef<"Release", 'ReleaseStatus'>
    readonly firstPublishedAt: FieldRef<"Release", 'DateTime'>
    readonly lastUpdatedAt: FieldRef<"Release", 'DateTime'>
    readonly allowComments: FieldRef<"Release", 'Boolean'>
    readonly createdById: FieldRef<"Release", 'String'>
    readonly createdAt: FieldRef<"Release", 'DateTime'>
    readonly updatedAt: FieldRef<"Release", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * Release findUnique
   */
  export type ReleaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release findUniqueOrThrow
   */
  export type ReleaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release findFirst
   */
  export type ReleaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Releases.
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Releases.
     */
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * Release findFirstOrThrow
   */
  export type ReleaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Release to fetch.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Releases.
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Releases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Releases.
     */
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * Release findMany
   */
  export type ReleaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter, which Releases to fetch.
     */
    where?: ReleaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Releases to fetch.
     */
    orderBy?: ReleaseOrderByWithRelationInput | ReleaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Releases.
     */
    cursor?: ReleaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Releases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Releases.
     */
    skip?: number
    distinct?: ReleaseScalarFieldEnum | ReleaseScalarFieldEnum[]
  }

  /**
   * Release create
   */
  export type ReleaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Release.
     */
    data: XOR<ReleaseCreateInput, ReleaseUncheckedCreateInput>
  }

  /**
   * Release createMany
   */
  export type ReleaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Releases.
     */
    data: ReleaseCreateManyInput | ReleaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Release createManyAndReturn
   */
  export type ReleaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * The data used to create many Releases.
     */
    data: ReleaseCreateManyInput | ReleaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Release update
   */
  export type ReleaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Release.
     */
    data: XOR<ReleaseUpdateInput, ReleaseUncheckedUpdateInput>
    /**
     * Choose, which Release to update.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release updateMany
   */
  export type ReleaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Releases.
     */
    data: XOR<ReleaseUpdateManyMutationInput, ReleaseUncheckedUpdateManyInput>
    /**
     * Filter which Releases to update
     */
    where?: ReleaseWhereInput
    /**
     * Limit how many Releases to update.
     */
    limit?: number
  }

  /**
   * Release updateManyAndReturn
   */
  export type ReleaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * The data used to update Releases.
     */
    data: XOR<ReleaseUpdateManyMutationInput, ReleaseUncheckedUpdateManyInput>
    /**
     * Filter which Releases to update
     */
    where?: ReleaseWhereInput
    /**
     * Limit how many Releases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Release upsert
   */
  export type ReleaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Release to update in case it exists.
     */
    where: ReleaseWhereUniqueInput
    /**
     * In case the Release found by the `where` argument doesn't exist, create a new Release with this data.
     */
    create: XOR<ReleaseCreateInput, ReleaseUncheckedCreateInput>
    /**
     * In case the Release was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReleaseUpdateInput, ReleaseUncheckedUpdateInput>
  }

  /**
   * Release delete
   */
  export type ReleaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
    /**
     * Filter which Release to delete.
     */
    where: ReleaseWhereUniqueInput
  }

  /**
   * Release deleteMany
   */
  export type ReleaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Releases to delete
     */
    where?: ReleaseWhereInput
    /**
     * Limit how many Releases to delete.
     */
    limit?: number
  }

  /**
   * Release.publishedCase
   */
  export type Release$publishedCaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    where?: AssuranceCaseWhereInput
  }

  /**
   * Release.snapshots
   */
  export type Release$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    where?: ReleaseSnapshotWhereInput
    orderBy?: ReleaseSnapshotOrderByWithRelationInput | ReleaseSnapshotOrderByWithRelationInput[]
    cursor?: ReleaseSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReleaseSnapshotScalarFieldEnum | ReleaseSnapshotScalarFieldEnum[]
  }

  /**
   * Release.comments
   */
  export type Release$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    where?: ReleaseCommentWhereInput
    orderBy?: ReleaseCommentOrderByWithRelationInput | ReleaseCommentOrderByWithRelationInput[]
    cursor?: ReleaseCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReleaseCommentScalarFieldEnum | ReleaseCommentScalarFieldEnum[]
  }

  /**
   * Release.image
   */
  export type Release$imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    where?: ReleaseImageWhereInput
  }

  /**
   * Release without action
   */
  export type ReleaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Release
     */
    select?: ReleaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Release
     */
    omit?: ReleaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseInclude<ExtArgs> | null
  }


  /**
   * Model ReleaseSnapshot
   */

  export type AggregateReleaseSnapshot = {
    _count: ReleaseSnapshotCountAggregateOutputType | null
    _avg: ReleaseSnapshotAvgAggregateOutputType | null
    _sum: ReleaseSnapshotSumAggregateOutputType | null
    _min: ReleaseSnapshotMinAggregateOutputType | null
    _max: ReleaseSnapshotMaxAggregateOutputType | null
  }

  export type ReleaseSnapshotAvgAggregateOutputType = {
    versionNumber: number | null
  }

  export type ReleaseSnapshotSumAggregateOutputType = {
    versionNumber: number | null
  }

  export type ReleaseSnapshotMinAggregateOutputType = {
    id: string | null
    releaseId: string | null
    versionNumber: number | null
    versionLabel: string | null
    snapshotTakenAt: Date | null
    snapshotTakenById: string | null
    reason: $Enums.SnapshotReason | null
    createdAt: Date | null
  }

  export type ReleaseSnapshotMaxAggregateOutputType = {
    id: string | null
    releaseId: string | null
    versionNumber: number | null
    versionLabel: string | null
    snapshotTakenAt: Date | null
    snapshotTakenById: string | null
    reason: $Enums.SnapshotReason | null
    createdAt: Date | null
  }

  export type ReleaseSnapshotCountAggregateOutputType = {
    id: number
    releaseId: number
    versionNumber: number
    versionLabel: number
    content: number
    snapshotTakenAt: number
    snapshotTakenById: number
    reason: number
    createdAt: number
    _all: number
  }


  export type ReleaseSnapshotAvgAggregateInputType = {
    versionNumber?: true
  }

  export type ReleaseSnapshotSumAggregateInputType = {
    versionNumber?: true
  }

  export type ReleaseSnapshotMinAggregateInputType = {
    id?: true
    releaseId?: true
    versionNumber?: true
    versionLabel?: true
    snapshotTakenAt?: true
    snapshotTakenById?: true
    reason?: true
    createdAt?: true
  }

  export type ReleaseSnapshotMaxAggregateInputType = {
    id?: true
    releaseId?: true
    versionNumber?: true
    versionLabel?: true
    snapshotTakenAt?: true
    snapshotTakenById?: true
    reason?: true
    createdAt?: true
  }

  export type ReleaseSnapshotCountAggregateInputType = {
    id?: true
    releaseId?: true
    versionNumber?: true
    versionLabel?: true
    content?: true
    snapshotTakenAt?: true
    snapshotTakenById?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type ReleaseSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseSnapshot to aggregate.
     */
    where?: ReleaseSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseSnapshots to fetch.
     */
    orderBy?: ReleaseSnapshotOrderByWithRelationInput | ReleaseSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReleaseSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ReleaseSnapshots
    **/
    _count?: true | ReleaseSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: ReleaseSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: ReleaseSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: ReleaseSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: ReleaseSnapshotMaxAggregateInputType
  }

  export type GetReleaseSnapshotAggregateType<T extends ReleaseSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateReleaseSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReleaseSnapshot[P]>
      : GetScalarType<T[P], AggregateReleaseSnapshot[P]>
  }




  export type ReleaseSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseSnapshotWhereInput
    orderBy?: ReleaseSnapshotOrderByWithAggregationInput | ReleaseSnapshotOrderByWithAggregationInput[]
    by: ReleaseSnapshotScalarFieldEnum[] | ReleaseSnapshotScalarFieldEnum
    having?: ReleaseSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleaseSnapshotCountAggregateInputType | true
    _avg?: ReleaseSnapshotAvgAggregateInputType
    _sum?: ReleaseSnapshotSumAggregateInputType
    _min?: ReleaseSnapshotMinAggregateInputType
    _max?: ReleaseSnapshotMaxAggregateInputType
  }

  export type ReleaseSnapshotGroupByOutputType = {
    id: string
    releaseId: string
    versionNumber: number
    versionLabel: string | null
    content: JsonValue
    snapshotTakenAt: Date
    snapshotTakenById: string
    reason: $Enums.SnapshotReason
    createdAt: Date
    _count: ReleaseSnapshotCountAggregateOutputType | null
    _avg: ReleaseSnapshotAvgAggregateOutputType | null
    _sum: ReleaseSnapshotSumAggregateOutputType | null
    _min: ReleaseSnapshotMinAggregateOutputType | null
    _max: ReleaseSnapshotMaxAggregateOutputType | null
  }

  type GetReleaseSnapshotGroupByPayload<T extends ReleaseSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleaseSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleaseSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleaseSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], ReleaseSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type ReleaseSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    versionNumber?: boolean
    versionLabel?: boolean
    content?: boolean
    snapshotTakenAt?: boolean
    snapshotTakenById?: boolean
    reason?: boolean
    createdAt?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseSnapshot"]>

  export type ReleaseSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    versionNumber?: boolean
    versionLabel?: boolean
    content?: boolean
    snapshotTakenAt?: boolean
    snapshotTakenById?: boolean
    reason?: boolean
    createdAt?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseSnapshot"]>

  export type ReleaseSnapshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    versionNumber?: boolean
    versionLabel?: boolean
    content?: boolean
    snapshotTakenAt?: boolean
    snapshotTakenById?: boolean
    reason?: boolean
    createdAt?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseSnapshot"]>

  export type ReleaseSnapshotSelectScalar = {
    id?: boolean
    releaseId?: boolean
    versionNumber?: boolean
    versionLabel?: boolean
    content?: boolean
    snapshotTakenAt?: boolean
    snapshotTakenById?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type ReleaseSnapshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "releaseId" | "versionNumber" | "versionLabel" | "content" | "snapshotTakenAt" | "snapshotTakenById" | "reason" | "createdAt", ExtArgs["result"]["releaseSnapshot"]>
  export type ReleaseSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }
  export type ReleaseSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }
  export type ReleaseSnapshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }

  export type $ReleaseSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReleaseSnapshot"
    objects: {
      release: Prisma.$ReleasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      releaseId: string
      versionNumber: number
      versionLabel: string | null
      content: Prisma.JsonValue
      snapshotTakenAt: Date
      snapshotTakenById: string
      reason: $Enums.SnapshotReason
      createdAt: Date
    }, ExtArgs["result"]["releaseSnapshot"]>
    composites: {}
  }

  type ReleaseSnapshotGetPayload<S extends boolean | null | undefined | ReleaseSnapshotDefaultArgs> = $Result.GetResult<Prisma.$ReleaseSnapshotPayload, S>

  type ReleaseSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReleaseSnapshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReleaseSnapshotCountAggregateInputType | true
    }

  export interface ReleaseSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReleaseSnapshot'], meta: { name: 'ReleaseSnapshot' } }
    /**
     * Find zero or one ReleaseSnapshot that matches the filter.
     * @param {ReleaseSnapshotFindUniqueArgs} args - Arguments to find a ReleaseSnapshot
     * @example
     * // Get one ReleaseSnapshot
     * const releaseSnapshot = await prisma.releaseSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReleaseSnapshotFindUniqueArgs>(args: SelectSubset<T, ReleaseSnapshotFindUniqueArgs<ExtArgs>>): Prisma__ReleaseSnapshotClient<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReleaseSnapshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReleaseSnapshotFindUniqueOrThrowArgs} args - Arguments to find a ReleaseSnapshot
     * @example
     * // Get one ReleaseSnapshot
     * const releaseSnapshot = await prisma.releaseSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReleaseSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, ReleaseSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReleaseSnapshotClient<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReleaseSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseSnapshotFindFirstArgs} args - Arguments to find a ReleaseSnapshot
     * @example
     * // Get one ReleaseSnapshot
     * const releaseSnapshot = await prisma.releaseSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReleaseSnapshotFindFirstArgs>(args?: SelectSubset<T, ReleaseSnapshotFindFirstArgs<ExtArgs>>): Prisma__ReleaseSnapshotClient<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReleaseSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseSnapshotFindFirstOrThrowArgs} args - Arguments to find a ReleaseSnapshot
     * @example
     * // Get one ReleaseSnapshot
     * const releaseSnapshot = await prisma.releaseSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReleaseSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, ReleaseSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReleaseSnapshotClient<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReleaseSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReleaseSnapshots
     * const releaseSnapshots = await prisma.releaseSnapshot.findMany()
     *
     * // Get first 10 ReleaseSnapshots
     * const releaseSnapshots = await prisma.releaseSnapshot.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const releaseSnapshotWithIdOnly = await prisma.releaseSnapshot.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReleaseSnapshotFindManyArgs>(args?: SelectSubset<T, ReleaseSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReleaseSnapshot.
     * @param {ReleaseSnapshotCreateArgs} args - Arguments to create a ReleaseSnapshot.
     * @example
     * // Create one ReleaseSnapshot
     * const ReleaseSnapshot = await prisma.releaseSnapshot.create({
     *   data: {
     *     // ... data to create a ReleaseSnapshot
     *   }
     * })
     *
     */
    create<T extends ReleaseSnapshotCreateArgs>(args: SelectSubset<T, ReleaseSnapshotCreateArgs<ExtArgs>>): Prisma__ReleaseSnapshotClient<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReleaseSnapshots.
     * @param {ReleaseSnapshotCreateManyArgs} args - Arguments to create many ReleaseSnapshots.
     * @example
     * // Create many ReleaseSnapshots
     * const releaseSnapshot = await prisma.releaseSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReleaseSnapshotCreateManyArgs>(args?: SelectSubset<T, ReleaseSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReleaseSnapshots and returns the data saved in the database.
     * @param {ReleaseSnapshotCreateManyAndReturnArgs} args - Arguments to create many ReleaseSnapshots.
     * @example
     * // Create many ReleaseSnapshots
     * const releaseSnapshot = await prisma.releaseSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ReleaseSnapshots and only return the `id`
     * const releaseSnapshotWithIdOnly = await prisma.releaseSnapshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReleaseSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, ReleaseSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReleaseSnapshot.
     * @param {ReleaseSnapshotDeleteArgs} args - Arguments to delete one ReleaseSnapshot.
     * @example
     * // Delete one ReleaseSnapshot
     * const ReleaseSnapshot = await prisma.releaseSnapshot.delete({
     *   where: {
     *     // ... filter to delete one ReleaseSnapshot
     *   }
     * })
     *
     */
    delete<T extends ReleaseSnapshotDeleteArgs>(args: SelectSubset<T, ReleaseSnapshotDeleteArgs<ExtArgs>>): Prisma__ReleaseSnapshotClient<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReleaseSnapshot.
     * @param {ReleaseSnapshotUpdateArgs} args - Arguments to update one ReleaseSnapshot.
     * @example
     * // Update one ReleaseSnapshot
     * const releaseSnapshot = await prisma.releaseSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReleaseSnapshotUpdateArgs>(args: SelectSubset<T, ReleaseSnapshotUpdateArgs<ExtArgs>>): Prisma__ReleaseSnapshotClient<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReleaseSnapshots.
     * @param {ReleaseSnapshotDeleteManyArgs} args - Arguments to filter ReleaseSnapshots to delete.
     * @example
     * // Delete a few ReleaseSnapshots
     * const { count } = await prisma.releaseSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReleaseSnapshotDeleteManyArgs>(args?: SelectSubset<T, ReleaseSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReleaseSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReleaseSnapshots
     * const releaseSnapshot = await prisma.releaseSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReleaseSnapshotUpdateManyArgs>(args: SelectSubset<T, ReleaseSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReleaseSnapshots and returns the data updated in the database.
     * @param {ReleaseSnapshotUpdateManyAndReturnArgs} args - Arguments to update many ReleaseSnapshots.
     * @example
     * // Update many ReleaseSnapshots
     * const releaseSnapshot = await prisma.releaseSnapshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ReleaseSnapshots and only return the `id`
     * const releaseSnapshotWithIdOnly = await prisma.releaseSnapshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReleaseSnapshotUpdateManyAndReturnArgs>(args: SelectSubset<T, ReleaseSnapshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReleaseSnapshot.
     * @param {ReleaseSnapshotUpsertArgs} args - Arguments to update or create a ReleaseSnapshot.
     * @example
     * // Update or create a ReleaseSnapshot
     * const releaseSnapshot = await prisma.releaseSnapshot.upsert({
     *   create: {
     *     // ... data to create a ReleaseSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReleaseSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends ReleaseSnapshotUpsertArgs>(args: SelectSubset<T, ReleaseSnapshotUpsertArgs<ExtArgs>>): Prisma__ReleaseSnapshotClient<$Result.GetResult<Prisma.$ReleaseSnapshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReleaseSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseSnapshotCountArgs} args - Arguments to filter ReleaseSnapshots to count.
     * @example
     * // Count the number of ReleaseSnapshots
     * const count = await prisma.releaseSnapshot.count({
     *   where: {
     *     // ... the filter for the ReleaseSnapshots we want to count
     *   }
     * })
    **/
    count<T extends ReleaseSnapshotCountArgs>(
      args?: Subset<T, ReleaseSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleaseSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReleaseSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleaseSnapshotAggregateArgs>(args: Subset<T, ReleaseSnapshotAggregateArgs>): Prisma.PrismaPromise<GetReleaseSnapshotAggregateType<T>>

    /**
     * Group by ReleaseSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends ReleaseSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReleaseSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: ReleaseSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReleaseSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReleaseSnapshot model
   */
  readonly fields: ReleaseSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReleaseSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReleaseSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    release<T extends ReleaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReleaseDefaultArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReleaseSnapshot model
   */
  interface ReleaseSnapshotFieldRefs {
    readonly id: FieldRef<"ReleaseSnapshot", 'String'>
    readonly releaseId: FieldRef<"ReleaseSnapshot", 'String'>
    readonly versionNumber: FieldRef<"ReleaseSnapshot", 'Int'>
    readonly versionLabel: FieldRef<"ReleaseSnapshot", 'String'>
    readonly content: FieldRef<"ReleaseSnapshot", 'Json'>
    readonly snapshotTakenAt: FieldRef<"ReleaseSnapshot", 'DateTime'>
    readonly snapshotTakenById: FieldRef<"ReleaseSnapshot", 'String'>
    readonly reason: FieldRef<"ReleaseSnapshot", 'SnapshotReason'>
    readonly createdAt: FieldRef<"ReleaseSnapshot", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * ReleaseSnapshot findUnique
   */
  export type ReleaseSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseSnapshot to fetch.
     */
    where: ReleaseSnapshotWhereUniqueInput
  }

  /**
   * ReleaseSnapshot findUniqueOrThrow
   */
  export type ReleaseSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseSnapshot to fetch.
     */
    where: ReleaseSnapshotWhereUniqueInput
  }

  /**
   * ReleaseSnapshot findFirst
   */
  export type ReleaseSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseSnapshot to fetch.
     */
    where?: ReleaseSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseSnapshots to fetch.
     */
    orderBy?: ReleaseSnapshotOrderByWithRelationInput | ReleaseSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ReleaseSnapshots.
     */
    cursor?: ReleaseSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ReleaseSnapshots.
     */
    distinct?: ReleaseSnapshotScalarFieldEnum | ReleaseSnapshotScalarFieldEnum[]
  }

  /**
   * ReleaseSnapshot findFirstOrThrow
   */
  export type ReleaseSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseSnapshot to fetch.
     */
    where?: ReleaseSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseSnapshots to fetch.
     */
    orderBy?: ReleaseSnapshotOrderByWithRelationInput | ReleaseSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ReleaseSnapshots.
     */
    cursor?: ReleaseSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ReleaseSnapshots.
     */
    distinct?: ReleaseSnapshotScalarFieldEnum | ReleaseSnapshotScalarFieldEnum[]
  }

  /**
   * ReleaseSnapshot findMany
   */
  export type ReleaseSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseSnapshots to fetch.
     */
    where?: ReleaseSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseSnapshots to fetch.
     */
    orderBy?: ReleaseSnapshotOrderByWithRelationInput | ReleaseSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ReleaseSnapshots.
     */
    cursor?: ReleaseSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseSnapshots.
     */
    skip?: number
    distinct?: ReleaseSnapshotScalarFieldEnum | ReleaseSnapshotScalarFieldEnum[]
  }

  /**
   * ReleaseSnapshot create
   */
  export type ReleaseSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a ReleaseSnapshot.
     */
    data: XOR<ReleaseSnapshotCreateInput, ReleaseSnapshotUncheckedCreateInput>
  }

  /**
   * ReleaseSnapshot createMany
   */
  export type ReleaseSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReleaseSnapshots.
     */
    data: ReleaseSnapshotCreateManyInput | ReleaseSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReleaseSnapshot createManyAndReturn
   */
  export type ReleaseSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * The data used to create many ReleaseSnapshots.
     */
    data: ReleaseSnapshotCreateManyInput | ReleaseSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReleaseSnapshot update
   */
  export type ReleaseSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a ReleaseSnapshot.
     */
    data: XOR<ReleaseSnapshotUpdateInput, ReleaseSnapshotUncheckedUpdateInput>
    /**
     * Choose, which ReleaseSnapshot to update.
     */
    where: ReleaseSnapshotWhereUniqueInput
  }

  /**
   * ReleaseSnapshot updateMany
   */
  export type ReleaseSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReleaseSnapshots.
     */
    data: XOR<ReleaseSnapshotUpdateManyMutationInput, ReleaseSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which ReleaseSnapshots to update
     */
    where?: ReleaseSnapshotWhereInput
    /**
     * Limit how many ReleaseSnapshots to update.
     */
    limit?: number
  }

  /**
   * ReleaseSnapshot updateManyAndReturn
   */
  export type ReleaseSnapshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * The data used to update ReleaseSnapshots.
     */
    data: XOR<ReleaseSnapshotUpdateManyMutationInput, ReleaseSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which ReleaseSnapshots to update
     */
    where?: ReleaseSnapshotWhereInput
    /**
     * Limit how many ReleaseSnapshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReleaseSnapshot upsert
   */
  export type ReleaseSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the ReleaseSnapshot to update in case it exists.
     */
    where: ReleaseSnapshotWhereUniqueInput
    /**
     * In case the ReleaseSnapshot found by the `where` argument doesn't exist, create a new ReleaseSnapshot with this data.
     */
    create: XOR<ReleaseSnapshotCreateInput, ReleaseSnapshotUncheckedCreateInput>
    /**
     * In case the ReleaseSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReleaseSnapshotUpdateInput, ReleaseSnapshotUncheckedUpdateInput>
  }

  /**
   * ReleaseSnapshot delete
   */
  export type ReleaseSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
    /**
     * Filter which ReleaseSnapshot to delete.
     */
    where: ReleaseSnapshotWhereUniqueInput
  }

  /**
   * ReleaseSnapshot deleteMany
   */
  export type ReleaseSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseSnapshots to delete
     */
    where?: ReleaseSnapshotWhereInput
    /**
     * Limit how many ReleaseSnapshots to delete.
     */
    limit?: number
  }

  /**
   * ReleaseSnapshot without action
   */
  export type ReleaseSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseSnapshot
     */
    select?: ReleaseSnapshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseSnapshot
     */
    omit?: ReleaseSnapshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model ReleaseComment
   */

  export type AggregateReleaseComment = {
    _count: ReleaseCommentCountAggregateOutputType | null
    _min: ReleaseCommentMinAggregateOutputType | null
    _max: ReleaseCommentMaxAggregateOutputType | null
  }

  export type ReleaseCommentMinAggregateOutputType = {
    id: string | null
    releaseId: string | null
    elementId: string | null
    parentCommentId: string | null
    content: string | null
    authorId: string | null
    status: $Enums.CommentStatus | null
    hiddenById: string | null
    hiddenAt: Date | null
    hiddenReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseCommentMaxAggregateOutputType = {
    id: string | null
    releaseId: string | null
    elementId: string | null
    parentCommentId: string | null
    content: string | null
    authorId: string | null
    status: $Enums.CommentStatus | null
    hiddenById: string | null
    hiddenAt: Date | null
    hiddenReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReleaseCommentCountAggregateOutputType = {
    id: number
    releaseId: number
    elementId: number
    parentCommentId: number
    content: number
    authorId: number
    status: number
    hiddenById: number
    hiddenAt: number
    hiddenReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReleaseCommentMinAggregateInputType = {
    id?: true
    releaseId?: true
    elementId?: true
    parentCommentId?: true
    content?: true
    authorId?: true
    status?: true
    hiddenById?: true
    hiddenAt?: true
    hiddenReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseCommentMaxAggregateInputType = {
    id?: true
    releaseId?: true
    elementId?: true
    parentCommentId?: true
    content?: true
    authorId?: true
    status?: true
    hiddenById?: true
    hiddenAt?: true
    hiddenReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReleaseCommentCountAggregateInputType = {
    id?: true
    releaseId?: true
    elementId?: true
    parentCommentId?: true
    content?: true
    authorId?: true
    status?: true
    hiddenById?: true
    hiddenAt?: true
    hiddenReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReleaseCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseComment to aggregate.
     */
    where?: ReleaseCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseComments to fetch.
     */
    orderBy?: ReleaseCommentOrderByWithRelationInput | ReleaseCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReleaseCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ReleaseComments
    **/
    _count?: true | ReleaseCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: ReleaseCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: ReleaseCommentMaxAggregateInputType
  }

  export type GetReleaseCommentAggregateType<T extends ReleaseCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateReleaseComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReleaseComment[P]>
      : GetScalarType<T[P], AggregateReleaseComment[P]>
  }




  export type ReleaseCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseCommentWhereInput
    orderBy?: ReleaseCommentOrderByWithAggregationInput | ReleaseCommentOrderByWithAggregationInput[]
    by: ReleaseCommentScalarFieldEnum[] | ReleaseCommentScalarFieldEnum
    having?: ReleaseCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleaseCommentCountAggregateInputType | true
    _min?: ReleaseCommentMinAggregateInputType
    _max?: ReleaseCommentMaxAggregateInputType
  }

  export type ReleaseCommentGroupByOutputType = {
    id: string
    releaseId: string
    elementId: string | null
    parentCommentId: string | null
    content: string
    authorId: string
    status: $Enums.CommentStatus
    hiddenById: string | null
    hiddenAt: Date | null
    hiddenReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReleaseCommentCountAggregateOutputType | null
    _min: ReleaseCommentMinAggregateOutputType | null
    _max: ReleaseCommentMaxAggregateOutputType | null
  }

  type GetReleaseCommentGroupByPayload<T extends ReleaseCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleaseCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleaseCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleaseCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ReleaseCommentGroupByOutputType[P]>
        }
      >
    >


  export type ReleaseCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    elementId?: boolean
    parentCommentId?: boolean
    content?: boolean
    authorId?: boolean
    status?: boolean
    hiddenById?: boolean
    hiddenAt?: boolean
    hiddenReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
    element?: boolean | ReleaseComment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ReleaseComment$parentCommentArgs<ExtArgs>
    replies?: boolean | ReleaseComment$repliesArgs<ExtArgs>
    _count?: boolean | ReleaseCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseComment"]>

  export type ReleaseCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    elementId?: boolean
    parentCommentId?: boolean
    content?: boolean
    authorId?: boolean
    status?: boolean
    hiddenById?: boolean
    hiddenAt?: boolean
    hiddenReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
    element?: boolean | ReleaseComment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ReleaseComment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["releaseComment"]>

  export type ReleaseCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    elementId?: boolean
    parentCommentId?: boolean
    content?: boolean
    authorId?: boolean
    status?: boolean
    hiddenById?: boolean
    hiddenAt?: boolean
    hiddenReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
    element?: boolean | ReleaseComment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ReleaseComment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["releaseComment"]>

  export type ReleaseCommentSelectScalar = {
    id?: boolean
    releaseId?: boolean
    elementId?: boolean
    parentCommentId?: boolean
    content?: boolean
    authorId?: boolean
    status?: boolean
    hiddenById?: boolean
    hiddenAt?: boolean
    hiddenReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReleaseCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "releaseId" | "elementId" | "parentCommentId" | "content" | "authorId" | "status" | "hiddenById" | "hiddenAt" | "hiddenReason" | "createdAt" | "updatedAt", ExtArgs["result"]["releaseComment"]>
  export type ReleaseCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
    element?: boolean | ReleaseComment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ReleaseComment$parentCommentArgs<ExtArgs>
    replies?: boolean | ReleaseComment$repliesArgs<ExtArgs>
    _count?: boolean | ReleaseCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReleaseCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
    element?: boolean | ReleaseComment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ReleaseComment$parentCommentArgs<ExtArgs>
  }
  export type ReleaseCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
    element?: boolean | ReleaseComment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ReleaseComment$parentCommentArgs<ExtArgs>
  }

  export type $ReleaseCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReleaseComment"
    objects: {
      release: Prisma.$ReleasePayload<ExtArgs>
      element: Prisma.$AssuranceElementPayload<ExtArgs> | null
      author: Prisma.$UserPayload<ExtArgs>
      parentComment: Prisma.$ReleaseCommentPayload<ExtArgs> | null
      replies: Prisma.$ReleaseCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      releaseId: string
      elementId: string | null
      parentCommentId: string | null
      content: string
      authorId: string
      status: $Enums.CommentStatus
      hiddenById: string | null
      hiddenAt: Date | null
      hiddenReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["releaseComment"]>
    composites: {}
  }

  type ReleaseCommentGetPayload<S extends boolean | null | undefined | ReleaseCommentDefaultArgs> = $Result.GetResult<Prisma.$ReleaseCommentPayload, S>

  type ReleaseCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReleaseCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReleaseCommentCountAggregateInputType | true
    }

  export interface ReleaseCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReleaseComment'], meta: { name: 'ReleaseComment' } }
    /**
     * Find zero or one ReleaseComment that matches the filter.
     * @param {ReleaseCommentFindUniqueArgs} args - Arguments to find a ReleaseComment
     * @example
     * // Get one ReleaseComment
     * const releaseComment = await prisma.releaseComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReleaseCommentFindUniqueArgs>(args: SelectSubset<T, ReleaseCommentFindUniqueArgs<ExtArgs>>): Prisma__ReleaseCommentClient<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReleaseComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReleaseCommentFindUniqueOrThrowArgs} args - Arguments to find a ReleaseComment
     * @example
     * // Get one ReleaseComment
     * const releaseComment = await prisma.releaseComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReleaseCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ReleaseCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReleaseCommentClient<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReleaseComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCommentFindFirstArgs} args - Arguments to find a ReleaseComment
     * @example
     * // Get one ReleaseComment
     * const releaseComment = await prisma.releaseComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReleaseCommentFindFirstArgs>(args?: SelectSubset<T, ReleaseCommentFindFirstArgs<ExtArgs>>): Prisma__ReleaseCommentClient<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReleaseComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCommentFindFirstOrThrowArgs} args - Arguments to find a ReleaseComment
     * @example
     * // Get one ReleaseComment
     * const releaseComment = await prisma.releaseComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReleaseCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ReleaseCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReleaseCommentClient<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReleaseComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReleaseComments
     * const releaseComments = await prisma.releaseComment.findMany()
     *
     * // Get first 10 ReleaseComments
     * const releaseComments = await prisma.releaseComment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const releaseCommentWithIdOnly = await prisma.releaseComment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReleaseCommentFindManyArgs>(args?: SelectSubset<T, ReleaseCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReleaseComment.
     * @param {ReleaseCommentCreateArgs} args - Arguments to create a ReleaseComment.
     * @example
     * // Create one ReleaseComment
     * const ReleaseComment = await prisma.releaseComment.create({
     *   data: {
     *     // ... data to create a ReleaseComment
     *   }
     * })
     *
     */
    create<T extends ReleaseCommentCreateArgs>(args: SelectSubset<T, ReleaseCommentCreateArgs<ExtArgs>>): Prisma__ReleaseCommentClient<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReleaseComments.
     * @param {ReleaseCommentCreateManyArgs} args - Arguments to create many ReleaseComments.
     * @example
     * // Create many ReleaseComments
     * const releaseComment = await prisma.releaseComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReleaseCommentCreateManyArgs>(args?: SelectSubset<T, ReleaseCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReleaseComments and returns the data saved in the database.
     * @param {ReleaseCommentCreateManyAndReturnArgs} args - Arguments to create many ReleaseComments.
     * @example
     * // Create many ReleaseComments
     * const releaseComment = await prisma.releaseComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ReleaseComments and only return the `id`
     * const releaseCommentWithIdOnly = await prisma.releaseComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReleaseCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ReleaseCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReleaseComment.
     * @param {ReleaseCommentDeleteArgs} args - Arguments to delete one ReleaseComment.
     * @example
     * // Delete one ReleaseComment
     * const ReleaseComment = await prisma.releaseComment.delete({
     *   where: {
     *     // ... filter to delete one ReleaseComment
     *   }
     * })
     *
     */
    delete<T extends ReleaseCommentDeleteArgs>(args: SelectSubset<T, ReleaseCommentDeleteArgs<ExtArgs>>): Prisma__ReleaseCommentClient<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReleaseComment.
     * @param {ReleaseCommentUpdateArgs} args - Arguments to update one ReleaseComment.
     * @example
     * // Update one ReleaseComment
     * const releaseComment = await prisma.releaseComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReleaseCommentUpdateArgs>(args: SelectSubset<T, ReleaseCommentUpdateArgs<ExtArgs>>): Prisma__ReleaseCommentClient<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReleaseComments.
     * @param {ReleaseCommentDeleteManyArgs} args - Arguments to filter ReleaseComments to delete.
     * @example
     * // Delete a few ReleaseComments
     * const { count } = await prisma.releaseComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReleaseCommentDeleteManyArgs>(args?: SelectSubset<T, ReleaseCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReleaseComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReleaseComments
     * const releaseComment = await prisma.releaseComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReleaseCommentUpdateManyArgs>(args: SelectSubset<T, ReleaseCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReleaseComments and returns the data updated in the database.
     * @param {ReleaseCommentUpdateManyAndReturnArgs} args - Arguments to update many ReleaseComments.
     * @example
     * // Update many ReleaseComments
     * const releaseComment = await prisma.releaseComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ReleaseComments and only return the `id`
     * const releaseCommentWithIdOnly = await prisma.releaseComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReleaseCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, ReleaseCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReleaseComment.
     * @param {ReleaseCommentUpsertArgs} args - Arguments to update or create a ReleaseComment.
     * @example
     * // Update or create a ReleaseComment
     * const releaseComment = await prisma.releaseComment.upsert({
     *   create: {
     *     // ... data to create a ReleaseComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReleaseComment we want to update
     *   }
     * })
     */
    upsert<T extends ReleaseCommentUpsertArgs>(args: SelectSubset<T, ReleaseCommentUpsertArgs<ExtArgs>>): Prisma__ReleaseCommentClient<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReleaseComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCommentCountArgs} args - Arguments to filter ReleaseComments to count.
     * @example
     * // Count the number of ReleaseComments
     * const count = await prisma.releaseComment.count({
     *   where: {
     *     // ... the filter for the ReleaseComments we want to count
     *   }
     * })
    **/
    count<T extends ReleaseCommentCountArgs>(
      args?: Subset<T, ReleaseCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleaseCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReleaseComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleaseCommentAggregateArgs>(args: Subset<T, ReleaseCommentAggregateArgs>): Prisma.PrismaPromise<GetReleaseCommentAggregateType<T>>

    /**
     * Group by ReleaseComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends ReleaseCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReleaseCommentGroupByArgs['orderBy'] }
        : { orderBy?: ReleaseCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReleaseCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReleaseComment model
   */
  readonly fields: ReleaseCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReleaseComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReleaseCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    release<T extends ReleaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReleaseDefaultArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    element<T extends ReleaseComment$elementArgs<ExtArgs> = {}>(args?: Subset<T, ReleaseComment$elementArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentComment<T extends ReleaseComment$parentCommentArgs<ExtArgs> = {}>(args?: Subset<T, ReleaseComment$parentCommentArgs<ExtArgs>>): Prisma__ReleaseCommentClient<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends ReleaseComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, ReleaseComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReleaseComment model
   */
  interface ReleaseCommentFieldRefs {
    readonly id: FieldRef<"ReleaseComment", 'String'>
    readonly releaseId: FieldRef<"ReleaseComment", 'String'>
    readonly elementId: FieldRef<"ReleaseComment", 'String'>
    readonly parentCommentId: FieldRef<"ReleaseComment", 'String'>
    readonly content: FieldRef<"ReleaseComment", 'String'>
    readonly authorId: FieldRef<"ReleaseComment", 'String'>
    readonly status: FieldRef<"ReleaseComment", 'CommentStatus'>
    readonly hiddenById: FieldRef<"ReleaseComment", 'String'>
    readonly hiddenAt: FieldRef<"ReleaseComment", 'DateTime'>
    readonly hiddenReason: FieldRef<"ReleaseComment", 'String'>
    readonly createdAt: FieldRef<"ReleaseComment", 'DateTime'>
    readonly updatedAt: FieldRef<"ReleaseComment", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * ReleaseComment findUnique
   */
  export type ReleaseCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseComment to fetch.
     */
    where: ReleaseCommentWhereUniqueInput
  }

  /**
   * ReleaseComment findUniqueOrThrow
   */
  export type ReleaseCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseComment to fetch.
     */
    where: ReleaseCommentWhereUniqueInput
  }

  /**
   * ReleaseComment findFirst
   */
  export type ReleaseCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseComment to fetch.
     */
    where?: ReleaseCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseComments to fetch.
     */
    orderBy?: ReleaseCommentOrderByWithRelationInput | ReleaseCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ReleaseComments.
     */
    cursor?: ReleaseCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ReleaseComments.
     */
    distinct?: ReleaseCommentScalarFieldEnum | ReleaseCommentScalarFieldEnum[]
  }

  /**
   * ReleaseComment findFirstOrThrow
   */
  export type ReleaseCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseComment to fetch.
     */
    where?: ReleaseCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseComments to fetch.
     */
    orderBy?: ReleaseCommentOrderByWithRelationInput | ReleaseCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ReleaseComments.
     */
    cursor?: ReleaseCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ReleaseComments.
     */
    distinct?: ReleaseCommentScalarFieldEnum | ReleaseCommentScalarFieldEnum[]
  }

  /**
   * ReleaseComment findMany
   */
  export type ReleaseCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseComments to fetch.
     */
    where?: ReleaseCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseComments to fetch.
     */
    orderBy?: ReleaseCommentOrderByWithRelationInput | ReleaseCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ReleaseComments.
     */
    cursor?: ReleaseCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseComments.
     */
    skip?: number
    distinct?: ReleaseCommentScalarFieldEnum | ReleaseCommentScalarFieldEnum[]
  }

  /**
   * ReleaseComment create
   */
  export type ReleaseCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ReleaseComment.
     */
    data: XOR<ReleaseCommentCreateInput, ReleaseCommentUncheckedCreateInput>
  }

  /**
   * ReleaseComment createMany
   */
  export type ReleaseCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReleaseComments.
     */
    data: ReleaseCommentCreateManyInput | ReleaseCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReleaseComment createManyAndReturn
   */
  export type ReleaseCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * The data used to create many ReleaseComments.
     */
    data: ReleaseCommentCreateManyInput | ReleaseCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReleaseComment update
   */
  export type ReleaseCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ReleaseComment.
     */
    data: XOR<ReleaseCommentUpdateInput, ReleaseCommentUncheckedUpdateInput>
    /**
     * Choose, which ReleaseComment to update.
     */
    where: ReleaseCommentWhereUniqueInput
  }

  /**
   * ReleaseComment updateMany
   */
  export type ReleaseCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReleaseComments.
     */
    data: XOR<ReleaseCommentUpdateManyMutationInput, ReleaseCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReleaseComments to update
     */
    where?: ReleaseCommentWhereInput
    /**
     * Limit how many ReleaseComments to update.
     */
    limit?: number
  }

  /**
   * ReleaseComment updateManyAndReturn
   */
  export type ReleaseCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * The data used to update ReleaseComments.
     */
    data: XOR<ReleaseCommentUpdateManyMutationInput, ReleaseCommentUncheckedUpdateManyInput>
    /**
     * Filter which ReleaseComments to update
     */
    where?: ReleaseCommentWhereInput
    /**
     * Limit how many ReleaseComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReleaseComment upsert
   */
  export type ReleaseCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ReleaseComment to update in case it exists.
     */
    where: ReleaseCommentWhereUniqueInput
    /**
     * In case the ReleaseComment found by the `where` argument doesn't exist, create a new ReleaseComment with this data.
     */
    create: XOR<ReleaseCommentCreateInput, ReleaseCommentUncheckedCreateInput>
    /**
     * In case the ReleaseComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReleaseCommentUpdateInput, ReleaseCommentUncheckedUpdateInput>
  }

  /**
   * ReleaseComment delete
   */
  export type ReleaseCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    /**
     * Filter which ReleaseComment to delete.
     */
    where: ReleaseCommentWhereUniqueInput
  }

  /**
   * ReleaseComment deleteMany
   */
  export type ReleaseCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseComments to delete
     */
    where?: ReleaseCommentWhereInput
    /**
     * Limit how many ReleaseComments to delete.
     */
    limit?: number
  }

  /**
   * ReleaseComment.element
   */
  export type ReleaseComment$elementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    where?: AssuranceElementWhereInput
  }

  /**
   * ReleaseComment.parentComment
   */
  export type ReleaseComment$parentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    where?: ReleaseCommentWhereInput
  }

  /**
   * ReleaseComment.replies
   */
  export type ReleaseComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
    where?: ReleaseCommentWhereInput
    orderBy?: ReleaseCommentOrderByWithRelationInput | ReleaseCommentOrderByWithRelationInput[]
    cursor?: ReleaseCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReleaseCommentScalarFieldEnum | ReleaseCommentScalarFieldEnum[]
  }

  /**
   * ReleaseComment without action
   */
  export type ReleaseCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseComment
     */
    select?: ReleaseCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseComment
     */
    omit?: ReleaseCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseCommentInclude<ExtArgs> | null
  }


  /**
   * Model ReleaseImage
   */

  export type AggregateReleaseImage = {
    _count: ReleaseImageCountAggregateOutputType | null
    _min: ReleaseImageMinAggregateOutputType | null
    _max: ReleaseImageMaxAggregateOutputType | null
  }

  export type ReleaseImageMinAggregateOutputType = {
    id: string | null
    releaseId: string | null
    imageUrl: string | null
    altText: string | null
    uploadedAt: Date | null
    uploadedById: string | null
  }

  export type ReleaseImageMaxAggregateOutputType = {
    id: string | null
    releaseId: string | null
    imageUrl: string | null
    altText: string | null
    uploadedAt: Date | null
    uploadedById: string | null
  }

  export type ReleaseImageCountAggregateOutputType = {
    id: number
    releaseId: number
    imageUrl: number
    altText: number
    uploadedAt: number
    uploadedById: number
    _all: number
  }


  export type ReleaseImageMinAggregateInputType = {
    id?: true
    releaseId?: true
    imageUrl?: true
    altText?: true
    uploadedAt?: true
    uploadedById?: true
  }

  export type ReleaseImageMaxAggregateInputType = {
    id?: true
    releaseId?: true
    imageUrl?: true
    altText?: true
    uploadedAt?: true
    uploadedById?: true
  }

  export type ReleaseImageCountAggregateInputType = {
    id?: true
    releaseId?: true
    imageUrl?: true
    altText?: true
    uploadedAt?: true
    uploadedById?: true
    _all?: true
  }

  export type ReleaseImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseImage to aggregate.
     */
    where?: ReleaseImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseImages to fetch.
     */
    orderBy?: ReleaseImageOrderByWithRelationInput | ReleaseImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ReleaseImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ReleaseImages
    **/
    _count?: true | ReleaseImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: ReleaseImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: ReleaseImageMaxAggregateInputType
  }

  export type GetReleaseImageAggregateType<T extends ReleaseImageAggregateArgs> = {
        [P in keyof T & keyof AggregateReleaseImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReleaseImage[P]>
      : GetScalarType<T[P], AggregateReleaseImage[P]>
  }




  export type ReleaseImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReleaseImageWhereInput
    orderBy?: ReleaseImageOrderByWithAggregationInput | ReleaseImageOrderByWithAggregationInput[]
    by: ReleaseImageScalarFieldEnum[] | ReleaseImageScalarFieldEnum
    having?: ReleaseImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReleaseImageCountAggregateInputType | true
    _min?: ReleaseImageMinAggregateInputType
    _max?: ReleaseImageMaxAggregateInputType
  }

  export type ReleaseImageGroupByOutputType = {
    id: string
    releaseId: string
    imageUrl: string
    altText: string | null
    uploadedAt: Date
    uploadedById: string
    _count: ReleaseImageCountAggregateOutputType | null
    _min: ReleaseImageMinAggregateOutputType | null
    _max: ReleaseImageMaxAggregateOutputType | null
  }

  type GetReleaseImageGroupByPayload<T extends ReleaseImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReleaseImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReleaseImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReleaseImageGroupByOutputType[P]>
            : GetScalarType<T[P], ReleaseImageGroupByOutputType[P]>
        }
      >
    >


  export type ReleaseImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    imageUrl?: boolean
    altText?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseImage"]>

  export type ReleaseImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    imageUrl?: boolean
    altText?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseImage"]>

  export type ReleaseImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    releaseId?: boolean
    imageUrl?: boolean
    altText?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["releaseImage"]>

  export type ReleaseImageSelectScalar = {
    id?: boolean
    releaseId?: boolean
    imageUrl?: boolean
    altText?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
  }

  export type ReleaseImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "releaseId" | "imageUrl" | "altText" | "uploadedAt" | "uploadedById", ExtArgs["result"]["releaseImage"]>
  export type ReleaseImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }
  export type ReleaseImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }
  export type ReleaseImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    release?: boolean | ReleaseDefaultArgs<ExtArgs>
  }

  export type $ReleaseImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReleaseImage"
    objects: {
      release: Prisma.$ReleasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      releaseId: string
      imageUrl: string
      altText: string | null
      uploadedAt: Date
      uploadedById: string
    }, ExtArgs["result"]["releaseImage"]>
    composites: {}
  }

  type ReleaseImageGetPayload<S extends boolean | null | undefined | ReleaseImageDefaultArgs> = $Result.GetResult<Prisma.$ReleaseImagePayload, S>

  type ReleaseImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReleaseImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReleaseImageCountAggregateInputType | true
    }

  export interface ReleaseImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReleaseImage'], meta: { name: 'ReleaseImage' } }
    /**
     * Find zero or one ReleaseImage that matches the filter.
     * @param {ReleaseImageFindUniqueArgs} args - Arguments to find a ReleaseImage
     * @example
     * // Get one ReleaseImage
     * const releaseImage = await prisma.releaseImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReleaseImageFindUniqueArgs>(args: SelectSubset<T, ReleaseImageFindUniqueArgs<ExtArgs>>): Prisma__ReleaseImageClient<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReleaseImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReleaseImageFindUniqueOrThrowArgs} args - Arguments to find a ReleaseImage
     * @example
     * // Get one ReleaseImage
     * const releaseImage = await prisma.releaseImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReleaseImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ReleaseImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReleaseImageClient<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReleaseImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseImageFindFirstArgs} args - Arguments to find a ReleaseImage
     * @example
     * // Get one ReleaseImage
     * const releaseImage = await prisma.releaseImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReleaseImageFindFirstArgs>(args?: SelectSubset<T, ReleaseImageFindFirstArgs<ExtArgs>>): Prisma__ReleaseImageClient<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReleaseImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseImageFindFirstOrThrowArgs} args - Arguments to find a ReleaseImage
     * @example
     * // Get one ReleaseImage
     * const releaseImage = await prisma.releaseImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReleaseImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ReleaseImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReleaseImageClient<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReleaseImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReleaseImages
     * const releaseImages = await prisma.releaseImage.findMany()
     *
     * // Get first 10 ReleaseImages
     * const releaseImages = await prisma.releaseImage.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const releaseImageWithIdOnly = await prisma.releaseImage.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ReleaseImageFindManyArgs>(args?: SelectSubset<T, ReleaseImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReleaseImage.
     * @param {ReleaseImageCreateArgs} args - Arguments to create a ReleaseImage.
     * @example
     * // Create one ReleaseImage
     * const ReleaseImage = await prisma.releaseImage.create({
     *   data: {
     *     // ... data to create a ReleaseImage
     *   }
     * })
     *
     */
    create<T extends ReleaseImageCreateArgs>(args: SelectSubset<T, ReleaseImageCreateArgs<ExtArgs>>): Prisma__ReleaseImageClient<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReleaseImages.
     * @param {ReleaseImageCreateManyArgs} args - Arguments to create many ReleaseImages.
     * @example
     * // Create many ReleaseImages
     * const releaseImage = await prisma.releaseImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ReleaseImageCreateManyArgs>(args?: SelectSubset<T, ReleaseImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReleaseImages and returns the data saved in the database.
     * @param {ReleaseImageCreateManyAndReturnArgs} args - Arguments to create many ReleaseImages.
     * @example
     * // Create many ReleaseImages
     * const releaseImage = await prisma.releaseImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many ReleaseImages and only return the `id`
     * const releaseImageWithIdOnly = await prisma.releaseImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends ReleaseImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ReleaseImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReleaseImage.
     * @param {ReleaseImageDeleteArgs} args - Arguments to delete one ReleaseImage.
     * @example
     * // Delete one ReleaseImage
     * const ReleaseImage = await prisma.releaseImage.delete({
     *   where: {
     *     // ... filter to delete one ReleaseImage
     *   }
     * })
     *
     */
    delete<T extends ReleaseImageDeleteArgs>(args: SelectSubset<T, ReleaseImageDeleteArgs<ExtArgs>>): Prisma__ReleaseImageClient<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReleaseImage.
     * @param {ReleaseImageUpdateArgs} args - Arguments to update one ReleaseImage.
     * @example
     * // Update one ReleaseImage
     * const releaseImage = await prisma.releaseImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ReleaseImageUpdateArgs>(args: SelectSubset<T, ReleaseImageUpdateArgs<ExtArgs>>): Prisma__ReleaseImageClient<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReleaseImages.
     * @param {ReleaseImageDeleteManyArgs} args - Arguments to filter ReleaseImages to delete.
     * @example
     * // Delete a few ReleaseImages
     * const { count } = await prisma.releaseImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ReleaseImageDeleteManyArgs>(args?: SelectSubset<T, ReleaseImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReleaseImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReleaseImages
     * const releaseImage = await prisma.releaseImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ReleaseImageUpdateManyArgs>(args: SelectSubset<T, ReleaseImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReleaseImages and returns the data updated in the database.
     * @param {ReleaseImageUpdateManyAndReturnArgs} args - Arguments to update many ReleaseImages.
     * @example
     * // Update many ReleaseImages
     * const releaseImage = await prisma.releaseImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more ReleaseImages and only return the `id`
     * const releaseImageWithIdOnly = await prisma.releaseImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends ReleaseImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ReleaseImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReleaseImage.
     * @param {ReleaseImageUpsertArgs} args - Arguments to update or create a ReleaseImage.
     * @example
     * // Update or create a ReleaseImage
     * const releaseImage = await prisma.releaseImage.upsert({
     *   create: {
     *     // ... data to create a ReleaseImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReleaseImage we want to update
     *   }
     * })
     */
    upsert<T extends ReleaseImageUpsertArgs>(args: SelectSubset<T, ReleaseImageUpsertArgs<ExtArgs>>): Prisma__ReleaseImageClient<$Result.GetResult<Prisma.$ReleaseImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReleaseImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseImageCountArgs} args - Arguments to filter ReleaseImages to count.
     * @example
     * // Count the number of ReleaseImages
     * const count = await prisma.releaseImage.count({
     *   where: {
     *     // ... the filter for the ReleaseImages we want to count
     *   }
     * })
    **/
    count<T extends ReleaseImageCountArgs>(
      args?: Subset<T, ReleaseImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReleaseImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReleaseImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReleaseImageAggregateArgs>(args: Subset<T, ReleaseImageAggregateArgs>): Prisma.PrismaPromise<GetReleaseImageAggregateType<T>>

    /**
     * Group by ReleaseImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReleaseImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends ReleaseImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReleaseImageGroupByArgs['orderBy'] }
        : { orderBy?: ReleaseImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReleaseImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReleaseImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReleaseImage model
   */
  readonly fields: ReleaseImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReleaseImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReleaseImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    release<T extends ReleaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReleaseDefaultArgs<ExtArgs>>): Prisma__ReleaseClient<$Result.GetResult<Prisma.$ReleasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReleaseImage model
   */
  interface ReleaseImageFieldRefs {
    readonly id: FieldRef<"ReleaseImage", 'String'>
    readonly releaseId: FieldRef<"ReleaseImage", 'String'>
    readonly imageUrl: FieldRef<"ReleaseImage", 'String'>
    readonly altText: FieldRef<"ReleaseImage", 'String'>
    readonly uploadedAt: FieldRef<"ReleaseImage", 'DateTime'>
    readonly uploadedById: FieldRef<"ReleaseImage", 'String'>
  }


  // Custom InputTypes
  /**
   * ReleaseImage findUnique
   */
  export type ReleaseImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseImage to fetch.
     */
    where: ReleaseImageWhereUniqueInput
  }

  /**
   * ReleaseImage findUniqueOrThrow
   */
  export type ReleaseImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseImage to fetch.
     */
    where: ReleaseImageWhereUniqueInput
  }

  /**
   * ReleaseImage findFirst
   */
  export type ReleaseImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseImage to fetch.
     */
    where?: ReleaseImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseImages to fetch.
     */
    orderBy?: ReleaseImageOrderByWithRelationInput | ReleaseImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ReleaseImages.
     */
    cursor?: ReleaseImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ReleaseImages.
     */
    distinct?: ReleaseImageScalarFieldEnum | ReleaseImageScalarFieldEnum[]
  }

  /**
   * ReleaseImage findFirstOrThrow
   */
  export type ReleaseImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseImage to fetch.
     */
    where?: ReleaseImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseImages to fetch.
     */
    orderBy?: ReleaseImageOrderByWithRelationInput | ReleaseImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ReleaseImages.
     */
    cursor?: ReleaseImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ReleaseImages.
     */
    distinct?: ReleaseImageScalarFieldEnum | ReleaseImageScalarFieldEnum[]
  }

  /**
   * ReleaseImage findMany
   */
  export type ReleaseImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    /**
     * Filter, which ReleaseImages to fetch.
     */
    where?: ReleaseImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ReleaseImages to fetch.
     */
    orderBy?: ReleaseImageOrderByWithRelationInput | ReleaseImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ReleaseImages.
     */
    cursor?: ReleaseImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ReleaseImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ReleaseImages.
     */
    skip?: number
    distinct?: ReleaseImageScalarFieldEnum | ReleaseImageScalarFieldEnum[]
  }

  /**
   * ReleaseImage create
   */
  export type ReleaseImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ReleaseImage.
     */
    data: XOR<ReleaseImageCreateInput, ReleaseImageUncheckedCreateInput>
  }

  /**
   * ReleaseImage createMany
   */
  export type ReleaseImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReleaseImages.
     */
    data: ReleaseImageCreateManyInput | ReleaseImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReleaseImage createManyAndReturn
   */
  export type ReleaseImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * The data used to create many ReleaseImages.
     */
    data: ReleaseImageCreateManyInput | ReleaseImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReleaseImage update
   */
  export type ReleaseImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ReleaseImage.
     */
    data: XOR<ReleaseImageUpdateInput, ReleaseImageUncheckedUpdateInput>
    /**
     * Choose, which ReleaseImage to update.
     */
    where: ReleaseImageWhereUniqueInput
  }

  /**
   * ReleaseImage updateMany
   */
  export type ReleaseImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReleaseImages.
     */
    data: XOR<ReleaseImageUpdateManyMutationInput, ReleaseImageUncheckedUpdateManyInput>
    /**
     * Filter which ReleaseImages to update
     */
    where?: ReleaseImageWhereInput
    /**
     * Limit how many ReleaseImages to update.
     */
    limit?: number
  }

  /**
   * ReleaseImage updateManyAndReturn
   */
  export type ReleaseImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * The data used to update ReleaseImages.
     */
    data: XOR<ReleaseImageUpdateManyMutationInput, ReleaseImageUncheckedUpdateManyInput>
    /**
     * Filter which ReleaseImages to update
     */
    where?: ReleaseImageWhereInput
    /**
     * Limit how many ReleaseImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReleaseImage upsert
   */
  export type ReleaseImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ReleaseImage to update in case it exists.
     */
    where: ReleaseImageWhereUniqueInput
    /**
     * In case the ReleaseImage found by the `where` argument doesn't exist, create a new ReleaseImage with this data.
     */
    create: XOR<ReleaseImageCreateInput, ReleaseImageUncheckedCreateInput>
    /**
     * In case the ReleaseImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReleaseImageUpdateInput, ReleaseImageUncheckedUpdateInput>
  }

  /**
   * ReleaseImage delete
   */
  export type ReleaseImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
    /**
     * Filter which ReleaseImage to delete.
     */
    where: ReleaseImageWhereUniqueInput
  }

  /**
   * ReleaseImage deleteMany
   */
  export type ReleaseImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReleaseImages to delete
     */
    where?: ReleaseImageWhereInput
    /**
     * Limit how many ReleaseImages to delete.
     */
    limit?: number
  }

  /**
   * ReleaseImage without action
   */
  export type ReleaseImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReleaseImage
     */
    select?: ReleaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReleaseImage
     */
    omit?: ReleaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReleaseImageInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    elementId: string | null
    parentCommentId: string | null
    content: string | null
    authorId: string | null
    resolved: boolean | null
    resolvedById: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    elementId: string | null
    parentCommentId: string | null
    content: string | null
    authorId: string | null
    resolved: boolean | null
    resolvedById: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    caseId: number
    elementId: number
    parentCommentId: number
    content: number
    authorId: number
    resolved: number
    resolvedById: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    caseId?: true
    elementId?: true
    parentCommentId?: true
    content?: true
    authorId?: true
    resolved?: true
    resolvedById?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    caseId?: true
    elementId?: true
    parentCommentId?: true
    content?: true
    authorId?: true
    resolved?: true
    resolvedById?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    caseId?: true
    elementId?: true
    parentCommentId?: true
    content?: true
    authorId?: true
    resolved?: true
    resolvedById?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    caseId: string | null
    elementId: string | null
    parentCommentId: string | null
    content: string
    authorId: string
    resolved: boolean
    resolvedById: string | null
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    elementId?: boolean
    parentCommentId?: boolean
    content?: boolean
    authorId?: boolean
    resolved?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    case?: boolean | Comment$caseArgs<ExtArgs>
    element?: boolean | Comment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Comment$resolvedByArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    elementId?: boolean
    parentCommentId?: boolean
    content?: boolean
    authorId?: boolean
    resolved?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    case?: boolean | Comment$caseArgs<ExtArgs>
    element?: boolean | Comment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Comment$resolvedByArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    elementId?: boolean
    parentCommentId?: boolean
    content?: boolean
    authorId?: boolean
    resolved?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    case?: boolean | Comment$caseArgs<ExtArgs>
    element?: boolean | Comment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Comment$resolvedByArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    caseId?: boolean
    elementId?: boolean
    parentCommentId?: boolean
    content?: boolean
    authorId?: boolean
    resolved?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "elementId" | "parentCommentId" | "content" | "authorId" | "resolved" | "resolvedById" | "resolvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | Comment$caseArgs<ExtArgs>
    element?: boolean | Comment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Comment$resolvedByArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | Comment$caseArgs<ExtArgs>
    element?: boolean | Comment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Comment$resolvedByArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | Comment$caseArgs<ExtArgs>
    element?: boolean | Comment$elementArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Comment$resolvedByArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      case: Prisma.$AssuranceCasePayload<ExtArgs> | null
      element: Prisma.$AssuranceElementPayload<ExtArgs> | null
      author: Prisma.$UserPayload<ExtArgs>
      resolvedBy: Prisma.$UserPayload<ExtArgs> | null
      parentComment: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string | null
      elementId: string | null
      parentCommentId: string | null
      content: string
      authorId: string
      resolved: boolean
      resolvedById: string | null
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     *
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     *
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     *
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends Comment$caseArgs<ExtArgs> = {}>(args?: Subset<T, Comment$caseArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    element<T extends Comment$elementArgs<ExtArgs> = {}>(args?: Subset<T, Comment$elementArgs<ExtArgs>>): Prisma__AssuranceElementClient<$Result.GetResult<Prisma.$AssuranceElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    resolvedBy<T extends Comment$resolvedByArgs<ExtArgs> = {}>(args?: Subset<T, Comment$resolvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parentComment<T extends Comment$parentCommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentCommentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly caseId: FieldRef<"Comment", 'String'>
    readonly elementId: FieldRef<"Comment", 'String'>
    readonly parentCommentId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly resolved: FieldRef<"Comment", 'Boolean'>
    readonly resolvedById: FieldRef<"Comment", 'String'>
    readonly resolvedAt: FieldRef<"Comment", 'DateTime'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.case
   */
  export type Comment$caseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceCase
     */
    select?: AssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceCase
     */
    omit?: AssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceCaseInclude<ExtArgs> | null
    where?: AssuranceCaseWhereInput
  }

  /**
   * Comment.element
   */
  export type Comment$elementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssuranceElement
     */
    select?: AssuranceElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AssuranceElement
     */
    omit?: AssuranceElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssuranceElementInclude<ExtArgs> | null
    where?: AssuranceElementWhereInput
  }

  /**
   * Comment.resolvedBy
   */
  export type Comment$resolvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Comment.parentComment
   */
  export type Comment$parentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model CaseImage
   */

  export type AggregateCaseImage = {
    _count: CaseImageCountAggregateOutputType | null
    _min: CaseImageMinAggregateOutputType | null
    _max: CaseImageMaxAggregateOutputType | null
  }

  export type CaseImageMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    imageUrl: string | null
    uploadedAt: Date | null
    uploadedById: string | null
  }

  export type CaseImageMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    imageUrl: string | null
    uploadedAt: Date | null
    uploadedById: string | null
  }

  export type CaseImageCountAggregateOutputType = {
    id: number
    caseId: number
    imageUrl: number
    uploadedAt: number
    uploadedById: number
    _all: number
  }


  export type CaseImageMinAggregateInputType = {
    id?: true
    caseId?: true
    imageUrl?: true
    uploadedAt?: true
    uploadedById?: true
  }

  export type CaseImageMaxAggregateInputType = {
    id?: true
    caseId?: true
    imageUrl?: true
    uploadedAt?: true
    uploadedById?: true
  }

  export type CaseImageCountAggregateInputType = {
    id?: true
    caseId?: true
    imageUrl?: true
    uploadedAt?: true
    uploadedById?: true
    _all?: true
  }

  export type CaseImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseImage to aggregate.
     */
    where?: CaseImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseImages to fetch.
     */
    orderBy?: CaseImageOrderByWithRelationInput | CaseImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CaseImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CaseImages
    **/
    _count?: true | CaseImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CaseImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CaseImageMaxAggregateInputType
  }

  export type GetCaseImageAggregateType<T extends CaseImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseImage[P]>
      : GetScalarType<T[P], AggregateCaseImage[P]>
  }




  export type CaseImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseImageWhereInput
    orderBy?: CaseImageOrderByWithAggregationInput | CaseImageOrderByWithAggregationInput[]
    by: CaseImageScalarFieldEnum[] | CaseImageScalarFieldEnum
    having?: CaseImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseImageCountAggregateInputType | true
    _min?: CaseImageMinAggregateInputType
    _max?: CaseImageMaxAggregateInputType
  }

  export type CaseImageGroupByOutputType = {
    id: string
    caseId: string
    imageUrl: string
    uploadedAt: Date
    uploadedById: string
    _count: CaseImageCountAggregateOutputType | null
    _min: CaseImageMinAggregateOutputType | null
    _max: CaseImageMaxAggregateOutputType | null
  }

  type GetCaseImageGroupByPayload<T extends CaseImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseImageGroupByOutputType[P]>
            : GetScalarType<T[P], CaseImageGroupByOutputType[P]>
        }
      >
    >


  export type CaseImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    imageUrl?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseImage"]>

  export type CaseImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    imageUrl?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseImage"]>

  export type CaseImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    imageUrl?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseImage"]>

  export type CaseImageSelectScalar = {
    id?: boolean
    caseId?: boolean
    imageUrl?: boolean
    uploadedAt?: boolean
    uploadedById?: boolean
  }

  export type CaseImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "imageUrl" | "uploadedAt" | "uploadedById", ExtArgs["result"]["caseImage"]>
  export type CaseImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }
  export type CaseImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }
  export type CaseImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }

  export type $CaseImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseImage"
    objects: {
      case: Prisma.$AssuranceCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      imageUrl: string
      uploadedAt: Date
      uploadedById: string
    }, ExtArgs["result"]["caseImage"]>
    composites: {}
  }

  type CaseImageGetPayload<S extends boolean | null | undefined | CaseImageDefaultArgs> = $Result.GetResult<Prisma.$CaseImagePayload, S>

  type CaseImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseImageCountAggregateInputType | true
    }

  export interface CaseImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseImage'], meta: { name: 'CaseImage' } }
    /**
     * Find zero or one CaseImage that matches the filter.
     * @param {CaseImageFindUniqueArgs} args - Arguments to find a CaseImage
     * @example
     * // Get one CaseImage
     * const caseImage = await prisma.caseImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseImageFindUniqueArgs>(args: SelectSubset<T, CaseImageFindUniqueArgs<ExtArgs>>): Prisma__CaseImageClient<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseImageFindUniqueOrThrowArgs} args - Arguments to find a CaseImage
     * @example
     * // Get one CaseImage
     * const caseImage = await prisma.caseImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseImageClient<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseImageFindFirstArgs} args - Arguments to find a CaseImage
     * @example
     * // Get one CaseImage
     * const caseImage = await prisma.caseImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseImageFindFirstArgs>(args?: SelectSubset<T, CaseImageFindFirstArgs<ExtArgs>>): Prisma__CaseImageClient<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseImageFindFirstOrThrowArgs} args - Arguments to find a CaseImage
     * @example
     * // Get one CaseImage
     * const caseImage = await prisma.caseImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseImageClient<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseImages
     * const caseImages = await prisma.caseImage.findMany()
     *
     * // Get first 10 CaseImages
     * const caseImages = await prisma.caseImage.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const caseImageWithIdOnly = await prisma.caseImage.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CaseImageFindManyArgs>(args?: SelectSubset<T, CaseImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseImage.
     * @param {CaseImageCreateArgs} args - Arguments to create a CaseImage.
     * @example
     * // Create one CaseImage
     * const CaseImage = await prisma.caseImage.create({
     *   data: {
     *     // ... data to create a CaseImage
     *   }
     * })
     *
     */
    create<T extends CaseImageCreateArgs>(args: SelectSubset<T, CaseImageCreateArgs<ExtArgs>>): Prisma__CaseImageClient<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseImages.
     * @param {CaseImageCreateManyArgs} args - Arguments to create many CaseImages.
     * @example
     * // Create many CaseImages
     * const caseImage = await prisma.caseImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CaseImageCreateManyArgs>(args?: SelectSubset<T, CaseImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseImages and returns the data saved in the database.
     * @param {CaseImageCreateManyAndReturnArgs} args - Arguments to create many CaseImages.
     * @example
     * // Create many CaseImages
     * const caseImage = await prisma.caseImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CaseImages and only return the `id`
     * const caseImageWithIdOnly = await prisma.caseImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CaseImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseImage.
     * @param {CaseImageDeleteArgs} args - Arguments to delete one CaseImage.
     * @example
     * // Delete one CaseImage
     * const CaseImage = await prisma.caseImage.delete({
     *   where: {
     *     // ... filter to delete one CaseImage
     *   }
     * })
     *
     */
    delete<T extends CaseImageDeleteArgs>(args: SelectSubset<T, CaseImageDeleteArgs<ExtArgs>>): Prisma__CaseImageClient<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseImage.
     * @param {CaseImageUpdateArgs} args - Arguments to update one CaseImage.
     * @example
     * // Update one CaseImage
     * const caseImage = await prisma.caseImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CaseImageUpdateArgs>(args: SelectSubset<T, CaseImageUpdateArgs<ExtArgs>>): Prisma__CaseImageClient<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseImages.
     * @param {CaseImageDeleteManyArgs} args - Arguments to filter CaseImages to delete.
     * @example
     * // Delete a few CaseImages
     * const { count } = await prisma.caseImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CaseImageDeleteManyArgs>(args?: SelectSubset<T, CaseImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseImages
     * const caseImage = await prisma.caseImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CaseImageUpdateManyArgs>(args: SelectSubset<T, CaseImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseImages and returns the data updated in the database.
     * @param {CaseImageUpdateManyAndReturnArgs} args - Arguments to update many CaseImages.
     * @example
     * // Update many CaseImages
     * const caseImage = await prisma.caseImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CaseImages and only return the `id`
     * const caseImageWithIdOnly = await prisma.caseImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CaseImageUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseImage.
     * @param {CaseImageUpsertArgs} args - Arguments to update or create a CaseImage.
     * @example
     * // Update or create a CaseImage
     * const caseImage = await prisma.caseImage.upsert({
     *   create: {
     *     // ... data to create a CaseImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseImage we want to update
     *   }
     * })
     */
    upsert<T extends CaseImageUpsertArgs>(args: SelectSubset<T, CaseImageUpsertArgs<ExtArgs>>): Prisma__CaseImageClient<$Result.GetResult<Prisma.$CaseImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseImageCountArgs} args - Arguments to filter CaseImages to count.
     * @example
     * // Count the number of CaseImages
     * const count = await prisma.caseImage.count({
     *   where: {
     *     // ... the filter for the CaseImages we want to count
     *   }
     * })
    **/
    count<T extends CaseImageCountArgs>(
      args?: Subset<T, CaseImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseImageAggregateArgs>(args: Subset<T, CaseImageAggregateArgs>): Prisma.PrismaPromise<GetCaseImageAggregateType<T>>

    /**
     * Group by CaseImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CaseImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseImageGroupByArgs['orderBy'] }
        : { orderBy?: CaseImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseImage model
   */
  readonly fields: CaseImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends AssuranceCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCaseDefaultArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseImage model
   */
  interface CaseImageFieldRefs {
    readonly id: FieldRef<"CaseImage", 'String'>
    readonly caseId: FieldRef<"CaseImage", 'String'>
    readonly imageUrl: FieldRef<"CaseImage", 'String'>
    readonly uploadedAt: FieldRef<"CaseImage", 'DateTime'>
    readonly uploadedById: FieldRef<"CaseImage", 'String'>
  }


  // Custom InputTypes
  /**
   * CaseImage findUnique
   */
  export type CaseImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseImage to fetch.
     */
    where: CaseImageWhereUniqueInput
  }

  /**
   * CaseImage findUniqueOrThrow
   */
  export type CaseImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseImage to fetch.
     */
    where: CaseImageWhereUniqueInput
  }

  /**
   * CaseImage findFirst
   */
  export type CaseImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseImage to fetch.
     */
    where?: CaseImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseImages to fetch.
     */
    orderBy?: CaseImageOrderByWithRelationInput | CaseImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseImages.
     */
    cursor?: CaseImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseImages.
     */
    distinct?: CaseImageScalarFieldEnum | CaseImageScalarFieldEnum[]
  }

  /**
   * CaseImage findFirstOrThrow
   */
  export type CaseImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseImage to fetch.
     */
    where?: CaseImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseImages to fetch.
     */
    orderBy?: CaseImageOrderByWithRelationInput | CaseImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseImages.
     */
    cursor?: CaseImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseImages.
     */
    distinct?: CaseImageScalarFieldEnum | CaseImageScalarFieldEnum[]
  }

  /**
   * CaseImage findMany
   */
  export type CaseImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseImages to fetch.
     */
    where?: CaseImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseImages to fetch.
     */
    orderBy?: CaseImageOrderByWithRelationInput | CaseImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CaseImages.
     */
    cursor?: CaseImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseImages.
     */
    skip?: number
    distinct?: CaseImageScalarFieldEnum | CaseImageScalarFieldEnum[]
  }

  /**
   * CaseImage create
   */
  export type CaseImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseImage.
     */
    data: XOR<CaseImageCreateInput, CaseImageUncheckedCreateInput>
  }

  /**
   * CaseImage createMany
   */
  export type CaseImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseImages.
     */
    data: CaseImageCreateManyInput | CaseImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseImage createManyAndReturn
   */
  export type CaseImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * The data used to create many CaseImages.
     */
    data: CaseImageCreateManyInput | CaseImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseImage update
   */
  export type CaseImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseImage.
     */
    data: XOR<CaseImageUpdateInput, CaseImageUncheckedUpdateInput>
    /**
     * Choose, which CaseImage to update.
     */
    where: CaseImageWhereUniqueInput
  }

  /**
   * CaseImage updateMany
   */
  export type CaseImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseImages.
     */
    data: XOR<CaseImageUpdateManyMutationInput, CaseImageUncheckedUpdateManyInput>
    /**
     * Filter which CaseImages to update
     */
    where?: CaseImageWhereInput
    /**
     * Limit how many CaseImages to update.
     */
    limit?: number
  }

  /**
   * CaseImage updateManyAndReturn
   */
  export type CaseImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * The data used to update CaseImages.
     */
    data: XOR<CaseImageUpdateManyMutationInput, CaseImageUncheckedUpdateManyInput>
    /**
     * Filter which CaseImages to update
     */
    where?: CaseImageWhereInput
    /**
     * Limit how many CaseImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseImage upsert
   */
  export type CaseImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseImage to update in case it exists.
     */
    where: CaseImageWhereUniqueInput
    /**
     * In case the CaseImage found by the `where` argument doesn't exist, create a new CaseImage with this data.
     */
    create: XOR<CaseImageCreateInput, CaseImageUncheckedCreateInput>
    /**
     * In case the CaseImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseImageUpdateInput, CaseImageUncheckedUpdateInput>
  }

  /**
   * CaseImage delete
   */
  export type CaseImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
    /**
     * Filter which CaseImage to delete.
     */
    where: CaseImageWhereUniqueInput
  }

  /**
   * CaseImage deleteMany
   */
  export type CaseImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseImages to delete
     */
    where?: CaseImageWhereInput
    /**
     * Limit how many CaseImages to delete.
     */
    limit?: number
  }

  /**
   * CaseImage without action
   */
  export type CaseImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseImage
     */
    select?: CaseImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseImage
     */
    omit?: CaseImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseImageInclude<ExtArgs> | null
  }


  /**
   * Model CaseType
   */

  export type AggregateCaseType = {
    _count: CaseTypeCountAggregateOutputType | null
    _min: CaseTypeMinAggregateOutputType | null
    _max: CaseTypeMaxAggregateOutputType | null
  }

  export type CaseTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.CaseTypeCategory | null
    externalUrl: string | null
    createdAt: Date | null
  }

  export type CaseTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    category: $Enums.CaseTypeCategory | null
    externalUrl: string | null
    createdAt: Date | null
  }

  export type CaseTypeCountAggregateOutputType = {
    id: number
    name: number
    description: number
    category: number
    externalUrl: number
    createdAt: number
    _all: number
  }


  export type CaseTypeMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    externalUrl?: true
    createdAt?: true
  }

  export type CaseTypeMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    externalUrl?: true
    createdAt?: true
  }

  export type CaseTypeCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    category?: true
    externalUrl?: true
    createdAt?: true
    _all?: true
  }

  export type CaseTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseType to aggregate.
     */
    where?: CaseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTypes to fetch.
     */
    orderBy?: CaseTypeOrderByWithRelationInput | CaseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CaseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CaseTypes
    **/
    _count?: true | CaseTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CaseTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CaseTypeMaxAggregateInputType
  }

  export type GetCaseTypeAggregateType<T extends CaseTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseType[P]>
      : GetScalarType<T[P], AggregateCaseType[P]>
  }




  export type CaseTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseTypeWhereInput
    orderBy?: CaseTypeOrderByWithAggregationInput | CaseTypeOrderByWithAggregationInput[]
    by: CaseTypeScalarFieldEnum[] | CaseTypeScalarFieldEnum
    having?: CaseTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseTypeCountAggregateInputType | true
    _min?: CaseTypeMinAggregateInputType
    _max?: CaseTypeMaxAggregateInputType
  }

  export type CaseTypeGroupByOutputType = {
    id: string
    name: string
    description: string | null
    category: $Enums.CaseTypeCategory
    externalUrl: string | null
    createdAt: Date
    _count: CaseTypeCountAggregateOutputType | null
    _min: CaseTypeMinAggregateOutputType | null
    _max: CaseTypeMaxAggregateOutputType | null
  }

  type GetCaseTypeGroupByPayload<T extends CaseTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseTypeGroupByOutputType[P]>
            : GetScalarType<T[P], CaseTypeGroupByOutputType[P]>
        }
      >
    >


  export type CaseTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    externalUrl?: boolean
    createdAt?: boolean
    assignments?: boolean | CaseType$assignmentsArgs<ExtArgs>
    _count?: boolean | CaseTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseType"]>

  export type CaseTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    externalUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["caseType"]>

  export type CaseTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    externalUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["caseType"]>

  export type CaseTypeSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    externalUrl?: boolean
    createdAt?: boolean
  }

  export type CaseTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "category" | "externalUrl" | "createdAt", ExtArgs["result"]["caseType"]>
  export type CaseTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | CaseType$assignmentsArgs<ExtArgs>
    _count?: boolean | CaseTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CaseTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CaseTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CaseTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseType"
    objects: {
      assignments: Prisma.$CaseTypeAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      category: $Enums.CaseTypeCategory
      externalUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["caseType"]>
    composites: {}
  }

  type CaseTypeGetPayload<S extends boolean | null | undefined | CaseTypeDefaultArgs> = $Result.GetResult<Prisma.$CaseTypePayload, S>

  type CaseTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseTypeCountAggregateInputType | true
    }

  export interface CaseTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseType'], meta: { name: 'CaseType' } }
    /**
     * Find zero or one CaseType that matches the filter.
     * @param {CaseTypeFindUniqueArgs} args - Arguments to find a CaseType
     * @example
     * // Get one CaseType
     * const caseType = await prisma.caseType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseTypeFindUniqueArgs>(args: SelectSubset<T, CaseTypeFindUniqueArgs<ExtArgs>>): Prisma__CaseTypeClient<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseTypeFindUniqueOrThrowArgs} args - Arguments to find a CaseType
     * @example
     * // Get one CaseType
     * const caseType = await prisma.caseType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseTypeClient<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeFindFirstArgs} args - Arguments to find a CaseType
     * @example
     * // Get one CaseType
     * const caseType = await prisma.caseType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseTypeFindFirstArgs>(args?: SelectSubset<T, CaseTypeFindFirstArgs<ExtArgs>>): Prisma__CaseTypeClient<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeFindFirstOrThrowArgs} args - Arguments to find a CaseType
     * @example
     * // Get one CaseType
     * const caseType = await prisma.caseType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseTypeClient<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseTypes
     * const caseTypes = await prisma.caseType.findMany()
     *
     * // Get first 10 CaseTypes
     * const caseTypes = await prisma.caseType.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const caseTypeWithIdOnly = await prisma.caseType.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CaseTypeFindManyArgs>(args?: SelectSubset<T, CaseTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseType.
     * @param {CaseTypeCreateArgs} args - Arguments to create a CaseType.
     * @example
     * // Create one CaseType
     * const CaseType = await prisma.caseType.create({
     *   data: {
     *     // ... data to create a CaseType
     *   }
     * })
     *
     */
    create<T extends CaseTypeCreateArgs>(args: SelectSubset<T, CaseTypeCreateArgs<ExtArgs>>): Prisma__CaseTypeClient<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseTypes.
     * @param {CaseTypeCreateManyArgs} args - Arguments to create many CaseTypes.
     * @example
     * // Create many CaseTypes
     * const caseType = await prisma.caseType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CaseTypeCreateManyArgs>(args?: SelectSubset<T, CaseTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseTypes and returns the data saved in the database.
     * @param {CaseTypeCreateManyAndReturnArgs} args - Arguments to create many CaseTypes.
     * @example
     * // Create many CaseTypes
     * const caseType = await prisma.caseType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CaseTypes and only return the `id`
     * const caseTypeWithIdOnly = await prisma.caseType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CaseTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseType.
     * @param {CaseTypeDeleteArgs} args - Arguments to delete one CaseType.
     * @example
     * // Delete one CaseType
     * const CaseType = await prisma.caseType.delete({
     *   where: {
     *     // ... filter to delete one CaseType
     *   }
     * })
     *
     */
    delete<T extends CaseTypeDeleteArgs>(args: SelectSubset<T, CaseTypeDeleteArgs<ExtArgs>>): Prisma__CaseTypeClient<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseType.
     * @param {CaseTypeUpdateArgs} args - Arguments to update one CaseType.
     * @example
     * // Update one CaseType
     * const caseType = await prisma.caseType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CaseTypeUpdateArgs>(args: SelectSubset<T, CaseTypeUpdateArgs<ExtArgs>>): Prisma__CaseTypeClient<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseTypes.
     * @param {CaseTypeDeleteManyArgs} args - Arguments to filter CaseTypes to delete.
     * @example
     * // Delete a few CaseTypes
     * const { count } = await prisma.caseType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CaseTypeDeleteManyArgs>(args?: SelectSubset<T, CaseTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseTypes
     * const caseType = await prisma.caseType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CaseTypeUpdateManyArgs>(args: SelectSubset<T, CaseTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseTypes and returns the data updated in the database.
     * @param {CaseTypeUpdateManyAndReturnArgs} args - Arguments to update many CaseTypes.
     * @example
     * // Update many CaseTypes
     * const caseType = await prisma.caseType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CaseTypes and only return the `id`
     * const caseTypeWithIdOnly = await prisma.caseType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CaseTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseType.
     * @param {CaseTypeUpsertArgs} args - Arguments to update or create a CaseType.
     * @example
     * // Update or create a CaseType
     * const caseType = await prisma.caseType.upsert({
     *   create: {
     *     // ... data to create a CaseType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseType we want to update
     *   }
     * })
     */
    upsert<T extends CaseTypeUpsertArgs>(args: SelectSubset<T, CaseTypeUpsertArgs<ExtArgs>>): Prisma__CaseTypeClient<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeCountArgs} args - Arguments to filter CaseTypes to count.
     * @example
     * // Count the number of CaseTypes
     * const count = await prisma.caseType.count({
     *   where: {
     *     // ... the filter for the CaseTypes we want to count
     *   }
     * })
    **/
    count<T extends CaseTypeCountArgs>(
      args?: Subset<T, CaseTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseTypeAggregateArgs>(args: Subset<T, CaseTypeAggregateArgs>): Prisma.PrismaPromise<GetCaseTypeAggregateType<T>>

    /**
     * Group by CaseType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CaseTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseTypeGroupByArgs['orderBy'] }
        : { orderBy?: CaseTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseType model
   */
  readonly fields: CaseTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignments<T extends CaseType$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, CaseType$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseType model
   */
  interface CaseTypeFieldRefs {
    readonly id: FieldRef<"CaseType", 'String'>
    readonly name: FieldRef<"CaseType", 'String'>
    readonly description: FieldRef<"CaseType", 'String'>
    readonly category: FieldRef<"CaseType", 'CaseTypeCategory'>
    readonly externalUrl: FieldRef<"CaseType", 'String'>
    readonly createdAt: FieldRef<"CaseType", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * CaseType findUnique
   */
  export type CaseTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
    /**
     * Filter, which CaseType to fetch.
     */
    where: CaseTypeWhereUniqueInput
  }

  /**
   * CaseType findUniqueOrThrow
   */
  export type CaseTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
    /**
     * Filter, which CaseType to fetch.
     */
    where: CaseTypeWhereUniqueInput
  }

  /**
   * CaseType findFirst
   */
  export type CaseTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
    /**
     * Filter, which CaseType to fetch.
     */
    where?: CaseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTypes to fetch.
     */
    orderBy?: CaseTypeOrderByWithRelationInput | CaseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseTypes.
     */
    cursor?: CaseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseTypes.
     */
    distinct?: CaseTypeScalarFieldEnum | CaseTypeScalarFieldEnum[]
  }

  /**
   * CaseType findFirstOrThrow
   */
  export type CaseTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
    /**
     * Filter, which CaseType to fetch.
     */
    where?: CaseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTypes to fetch.
     */
    orderBy?: CaseTypeOrderByWithRelationInput | CaseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseTypes.
     */
    cursor?: CaseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseTypes.
     */
    distinct?: CaseTypeScalarFieldEnum | CaseTypeScalarFieldEnum[]
  }

  /**
   * CaseType findMany
   */
  export type CaseTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
    /**
     * Filter, which CaseTypes to fetch.
     */
    where?: CaseTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTypes to fetch.
     */
    orderBy?: CaseTypeOrderByWithRelationInput | CaseTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CaseTypes.
     */
    cursor?: CaseTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTypes.
     */
    skip?: number
    distinct?: CaseTypeScalarFieldEnum | CaseTypeScalarFieldEnum[]
  }

  /**
   * CaseType create
   */
  export type CaseTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseType.
     */
    data: XOR<CaseTypeCreateInput, CaseTypeUncheckedCreateInput>
  }

  /**
   * CaseType createMany
   */
  export type CaseTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseTypes.
     */
    data: CaseTypeCreateManyInput | CaseTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseType createManyAndReturn
   */
  export type CaseTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * The data used to create many CaseTypes.
     */
    data: CaseTypeCreateManyInput | CaseTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseType update
   */
  export type CaseTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseType.
     */
    data: XOR<CaseTypeUpdateInput, CaseTypeUncheckedUpdateInput>
    /**
     * Choose, which CaseType to update.
     */
    where: CaseTypeWhereUniqueInput
  }

  /**
   * CaseType updateMany
   */
  export type CaseTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseTypes.
     */
    data: XOR<CaseTypeUpdateManyMutationInput, CaseTypeUncheckedUpdateManyInput>
    /**
     * Filter which CaseTypes to update
     */
    where?: CaseTypeWhereInput
    /**
     * Limit how many CaseTypes to update.
     */
    limit?: number
  }

  /**
   * CaseType updateManyAndReturn
   */
  export type CaseTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * The data used to update CaseTypes.
     */
    data: XOR<CaseTypeUpdateManyMutationInput, CaseTypeUncheckedUpdateManyInput>
    /**
     * Filter which CaseTypes to update
     */
    where?: CaseTypeWhereInput
    /**
     * Limit how many CaseTypes to update.
     */
    limit?: number
  }

  /**
   * CaseType upsert
   */
  export type CaseTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseType to update in case it exists.
     */
    where: CaseTypeWhereUniqueInput
    /**
     * In case the CaseType found by the `where` argument doesn't exist, create a new CaseType with this data.
     */
    create: XOR<CaseTypeCreateInput, CaseTypeUncheckedCreateInput>
    /**
     * In case the CaseType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseTypeUpdateInput, CaseTypeUncheckedUpdateInput>
  }

  /**
   * CaseType delete
   */
  export type CaseTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
    /**
     * Filter which CaseType to delete.
     */
    where: CaseTypeWhereUniqueInput
  }

  /**
   * CaseType deleteMany
   */
  export type CaseTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseTypes to delete
     */
    where?: CaseTypeWhereInput
    /**
     * Limit how many CaseTypes to delete.
     */
    limit?: number
  }

  /**
   * CaseType.assignments
   */
  export type CaseType$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    where?: CaseTypeAssignmentWhereInput
    orderBy?: CaseTypeAssignmentOrderByWithRelationInput | CaseTypeAssignmentOrderByWithRelationInput[]
    cursor?: CaseTypeAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseTypeAssignmentScalarFieldEnum | CaseTypeAssignmentScalarFieldEnum[]
  }

  /**
   * CaseType without action
   */
  export type CaseTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseType
     */
    select?: CaseTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseType
     */
    omit?: CaseTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeInclude<ExtArgs> | null
  }


  /**
   * Model CaseTypeAssignment
   */

  export type AggregateCaseTypeAssignment = {
    _count: CaseTypeAssignmentCountAggregateOutputType | null
    _min: CaseTypeAssignmentMinAggregateOutputType | null
    _max: CaseTypeAssignmentMaxAggregateOutputType | null
  }

  export type CaseTypeAssignmentMinAggregateOutputType = {
    id: string | null
    caseId: string | null
    caseTypeId: string | null
    assignedById: string | null
    assignedAt: Date | null
  }

  export type CaseTypeAssignmentMaxAggregateOutputType = {
    id: string | null
    caseId: string | null
    caseTypeId: string | null
    assignedById: string | null
    assignedAt: Date | null
  }

  export type CaseTypeAssignmentCountAggregateOutputType = {
    id: number
    caseId: number
    caseTypeId: number
    assignedById: number
    assignedAt: number
    _all: number
  }


  export type CaseTypeAssignmentMinAggregateInputType = {
    id?: true
    caseId?: true
    caseTypeId?: true
    assignedById?: true
    assignedAt?: true
  }

  export type CaseTypeAssignmentMaxAggregateInputType = {
    id?: true
    caseId?: true
    caseTypeId?: true
    assignedById?: true
    assignedAt?: true
  }

  export type CaseTypeAssignmentCountAggregateInputType = {
    id?: true
    caseId?: true
    caseTypeId?: true
    assignedById?: true
    assignedAt?: true
    _all?: true
  }

  export type CaseTypeAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseTypeAssignment to aggregate.
     */
    where?: CaseTypeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTypeAssignments to fetch.
     */
    orderBy?: CaseTypeAssignmentOrderByWithRelationInput | CaseTypeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CaseTypeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTypeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTypeAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CaseTypeAssignments
    **/
    _count?: true | CaseTypeAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CaseTypeAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CaseTypeAssignmentMaxAggregateInputType
  }

  export type GetCaseTypeAssignmentAggregateType<T extends CaseTypeAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseTypeAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseTypeAssignment[P]>
      : GetScalarType<T[P], AggregateCaseTypeAssignment[P]>
  }




  export type CaseTypeAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseTypeAssignmentWhereInput
    orderBy?: CaseTypeAssignmentOrderByWithAggregationInput | CaseTypeAssignmentOrderByWithAggregationInput[]
    by: CaseTypeAssignmentScalarFieldEnum[] | CaseTypeAssignmentScalarFieldEnum
    having?: CaseTypeAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseTypeAssignmentCountAggregateInputType | true
    _min?: CaseTypeAssignmentMinAggregateInputType
    _max?: CaseTypeAssignmentMaxAggregateInputType
  }

  export type CaseTypeAssignmentGroupByOutputType = {
    id: string
    caseId: string
    caseTypeId: string
    assignedById: string
    assignedAt: Date
    _count: CaseTypeAssignmentCountAggregateOutputType | null
    _min: CaseTypeAssignmentMinAggregateOutputType | null
    _max: CaseTypeAssignmentMaxAggregateOutputType | null
  }

  type GetCaseTypeAssignmentGroupByPayload<T extends CaseTypeAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseTypeAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseTypeAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseTypeAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], CaseTypeAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type CaseTypeAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    caseTypeId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    caseType?: boolean | CaseTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseTypeAssignment"]>

  export type CaseTypeAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    caseTypeId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    caseType?: boolean | CaseTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseTypeAssignment"]>

  export type CaseTypeAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseId?: boolean
    caseTypeId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    caseType?: boolean | CaseTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseTypeAssignment"]>

  export type CaseTypeAssignmentSelectScalar = {
    id?: boolean
    caseId?: boolean
    caseTypeId?: boolean
    assignedById?: boolean
    assignedAt?: boolean
  }

  export type CaseTypeAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseId" | "caseTypeId" | "assignedById" | "assignedAt", ExtArgs["result"]["caseTypeAssignment"]>
  export type CaseTypeAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    caseType?: boolean | CaseTypeDefaultArgs<ExtArgs>
  }
  export type CaseTypeAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    caseType?: boolean | CaseTypeDefaultArgs<ExtArgs>
  }
  export type CaseTypeAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    case?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    caseType?: boolean | CaseTypeDefaultArgs<ExtArgs>
  }

  export type $CaseTypeAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseTypeAssignment"
    objects: {
      case: Prisma.$AssuranceCasePayload<ExtArgs>
      caseType: Prisma.$CaseTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      caseId: string
      caseTypeId: string
      assignedById: string
      assignedAt: Date
    }, ExtArgs["result"]["caseTypeAssignment"]>
    composites: {}
  }

  type CaseTypeAssignmentGetPayload<S extends boolean | null | undefined | CaseTypeAssignmentDefaultArgs> = $Result.GetResult<Prisma.$CaseTypeAssignmentPayload, S>

  type CaseTypeAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseTypeAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseTypeAssignmentCountAggregateInputType | true
    }

  export interface CaseTypeAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseTypeAssignment'], meta: { name: 'CaseTypeAssignment' } }
    /**
     * Find zero or one CaseTypeAssignment that matches the filter.
     * @param {CaseTypeAssignmentFindUniqueArgs} args - Arguments to find a CaseTypeAssignment
     * @example
     * // Get one CaseTypeAssignment
     * const caseTypeAssignment = await prisma.caseTypeAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseTypeAssignmentFindUniqueArgs>(args: SelectSubset<T, CaseTypeAssignmentFindUniqueArgs<ExtArgs>>): Prisma__CaseTypeAssignmentClient<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseTypeAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseTypeAssignmentFindUniqueOrThrowArgs} args - Arguments to find a CaseTypeAssignment
     * @example
     * // Get one CaseTypeAssignment
     * const caseTypeAssignment = await prisma.caseTypeAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseTypeAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseTypeAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseTypeAssignmentClient<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseTypeAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeAssignmentFindFirstArgs} args - Arguments to find a CaseTypeAssignment
     * @example
     * // Get one CaseTypeAssignment
     * const caseTypeAssignment = await prisma.caseTypeAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseTypeAssignmentFindFirstArgs>(args?: SelectSubset<T, CaseTypeAssignmentFindFirstArgs<ExtArgs>>): Prisma__CaseTypeAssignmentClient<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseTypeAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeAssignmentFindFirstOrThrowArgs} args - Arguments to find a CaseTypeAssignment
     * @example
     * // Get one CaseTypeAssignment
     * const caseTypeAssignment = await prisma.caseTypeAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseTypeAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseTypeAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseTypeAssignmentClient<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseTypeAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseTypeAssignments
     * const caseTypeAssignments = await prisma.caseTypeAssignment.findMany()
     *
     * // Get first 10 CaseTypeAssignments
     * const caseTypeAssignments = await prisma.caseTypeAssignment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const caseTypeAssignmentWithIdOnly = await prisma.caseTypeAssignment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CaseTypeAssignmentFindManyArgs>(args?: SelectSubset<T, CaseTypeAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseTypeAssignment.
     * @param {CaseTypeAssignmentCreateArgs} args - Arguments to create a CaseTypeAssignment.
     * @example
     * // Create one CaseTypeAssignment
     * const CaseTypeAssignment = await prisma.caseTypeAssignment.create({
     *   data: {
     *     // ... data to create a CaseTypeAssignment
     *   }
     * })
     *
     */
    create<T extends CaseTypeAssignmentCreateArgs>(args: SelectSubset<T, CaseTypeAssignmentCreateArgs<ExtArgs>>): Prisma__CaseTypeAssignmentClient<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseTypeAssignments.
     * @param {CaseTypeAssignmentCreateManyArgs} args - Arguments to create many CaseTypeAssignments.
     * @example
     * // Create many CaseTypeAssignments
     * const caseTypeAssignment = await prisma.caseTypeAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CaseTypeAssignmentCreateManyArgs>(args?: SelectSubset<T, CaseTypeAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseTypeAssignments and returns the data saved in the database.
     * @param {CaseTypeAssignmentCreateManyAndReturnArgs} args - Arguments to create many CaseTypeAssignments.
     * @example
     * // Create many CaseTypeAssignments
     * const caseTypeAssignment = await prisma.caseTypeAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CaseTypeAssignments and only return the `id`
     * const caseTypeAssignmentWithIdOnly = await prisma.caseTypeAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CaseTypeAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseTypeAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseTypeAssignment.
     * @param {CaseTypeAssignmentDeleteArgs} args - Arguments to delete one CaseTypeAssignment.
     * @example
     * // Delete one CaseTypeAssignment
     * const CaseTypeAssignment = await prisma.caseTypeAssignment.delete({
     *   where: {
     *     // ... filter to delete one CaseTypeAssignment
     *   }
     * })
     *
     */
    delete<T extends CaseTypeAssignmentDeleteArgs>(args: SelectSubset<T, CaseTypeAssignmentDeleteArgs<ExtArgs>>): Prisma__CaseTypeAssignmentClient<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseTypeAssignment.
     * @param {CaseTypeAssignmentUpdateArgs} args - Arguments to update one CaseTypeAssignment.
     * @example
     * // Update one CaseTypeAssignment
     * const caseTypeAssignment = await prisma.caseTypeAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CaseTypeAssignmentUpdateArgs>(args: SelectSubset<T, CaseTypeAssignmentUpdateArgs<ExtArgs>>): Prisma__CaseTypeAssignmentClient<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseTypeAssignments.
     * @param {CaseTypeAssignmentDeleteManyArgs} args - Arguments to filter CaseTypeAssignments to delete.
     * @example
     * // Delete a few CaseTypeAssignments
     * const { count } = await prisma.caseTypeAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CaseTypeAssignmentDeleteManyArgs>(args?: SelectSubset<T, CaseTypeAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseTypeAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseTypeAssignments
     * const caseTypeAssignment = await prisma.caseTypeAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CaseTypeAssignmentUpdateManyArgs>(args: SelectSubset<T, CaseTypeAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseTypeAssignments and returns the data updated in the database.
     * @param {CaseTypeAssignmentUpdateManyAndReturnArgs} args - Arguments to update many CaseTypeAssignments.
     * @example
     * // Update many CaseTypeAssignments
     * const caseTypeAssignment = await prisma.caseTypeAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CaseTypeAssignments and only return the `id`
     * const caseTypeAssignmentWithIdOnly = await prisma.caseTypeAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CaseTypeAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseTypeAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseTypeAssignment.
     * @param {CaseTypeAssignmentUpsertArgs} args - Arguments to update or create a CaseTypeAssignment.
     * @example
     * // Update or create a CaseTypeAssignment
     * const caseTypeAssignment = await prisma.caseTypeAssignment.upsert({
     *   create: {
     *     // ... data to create a CaseTypeAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseTypeAssignment we want to update
     *   }
     * })
     */
    upsert<T extends CaseTypeAssignmentUpsertArgs>(args: SelectSubset<T, CaseTypeAssignmentUpsertArgs<ExtArgs>>): Prisma__CaseTypeAssignmentClient<$Result.GetResult<Prisma.$CaseTypeAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseTypeAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeAssignmentCountArgs} args - Arguments to filter CaseTypeAssignments to count.
     * @example
     * // Count the number of CaseTypeAssignments
     * const count = await prisma.caseTypeAssignment.count({
     *   where: {
     *     // ... the filter for the CaseTypeAssignments we want to count
     *   }
     * })
    **/
    count<T extends CaseTypeAssignmentCountArgs>(
      args?: Subset<T, CaseTypeAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseTypeAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseTypeAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseTypeAssignmentAggregateArgs>(args: Subset<T, CaseTypeAssignmentAggregateArgs>): Prisma.PrismaPromise<GetCaseTypeAssignmentAggregateType<T>>

    /**
     * Group by CaseTypeAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseTypeAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CaseTypeAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseTypeAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: CaseTypeAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseTypeAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseTypeAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseTypeAssignment model
   */
  readonly fields: CaseTypeAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseTypeAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseTypeAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    case<T extends AssuranceCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCaseDefaultArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    caseType<T extends CaseTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaseTypeDefaultArgs<ExtArgs>>): Prisma__CaseTypeClient<$Result.GetResult<Prisma.$CaseTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseTypeAssignment model
   */
  interface CaseTypeAssignmentFieldRefs {
    readonly id: FieldRef<"CaseTypeAssignment", 'String'>
    readonly caseId: FieldRef<"CaseTypeAssignment", 'String'>
    readonly caseTypeId: FieldRef<"CaseTypeAssignment", 'String'>
    readonly assignedById: FieldRef<"CaseTypeAssignment", 'String'>
    readonly assignedAt: FieldRef<"CaseTypeAssignment", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * CaseTypeAssignment findUnique
   */
  export type CaseTypeAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseTypeAssignment to fetch.
     */
    where: CaseTypeAssignmentWhereUniqueInput
  }

  /**
   * CaseTypeAssignment findUniqueOrThrow
   */
  export type CaseTypeAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseTypeAssignment to fetch.
     */
    where: CaseTypeAssignmentWhereUniqueInput
  }

  /**
   * CaseTypeAssignment findFirst
   */
  export type CaseTypeAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseTypeAssignment to fetch.
     */
    where?: CaseTypeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTypeAssignments to fetch.
     */
    orderBy?: CaseTypeAssignmentOrderByWithRelationInput | CaseTypeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseTypeAssignments.
     */
    cursor?: CaseTypeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTypeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTypeAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseTypeAssignments.
     */
    distinct?: CaseTypeAssignmentScalarFieldEnum | CaseTypeAssignmentScalarFieldEnum[]
  }

  /**
   * CaseTypeAssignment findFirstOrThrow
   */
  export type CaseTypeAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseTypeAssignment to fetch.
     */
    where?: CaseTypeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTypeAssignments to fetch.
     */
    orderBy?: CaseTypeAssignmentOrderByWithRelationInput | CaseTypeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseTypeAssignments.
     */
    cursor?: CaseTypeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTypeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTypeAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseTypeAssignments.
     */
    distinct?: CaseTypeAssignmentScalarFieldEnum | CaseTypeAssignmentScalarFieldEnum[]
  }

  /**
   * CaseTypeAssignment findMany
   */
  export type CaseTypeAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which CaseTypeAssignments to fetch.
     */
    where?: CaseTypeAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseTypeAssignments to fetch.
     */
    orderBy?: CaseTypeAssignmentOrderByWithRelationInput | CaseTypeAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CaseTypeAssignments.
     */
    cursor?: CaseTypeAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseTypeAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseTypeAssignments.
     */
    skip?: number
    distinct?: CaseTypeAssignmentScalarFieldEnum | CaseTypeAssignmentScalarFieldEnum[]
  }

  /**
   * CaseTypeAssignment create
   */
  export type CaseTypeAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseTypeAssignment.
     */
    data: XOR<CaseTypeAssignmentCreateInput, CaseTypeAssignmentUncheckedCreateInput>
  }

  /**
   * CaseTypeAssignment createMany
   */
  export type CaseTypeAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseTypeAssignments.
     */
    data: CaseTypeAssignmentCreateManyInput | CaseTypeAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseTypeAssignment createManyAndReturn
   */
  export type CaseTypeAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many CaseTypeAssignments.
     */
    data: CaseTypeAssignmentCreateManyInput | CaseTypeAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseTypeAssignment update
   */
  export type CaseTypeAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseTypeAssignment.
     */
    data: XOR<CaseTypeAssignmentUpdateInput, CaseTypeAssignmentUncheckedUpdateInput>
    /**
     * Choose, which CaseTypeAssignment to update.
     */
    where: CaseTypeAssignmentWhereUniqueInput
  }

  /**
   * CaseTypeAssignment updateMany
   */
  export type CaseTypeAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseTypeAssignments.
     */
    data: XOR<CaseTypeAssignmentUpdateManyMutationInput, CaseTypeAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which CaseTypeAssignments to update
     */
    where?: CaseTypeAssignmentWhereInput
    /**
     * Limit how many CaseTypeAssignments to update.
     */
    limit?: number
  }

  /**
   * CaseTypeAssignment updateManyAndReturn
   */
  export type CaseTypeAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update CaseTypeAssignments.
     */
    data: XOR<CaseTypeAssignmentUpdateManyMutationInput, CaseTypeAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which CaseTypeAssignments to update
     */
    where?: CaseTypeAssignmentWhereInput
    /**
     * Limit how many CaseTypeAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseTypeAssignment upsert
   */
  export type CaseTypeAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseTypeAssignment to update in case it exists.
     */
    where: CaseTypeAssignmentWhereUniqueInput
    /**
     * In case the CaseTypeAssignment found by the `where` argument doesn't exist, create a new CaseTypeAssignment with this data.
     */
    create: XOR<CaseTypeAssignmentCreateInput, CaseTypeAssignmentUncheckedCreateInput>
    /**
     * In case the CaseTypeAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseTypeAssignmentUpdateInput, CaseTypeAssignmentUncheckedUpdateInput>
  }

  /**
   * CaseTypeAssignment delete
   */
  export type CaseTypeAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
    /**
     * Filter which CaseTypeAssignment to delete.
     */
    where: CaseTypeAssignmentWhereUniqueInput
  }

  /**
   * CaseTypeAssignment deleteMany
   */
  export type CaseTypeAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseTypeAssignments to delete
     */
    where?: CaseTypeAssignmentWhereInput
    /**
     * Limit how many CaseTypeAssignments to delete.
     */
    limit?: number
  }

  /**
   * CaseTypeAssignment without action
   */
  export type CaseTypeAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseTypeAssignment
     */
    select?: CaseTypeAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseTypeAssignment
     */
    omit?: CaseTypeAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseTypeAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model GitHubRepository
   */

  export type AggregateGitHubRepository = {
    _count: GitHubRepositoryCountAggregateOutputType | null
    _min: GitHubRepositoryMinAggregateOutputType | null
    _max: GitHubRepositoryMaxAggregateOutputType | null
  }

  export type GitHubRepositoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    description: string | null
    githubId: string | null
    defaultBranch: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GitHubRepositoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    url: string | null
    description: string | null
    githubId: string | null
    defaultBranch: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GitHubRepositoryCountAggregateOutputType = {
    id: number
    name: number
    url: number
    description: number
    githubId: number
    defaultBranch: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GitHubRepositoryMinAggregateInputType = {
    id?: true
    name?: true
    url?: true
    description?: true
    githubId?: true
    defaultBranch?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GitHubRepositoryMaxAggregateInputType = {
    id?: true
    name?: true
    url?: true
    description?: true
    githubId?: true
    defaultBranch?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GitHubRepositoryCountAggregateInputType = {
    id?: true
    name?: true
    url?: true
    description?: true
    githubId?: true
    defaultBranch?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GitHubRepositoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GitHubRepository to aggregate.
     */
    where?: GitHubRepositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GitHubRepositories to fetch.
     */
    orderBy?: GitHubRepositoryOrderByWithRelationInput | GitHubRepositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: GitHubRepositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GitHubRepositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GitHubRepositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned GitHubRepositories
    **/
    _count?: true | GitHubRepositoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: GitHubRepositoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: GitHubRepositoryMaxAggregateInputType
  }

  export type GetGitHubRepositoryAggregateType<T extends GitHubRepositoryAggregateArgs> = {
        [P in keyof T & keyof AggregateGitHubRepository]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGitHubRepository[P]>
      : GetScalarType<T[P], AggregateGitHubRepository[P]>
  }




  export type GitHubRepositoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GitHubRepositoryWhereInput
    orderBy?: GitHubRepositoryOrderByWithAggregationInput | GitHubRepositoryOrderByWithAggregationInput[]
    by: GitHubRepositoryScalarFieldEnum[] | GitHubRepositoryScalarFieldEnum
    having?: GitHubRepositoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GitHubRepositoryCountAggregateInputType | true
    _min?: GitHubRepositoryMinAggregateInputType
    _max?: GitHubRepositoryMaxAggregateInputType
  }

  export type GitHubRepositoryGroupByOutputType = {
    id: string
    name: string
    url: string
    description: string | null
    githubId: string | null
    defaultBranch: string
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: GitHubRepositoryCountAggregateOutputType | null
    _min: GitHubRepositoryMinAggregateOutputType | null
    _max: GitHubRepositoryMaxAggregateOutputType | null
  }

  type GetGitHubRepositoryGroupByPayload<T extends GitHubRepositoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GitHubRepositoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GitHubRepositoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GitHubRepositoryGroupByOutputType[P]>
            : GetScalarType<T[P], GitHubRepositoryGroupByOutputType[P]>
        }
      >
    >


  export type GitHubRepositorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    description?: boolean
    githubId?: boolean
    defaultBranch?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gitHubRepository"]>

  export type GitHubRepositorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    description?: boolean
    githubId?: boolean
    defaultBranch?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gitHubRepository"]>

  export type GitHubRepositorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    url?: boolean
    description?: boolean
    githubId?: boolean
    defaultBranch?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gitHubRepository"]>

  export type GitHubRepositorySelectScalar = {
    id?: boolean
    name?: boolean
    url?: boolean
    description?: boolean
    githubId?: boolean
    defaultBranch?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GitHubRepositoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "url" | "description" | "githubId" | "defaultBranch" | "userId" | "createdAt" | "updatedAt", ExtArgs["result"]["gitHubRepository"]>
  export type GitHubRepositoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GitHubRepositoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GitHubRepositoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GitHubRepositoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GitHubRepository"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      url: string
      description: string | null
      githubId: string | null
      defaultBranch: string
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["gitHubRepository"]>
    composites: {}
  }

  type GitHubRepositoryGetPayload<S extends boolean | null | undefined | GitHubRepositoryDefaultArgs> = $Result.GetResult<Prisma.$GitHubRepositoryPayload, S>

  type GitHubRepositoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GitHubRepositoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GitHubRepositoryCountAggregateInputType | true
    }

  export interface GitHubRepositoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GitHubRepository'], meta: { name: 'GitHubRepository' } }
    /**
     * Find zero or one GitHubRepository that matches the filter.
     * @param {GitHubRepositoryFindUniqueArgs} args - Arguments to find a GitHubRepository
     * @example
     * // Get one GitHubRepository
     * const gitHubRepository = await prisma.gitHubRepository.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GitHubRepositoryFindUniqueArgs>(args: SelectSubset<T, GitHubRepositoryFindUniqueArgs<ExtArgs>>): Prisma__GitHubRepositoryClient<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GitHubRepository that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GitHubRepositoryFindUniqueOrThrowArgs} args - Arguments to find a GitHubRepository
     * @example
     * // Get one GitHubRepository
     * const gitHubRepository = await prisma.gitHubRepository.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GitHubRepositoryFindUniqueOrThrowArgs>(args: SelectSubset<T, GitHubRepositoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GitHubRepositoryClient<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GitHubRepository that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GitHubRepositoryFindFirstArgs} args - Arguments to find a GitHubRepository
     * @example
     * // Get one GitHubRepository
     * const gitHubRepository = await prisma.gitHubRepository.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GitHubRepositoryFindFirstArgs>(args?: SelectSubset<T, GitHubRepositoryFindFirstArgs<ExtArgs>>): Prisma__GitHubRepositoryClient<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GitHubRepository that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GitHubRepositoryFindFirstOrThrowArgs} args - Arguments to find a GitHubRepository
     * @example
     * // Get one GitHubRepository
     * const gitHubRepository = await prisma.gitHubRepository.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GitHubRepositoryFindFirstOrThrowArgs>(args?: SelectSubset<T, GitHubRepositoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__GitHubRepositoryClient<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GitHubRepositories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GitHubRepositoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GitHubRepositories
     * const gitHubRepositories = await prisma.gitHubRepository.findMany()
     *
     * // Get first 10 GitHubRepositories
     * const gitHubRepositories = await prisma.gitHubRepository.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const gitHubRepositoryWithIdOnly = await prisma.gitHubRepository.findMany({ select: { id: true } })
     *
     */
    findMany<T extends GitHubRepositoryFindManyArgs>(args?: SelectSubset<T, GitHubRepositoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GitHubRepository.
     * @param {GitHubRepositoryCreateArgs} args - Arguments to create a GitHubRepository.
     * @example
     * // Create one GitHubRepository
     * const GitHubRepository = await prisma.gitHubRepository.create({
     *   data: {
     *     // ... data to create a GitHubRepository
     *   }
     * })
     *
     */
    create<T extends GitHubRepositoryCreateArgs>(args: SelectSubset<T, GitHubRepositoryCreateArgs<ExtArgs>>): Prisma__GitHubRepositoryClient<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GitHubRepositories.
     * @param {GitHubRepositoryCreateManyArgs} args - Arguments to create many GitHubRepositories.
     * @example
     * // Create many GitHubRepositories
     * const gitHubRepository = await prisma.gitHubRepository.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends GitHubRepositoryCreateManyArgs>(args?: SelectSubset<T, GitHubRepositoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GitHubRepositories and returns the data saved in the database.
     * @param {GitHubRepositoryCreateManyAndReturnArgs} args - Arguments to create many GitHubRepositories.
     * @example
     * // Create many GitHubRepositories
     * const gitHubRepository = await prisma.gitHubRepository.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many GitHubRepositories and only return the `id`
     * const gitHubRepositoryWithIdOnly = await prisma.gitHubRepository.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends GitHubRepositoryCreateManyAndReturnArgs>(args?: SelectSubset<T, GitHubRepositoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GitHubRepository.
     * @param {GitHubRepositoryDeleteArgs} args - Arguments to delete one GitHubRepository.
     * @example
     * // Delete one GitHubRepository
     * const GitHubRepository = await prisma.gitHubRepository.delete({
     *   where: {
     *     // ... filter to delete one GitHubRepository
     *   }
     * })
     *
     */
    delete<T extends GitHubRepositoryDeleteArgs>(args: SelectSubset<T, GitHubRepositoryDeleteArgs<ExtArgs>>): Prisma__GitHubRepositoryClient<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GitHubRepository.
     * @param {GitHubRepositoryUpdateArgs} args - Arguments to update one GitHubRepository.
     * @example
     * // Update one GitHubRepository
     * const gitHubRepository = await prisma.gitHubRepository.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends GitHubRepositoryUpdateArgs>(args: SelectSubset<T, GitHubRepositoryUpdateArgs<ExtArgs>>): Prisma__GitHubRepositoryClient<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GitHubRepositories.
     * @param {GitHubRepositoryDeleteManyArgs} args - Arguments to filter GitHubRepositories to delete.
     * @example
     * // Delete a few GitHubRepositories
     * const { count } = await prisma.gitHubRepository.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends GitHubRepositoryDeleteManyArgs>(args?: SelectSubset<T, GitHubRepositoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GitHubRepositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GitHubRepositoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GitHubRepositories
     * const gitHubRepository = await prisma.gitHubRepository.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends GitHubRepositoryUpdateManyArgs>(args: SelectSubset<T, GitHubRepositoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GitHubRepositories and returns the data updated in the database.
     * @param {GitHubRepositoryUpdateManyAndReturnArgs} args - Arguments to update many GitHubRepositories.
     * @example
     * // Update many GitHubRepositories
     * const gitHubRepository = await prisma.gitHubRepository.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more GitHubRepositories and only return the `id`
     * const gitHubRepositoryWithIdOnly = await prisma.gitHubRepository.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends GitHubRepositoryUpdateManyAndReturnArgs>(args: SelectSubset<T, GitHubRepositoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GitHubRepository.
     * @param {GitHubRepositoryUpsertArgs} args - Arguments to update or create a GitHubRepository.
     * @example
     * // Update or create a GitHubRepository
     * const gitHubRepository = await prisma.gitHubRepository.upsert({
     *   create: {
     *     // ... data to create a GitHubRepository
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GitHubRepository we want to update
     *   }
     * })
     */
    upsert<T extends GitHubRepositoryUpsertArgs>(args: SelectSubset<T, GitHubRepositoryUpsertArgs<ExtArgs>>): Prisma__GitHubRepositoryClient<$Result.GetResult<Prisma.$GitHubRepositoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GitHubRepositories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GitHubRepositoryCountArgs} args - Arguments to filter GitHubRepositories to count.
     * @example
     * // Count the number of GitHubRepositories
     * const count = await prisma.gitHubRepository.count({
     *   where: {
     *     // ... the filter for the GitHubRepositories we want to count
     *   }
     * })
    **/
    count<T extends GitHubRepositoryCountArgs>(
      args?: Subset<T, GitHubRepositoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GitHubRepositoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GitHubRepository.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GitHubRepositoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GitHubRepositoryAggregateArgs>(args: Subset<T, GitHubRepositoryAggregateArgs>): Prisma.PrismaPromise<GetGitHubRepositoryAggregateType<T>>

    /**
     * Group by GitHubRepository.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GitHubRepositoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends GitHubRepositoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GitHubRepositoryGroupByArgs['orderBy'] }
        : { orderBy?: GitHubRepositoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GitHubRepositoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGitHubRepositoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GitHubRepository model
   */
  readonly fields: GitHubRepositoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GitHubRepository.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GitHubRepositoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GitHubRepository model
   */
  interface GitHubRepositoryFieldRefs {
    readonly id: FieldRef<"GitHubRepository", 'String'>
    readonly name: FieldRef<"GitHubRepository", 'String'>
    readonly url: FieldRef<"GitHubRepository", 'String'>
    readonly description: FieldRef<"GitHubRepository", 'String'>
    readonly githubId: FieldRef<"GitHubRepository", 'String'>
    readonly defaultBranch: FieldRef<"GitHubRepository", 'String'>
    readonly userId: FieldRef<"GitHubRepository", 'String'>
    readonly createdAt: FieldRef<"GitHubRepository", 'DateTime'>
    readonly updatedAt: FieldRef<"GitHubRepository", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * GitHubRepository findUnique
   */
  export type GitHubRepositoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GitHubRepository to fetch.
     */
    where: GitHubRepositoryWhereUniqueInput
  }

  /**
   * GitHubRepository findUniqueOrThrow
   */
  export type GitHubRepositoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GitHubRepository to fetch.
     */
    where: GitHubRepositoryWhereUniqueInput
  }

  /**
   * GitHubRepository findFirst
   */
  export type GitHubRepositoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GitHubRepository to fetch.
     */
    where?: GitHubRepositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GitHubRepositories to fetch.
     */
    orderBy?: GitHubRepositoryOrderByWithRelationInput | GitHubRepositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GitHubRepositories.
     */
    cursor?: GitHubRepositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GitHubRepositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GitHubRepositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GitHubRepositories.
     */
    distinct?: GitHubRepositoryScalarFieldEnum | GitHubRepositoryScalarFieldEnum[]
  }

  /**
   * GitHubRepository findFirstOrThrow
   */
  export type GitHubRepositoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GitHubRepository to fetch.
     */
    where?: GitHubRepositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GitHubRepositories to fetch.
     */
    orderBy?: GitHubRepositoryOrderByWithRelationInput | GitHubRepositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for GitHubRepositories.
     */
    cursor?: GitHubRepositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GitHubRepositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GitHubRepositories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of GitHubRepositories.
     */
    distinct?: GitHubRepositoryScalarFieldEnum | GitHubRepositoryScalarFieldEnum[]
  }

  /**
   * GitHubRepository findMany
   */
  export type GitHubRepositoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    /**
     * Filter, which GitHubRepositories to fetch.
     */
    where?: GitHubRepositoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of GitHubRepositories to fetch.
     */
    orderBy?: GitHubRepositoryOrderByWithRelationInput | GitHubRepositoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing GitHubRepositories.
     */
    cursor?: GitHubRepositoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` GitHubRepositories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` GitHubRepositories.
     */
    skip?: number
    distinct?: GitHubRepositoryScalarFieldEnum | GitHubRepositoryScalarFieldEnum[]
  }

  /**
   * GitHubRepository create
   */
  export type GitHubRepositoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    /**
     * The data needed to create a GitHubRepository.
     */
    data: XOR<GitHubRepositoryCreateInput, GitHubRepositoryUncheckedCreateInput>
  }

  /**
   * GitHubRepository createMany
   */
  export type GitHubRepositoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GitHubRepositories.
     */
    data: GitHubRepositoryCreateManyInput | GitHubRepositoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GitHubRepository createManyAndReturn
   */
  export type GitHubRepositoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * The data used to create many GitHubRepositories.
     */
    data: GitHubRepositoryCreateManyInput | GitHubRepositoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GitHubRepository update
   */
  export type GitHubRepositoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    /**
     * The data needed to update a GitHubRepository.
     */
    data: XOR<GitHubRepositoryUpdateInput, GitHubRepositoryUncheckedUpdateInput>
    /**
     * Choose, which GitHubRepository to update.
     */
    where: GitHubRepositoryWhereUniqueInput
  }

  /**
   * GitHubRepository updateMany
   */
  export type GitHubRepositoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GitHubRepositories.
     */
    data: XOR<GitHubRepositoryUpdateManyMutationInput, GitHubRepositoryUncheckedUpdateManyInput>
    /**
     * Filter which GitHubRepositories to update
     */
    where?: GitHubRepositoryWhereInput
    /**
     * Limit how many GitHubRepositories to update.
     */
    limit?: number
  }

  /**
   * GitHubRepository updateManyAndReturn
   */
  export type GitHubRepositoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * The data used to update GitHubRepositories.
     */
    data: XOR<GitHubRepositoryUpdateManyMutationInput, GitHubRepositoryUncheckedUpdateManyInput>
    /**
     * Filter which GitHubRepositories to update
     */
    where?: GitHubRepositoryWhereInput
    /**
     * Limit how many GitHubRepositories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GitHubRepository upsert
   */
  export type GitHubRepositoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    /**
     * The filter to search for the GitHubRepository to update in case it exists.
     */
    where: GitHubRepositoryWhereUniqueInput
    /**
     * In case the GitHubRepository found by the `where` argument doesn't exist, create a new GitHubRepository with this data.
     */
    create: XOR<GitHubRepositoryCreateInput, GitHubRepositoryUncheckedCreateInput>
    /**
     * In case the GitHubRepository was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GitHubRepositoryUpdateInput, GitHubRepositoryUncheckedUpdateInput>
  }

  /**
   * GitHubRepository delete
   */
  export type GitHubRepositoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
    /**
     * Filter which GitHubRepository to delete.
     */
    where: GitHubRepositoryWhereUniqueInput
  }

  /**
   * GitHubRepository deleteMany
   */
  export type GitHubRepositoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GitHubRepositories to delete
     */
    where?: GitHubRepositoryWhereInput
    /**
     * Limit how many GitHubRepositories to delete.
     */
    limit?: number
  }

  /**
   * GitHubRepository without action
   */
  export type GitHubRepositoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GitHubRepository
     */
    select?: GitHubRepositorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the GitHubRepository
     */
    omit?: GitHubRepositoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GitHubRepositoryInclude<ExtArgs> | null
  }


  /**
   * Model CaseStudy
   */

  export type AggregateCaseStudy = {
    _count: CaseStudyCountAggregateOutputType | null
    _avg: CaseStudyAvgAggregateOutputType | null
    _sum: CaseStudySumAggregateOutputType | null
    _min: CaseStudyMinAggregateOutputType | null
    _max: CaseStudyMaxAggregateOutputType | null
  }

  export type CaseStudyAvgAggregateOutputType = {
    id: number | null
  }

  export type CaseStudySumAggregateOutputType = {
    id: number | null
  }

  export type CaseStudyMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    authors: string | null
    category: string | null
    publishedDate: Date | null
    lastModifiedOn: Date | null
    createdOn: Date | null
    sector: string | null
    contact: string | null
    image: string | null
    published: boolean | null
    ownerId: string | null
    type: string | null
  }

  export type CaseStudyMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    authors: string | null
    category: string | null
    publishedDate: Date | null
    lastModifiedOn: Date | null
    createdOn: Date | null
    sector: string | null
    contact: string | null
    image: string | null
    published: boolean | null
    ownerId: string | null
    type: string | null
  }

  export type CaseStudyCountAggregateOutputType = {
    id: number
    title: number
    description: number
    authors: number
    category: number
    publishedDate: number
    lastModifiedOn: number
    createdOn: number
    sector: number
    contact: number
    image: number
    published: number
    ownerId: number
    type: number
    _all: number
  }


  export type CaseStudyAvgAggregateInputType = {
    id?: true
  }

  export type CaseStudySumAggregateInputType = {
    id?: true
  }

  export type CaseStudyMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    authors?: true
    category?: true
    publishedDate?: true
    lastModifiedOn?: true
    createdOn?: true
    sector?: true
    contact?: true
    image?: true
    published?: true
    ownerId?: true
    type?: true
  }

  export type CaseStudyMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    authors?: true
    category?: true
    publishedDate?: true
    lastModifiedOn?: true
    createdOn?: true
    sector?: true
    contact?: true
    image?: true
    published?: true
    ownerId?: true
    type?: true
  }

  export type CaseStudyCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    authors?: true
    category?: true
    publishedDate?: true
    lastModifiedOn?: true
    createdOn?: true
    sector?: true
    contact?: true
    image?: true
    published?: true
    ownerId?: true
    type?: true
    _all?: true
  }

  export type CaseStudyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudy to aggregate.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CaseStudies
    **/
    _count?: true | CaseStudyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: CaseStudyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: CaseStudySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CaseStudyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CaseStudyMaxAggregateInputType
  }

  export type GetCaseStudyAggregateType<T extends CaseStudyAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseStudy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseStudy[P]>
      : GetScalarType<T[P], AggregateCaseStudy[P]>
  }




  export type CaseStudyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyWhereInput
    orderBy?: CaseStudyOrderByWithAggregationInput | CaseStudyOrderByWithAggregationInput[]
    by: CaseStudyScalarFieldEnum[] | CaseStudyScalarFieldEnum
    having?: CaseStudyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseStudyCountAggregateInputType | true
    _avg?: CaseStudyAvgAggregateInputType
    _sum?: CaseStudySumAggregateInputType
    _min?: CaseStudyMinAggregateInputType
    _max?: CaseStudyMaxAggregateInputType
  }

  export type CaseStudyGroupByOutputType = {
    id: number
    title: string
    description: string | null
    authors: string | null
    category: string | null
    publishedDate: Date | null
    lastModifiedOn: Date
    createdOn: Date
    sector: string | null
    contact: string | null
    image: string | null
    published: boolean
    ownerId: string | null
    type: string | null
    _count: CaseStudyCountAggregateOutputType | null
    _avg: CaseStudyAvgAggregateOutputType | null
    _sum: CaseStudySumAggregateOutputType | null
    _min: CaseStudyMinAggregateOutputType | null
    _max: CaseStudyMaxAggregateOutputType | null
  }

  type GetCaseStudyGroupByPayload<T extends CaseStudyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseStudyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseStudyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseStudyGroupByOutputType[P]>
            : GetScalarType<T[P], CaseStudyGroupByOutputType[P]>
        }
      >
    >


  export type CaseStudySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    authors?: boolean
    category?: boolean
    publishedDate?: boolean
    lastModifiedOn?: boolean
    createdOn?: boolean
    sector?: boolean
    contact?: boolean
    image?: boolean
    published?: boolean
    ownerId?: boolean
    type?: boolean
    owner?: boolean | CaseStudy$ownerArgs<ExtArgs>
    publishedCases?: boolean | CaseStudy$publishedCasesArgs<ExtArgs>
    featureImage?: boolean | CaseStudy$featureImageArgs<ExtArgs>
    _count?: boolean | CaseStudyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudy"]>

  export type CaseStudySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    authors?: boolean
    category?: boolean
    publishedDate?: boolean
    lastModifiedOn?: boolean
    createdOn?: boolean
    sector?: boolean
    contact?: boolean
    image?: boolean
    published?: boolean
    ownerId?: boolean
    type?: boolean
    owner?: boolean | CaseStudy$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudy"]>

  export type CaseStudySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    authors?: boolean
    category?: boolean
    publishedDate?: boolean
    lastModifiedOn?: boolean
    createdOn?: boolean
    sector?: boolean
    contact?: boolean
    image?: boolean
    published?: boolean
    ownerId?: boolean
    type?: boolean
    owner?: boolean | CaseStudy$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudy"]>

  export type CaseStudySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    authors?: boolean
    category?: boolean
    publishedDate?: boolean
    lastModifiedOn?: boolean
    createdOn?: boolean
    sector?: boolean
    contact?: boolean
    image?: boolean
    published?: boolean
    ownerId?: boolean
    type?: boolean
  }

  export type CaseStudyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "authors" | "category" | "publishedDate" | "lastModifiedOn" | "createdOn" | "sector" | "contact" | "image" | "published" | "ownerId" | "type", ExtArgs["result"]["caseStudy"]>
  export type CaseStudyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | CaseStudy$ownerArgs<ExtArgs>
    publishedCases?: boolean | CaseStudy$publishedCasesArgs<ExtArgs>
    featureImage?: boolean | CaseStudy$featureImageArgs<ExtArgs>
    _count?: boolean | CaseStudyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CaseStudyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | CaseStudy$ownerArgs<ExtArgs>
  }
  export type CaseStudyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | CaseStudy$ownerArgs<ExtArgs>
  }

  export type $CaseStudyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseStudy"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs> | null
      publishedCases: Prisma.$CaseStudyPublishedCasePayload<ExtArgs>[]
      featureImage: Prisma.$CaseStudyImagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      authors: string | null
      category: string | null
      publishedDate: Date | null
      lastModifiedOn: Date
      createdOn: Date
      sector: string | null
      contact: string | null
      image: string | null
      published: boolean
      ownerId: string | null
      type: string | null
    }, ExtArgs["result"]["caseStudy"]>
    composites: {}
  }

  type CaseStudyGetPayload<S extends boolean | null | undefined | CaseStudyDefaultArgs> = $Result.GetResult<Prisma.$CaseStudyPayload, S>

  type CaseStudyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseStudyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseStudyCountAggregateInputType | true
    }

  export interface CaseStudyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseStudy'], meta: { name: 'CaseStudy' } }
    /**
     * Find zero or one CaseStudy that matches the filter.
     * @param {CaseStudyFindUniqueArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseStudyFindUniqueArgs>(args: SelectSubset<T, CaseStudyFindUniqueArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseStudy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseStudyFindUniqueOrThrowArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseStudyFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseStudyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyFindFirstArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseStudyFindFirstArgs>(args?: SelectSubset<T, CaseStudyFindFirstArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyFindFirstOrThrowArgs} args - Arguments to find a CaseStudy
     * @example
     * // Get one CaseStudy
     * const caseStudy = await prisma.caseStudy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseStudyFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseStudyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseStudies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseStudies
     * const caseStudies = await prisma.caseStudy.findMany()
     *
     * // Get first 10 CaseStudies
     * const caseStudies = await prisma.caseStudy.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const caseStudyWithIdOnly = await prisma.caseStudy.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CaseStudyFindManyArgs>(args?: SelectSubset<T, CaseStudyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseStudy.
     * @param {CaseStudyCreateArgs} args - Arguments to create a CaseStudy.
     * @example
     * // Create one CaseStudy
     * const CaseStudy = await prisma.caseStudy.create({
     *   data: {
     *     // ... data to create a CaseStudy
     *   }
     * })
     *
     */
    create<T extends CaseStudyCreateArgs>(args: SelectSubset<T, CaseStudyCreateArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseStudies.
     * @param {CaseStudyCreateManyArgs} args - Arguments to create many CaseStudies.
     * @example
     * // Create many CaseStudies
     * const caseStudy = await prisma.caseStudy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CaseStudyCreateManyArgs>(args?: SelectSubset<T, CaseStudyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseStudies and returns the data saved in the database.
     * @param {CaseStudyCreateManyAndReturnArgs} args - Arguments to create many CaseStudies.
     * @example
     * // Create many CaseStudies
     * const caseStudy = await prisma.caseStudy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CaseStudies and only return the `id`
     * const caseStudyWithIdOnly = await prisma.caseStudy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CaseStudyCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseStudyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseStudy.
     * @param {CaseStudyDeleteArgs} args - Arguments to delete one CaseStudy.
     * @example
     * // Delete one CaseStudy
     * const CaseStudy = await prisma.caseStudy.delete({
     *   where: {
     *     // ... filter to delete one CaseStudy
     *   }
     * })
     *
     */
    delete<T extends CaseStudyDeleteArgs>(args: SelectSubset<T, CaseStudyDeleteArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseStudy.
     * @param {CaseStudyUpdateArgs} args - Arguments to update one CaseStudy.
     * @example
     * // Update one CaseStudy
     * const caseStudy = await prisma.caseStudy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CaseStudyUpdateArgs>(args: SelectSubset<T, CaseStudyUpdateArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseStudies.
     * @param {CaseStudyDeleteManyArgs} args - Arguments to filter CaseStudies to delete.
     * @example
     * // Delete a few CaseStudies
     * const { count } = await prisma.caseStudy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CaseStudyDeleteManyArgs>(args?: SelectSubset<T, CaseStudyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseStudies
     * const caseStudy = await prisma.caseStudy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CaseStudyUpdateManyArgs>(args: SelectSubset<T, CaseStudyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseStudies and returns the data updated in the database.
     * @param {CaseStudyUpdateManyAndReturnArgs} args - Arguments to update many CaseStudies.
     * @example
     * // Update many CaseStudies
     * const caseStudy = await prisma.caseStudy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CaseStudies and only return the `id`
     * const caseStudyWithIdOnly = await prisma.caseStudy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CaseStudyUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseStudyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseStudy.
     * @param {CaseStudyUpsertArgs} args - Arguments to update or create a CaseStudy.
     * @example
     * // Update or create a CaseStudy
     * const caseStudy = await prisma.caseStudy.upsert({
     *   create: {
     *     // ... data to create a CaseStudy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseStudy we want to update
     *   }
     * })
     */
    upsert<T extends CaseStudyUpsertArgs>(args: SelectSubset<T, CaseStudyUpsertArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseStudies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyCountArgs} args - Arguments to filter CaseStudies to count.
     * @example
     * // Count the number of CaseStudies
     * const count = await prisma.caseStudy.count({
     *   where: {
     *     // ... the filter for the CaseStudies we want to count
     *   }
     * })
    **/
    count<T extends CaseStudyCountArgs>(
      args?: Subset<T, CaseStudyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseStudyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseStudyAggregateArgs>(args: Subset<T, CaseStudyAggregateArgs>): Prisma.PrismaPromise<GetCaseStudyAggregateType<T>>

    /**
     * Group by CaseStudy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CaseStudyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseStudyGroupByArgs['orderBy'] }
        : { orderBy?: CaseStudyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseStudyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseStudyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseStudy model
   */
  readonly fields: CaseStudyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseStudy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseStudyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends CaseStudy$ownerArgs<ExtArgs> = {}>(args?: Subset<T, CaseStudy$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    publishedCases<T extends CaseStudy$publishedCasesArgs<ExtArgs> = {}>(args?: Subset<T, CaseStudy$publishedCasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    featureImage<T extends CaseStudy$featureImageArgs<ExtArgs> = {}>(args?: Subset<T, CaseStudy$featureImageArgs<ExtArgs>>): Prisma__CaseStudyImageClient<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseStudy model
   */
  interface CaseStudyFieldRefs {
    readonly id: FieldRef<"CaseStudy", 'Int'>
    readonly title: FieldRef<"CaseStudy", 'String'>
    readonly description: FieldRef<"CaseStudy", 'String'>
    readonly authors: FieldRef<"CaseStudy", 'String'>
    readonly category: FieldRef<"CaseStudy", 'String'>
    readonly publishedDate: FieldRef<"CaseStudy", 'DateTime'>
    readonly lastModifiedOn: FieldRef<"CaseStudy", 'DateTime'>
    readonly createdOn: FieldRef<"CaseStudy", 'DateTime'>
    readonly sector: FieldRef<"CaseStudy", 'String'>
    readonly contact: FieldRef<"CaseStudy", 'String'>
    readonly image: FieldRef<"CaseStudy", 'String'>
    readonly published: FieldRef<"CaseStudy", 'Boolean'>
    readonly ownerId: FieldRef<"CaseStudy", 'String'>
    readonly type: FieldRef<"CaseStudy", 'String'>
  }


  // Custom InputTypes
  /**
   * CaseStudy findUnique
   */
  export type CaseStudyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy findUniqueOrThrow
   */
  export type CaseStudyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy findFirst
   */
  export type CaseStudyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseStudies.
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseStudies.
     */
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * CaseStudy findFirstOrThrow
   */
  export type CaseStudyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudy to fetch.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseStudies.
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseStudies.
     */
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * CaseStudy findMany
   */
  export type CaseStudyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudies to fetch.
     */
    where?: CaseStudyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudies to fetch.
     */
    orderBy?: CaseStudyOrderByWithRelationInput | CaseStudyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CaseStudies.
     */
    cursor?: CaseStudyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudies.
     */
    skip?: number
    distinct?: CaseStudyScalarFieldEnum | CaseStudyScalarFieldEnum[]
  }

  /**
   * CaseStudy create
   */
  export type CaseStudyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseStudy.
     */
    data: XOR<CaseStudyCreateInput, CaseStudyUncheckedCreateInput>
  }

  /**
   * CaseStudy createMany
   */
  export type CaseStudyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseStudies.
     */
    data: CaseStudyCreateManyInput | CaseStudyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseStudy createManyAndReturn
   */
  export type CaseStudyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * The data used to create many CaseStudies.
     */
    data: CaseStudyCreateManyInput | CaseStudyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseStudy update
   */
  export type CaseStudyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseStudy.
     */
    data: XOR<CaseStudyUpdateInput, CaseStudyUncheckedUpdateInput>
    /**
     * Choose, which CaseStudy to update.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy updateMany
   */
  export type CaseStudyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseStudies.
     */
    data: XOR<CaseStudyUpdateManyMutationInput, CaseStudyUncheckedUpdateManyInput>
    /**
     * Filter which CaseStudies to update
     */
    where?: CaseStudyWhereInput
    /**
     * Limit how many CaseStudies to update.
     */
    limit?: number
  }

  /**
   * CaseStudy updateManyAndReturn
   */
  export type CaseStudyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * The data used to update CaseStudies.
     */
    data: XOR<CaseStudyUpdateManyMutationInput, CaseStudyUncheckedUpdateManyInput>
    /**
     * Filter which CaseStudies to update
     */
    where?: CaseStudyWhereInput
    /**
     * Limit how many CaseStudies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseStudy upsert
   */
  export type CaseStudyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseStudy to update in case it exists.
     */
    where: CaseStudyWhereUniqueInput
    /**
     * In case the CaseStudy found by the `where` argument doesn't exist, create a new CaseStudy with this data.
     */
    create: XOR<CaseStudyCreateInput, CaseStudyUncheckedCreateInput>
    /**
     * In case the CaseStudy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseStudyUpdateInput, CaseStudyUncheckedUpdateInput>
  }

  /**
   * CaseStudy delete
   */
  export type CaseStudyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
    /**
     * Filter which CaseStudy to delete.
     */
    where: CaseStudyWhereUniqueInput
  }

  /**
   * CaseStudy deleteMany
   */
  export type CaseStudyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudies to delete
     */
    where?: CaseStudyWhereInput
    /**
     * Limit how many CaseStudies to delete.
     */
    limit?: number
  }

  /**
   * CaseStudy.owner
   */
  export type CaseStudy$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * CaseStudy.publishedCases
   */
  export type CaseStudy$publishedCasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    where?: CaseStudyPublishedCaseWhereInput
    orderBy?: CaseStudyPublishedCaseOrderByWithRelationInput | CaseStudyPublishedCaseOrderByWithRelationInput[]
    cursor?: CaseStudyPublishedCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseStudyPublishedCaseScalarFieldEnum | CaseStudyPublishedCaseScalarFieldEnum[]
  }

  /**
   * CaseStudy.featureImage
   */
  export type CaseStudy$featureImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    where?: CaseStudyImageWhereInput
  }

  /**
   * CaseStudy without action
   */
  export type CaseStudyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudy
     */
    select?: CaseStudySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudy
     */
    omit?: CaseStudyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyInclude<ExtArgs> | null
  }


  /**
   * Model CaseStudyPublishedCase
   */

  export type AggregateCaseStudyPublishedCase = {
    _count: CaseStudyPublishedCaseCountAggregateOutputType | null
    _avg: CaseStudyPublishedCaseAvgAggregateOutputType | null
    _sum: CaseStudyPublishedCaseSumAggregateOutputType | null
    _min: CaseStudyPublishedCaseMinAggregateOutputType | null
    _max: CaseStudyPublishedCaseMaxAggregateOutputType | null
  }

  export type CaseStudyPublishedCaseAvgAggregateOutputType = {
    id: number | null
    caseStudyId: number | null
  }

  export type CaseStudyPublishedCaseSumAggregateOutputType = {
    id: bigint | null
    caseStudyId: number | null
  }

  export type CaseStudyPublishedCaseMinAggregateOutputType = {
    id: bigint | null
    caseStudyId: number | null
    publishedAssuranceCaseId: string | null
  }

  export type CaseStudyPublishedCaseMaxAggregateOutputType = {
    id: bigint | null
    caseStudyId: number | null
    publishedAssuranceCaseId: string | null
  }

  export type CaseStudyPublishedCaseCountAggregateOutputType = {
    id: number
    caseStudyId: number
    publishedAssuranceCaseId: number
    _all: number
  }


  export type CaseStudyPublishedCaseAvgAggregateInputType = {
    id?: true
    caseStudyId?: true
  }

  export type CaseStudyPublishedCaseSumAggregateInputType = {
    id?: true
    caseStudyId?: true
  }

  export type CaseStudyPublishedCaseMinAggregateInputType = {
    id?: true
    caseStudyId?: true
    publishedAssuranceCaseId?: true
  }

  export type CaseStudyPublishedCaseMaxAggregateInputType = {
    id?: true
    caseStudyId?: true
    publishedAssuranceCaseId?: true
  }

  export type CaseStudyPublishedCaseCountAggregateInputType = {
    id?: true
    caseStudyId?: true
    publishedAssuranceCaseId?: true
    _all?: true
  }

  export type CaseStudyPublishedCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudyPublishedCase to aggregate.
     */
    where?: CaseStudyPublishedCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudyPublishedCases to fetch.
     */
    orderBy?: CaseStudyPublishedCaseOrderByWithRelationInput | CaseStudyPublishedCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CaseStudyPublishedCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudyPublishedCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudyPublishedCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CaseStudyPublishedCases
    **/
    _count?: true | CaseStudyPublishedCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: CaseStudyPublishedCaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: CaseStudyPublishedCaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CaseStudyPublishedCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CaseStudyPublishedCaseMaxAggregateInputType
  }

  export type GetCaseStudyPublishedCaseAggregateType<T extends CaseStudyPublishedCaseAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseStudyPublishedCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseStudyPublishedCase[P]>
      : GetScalarType<T[P], AggregateCaseStudyPublishedCase[P]>
  }




  export type CaseStudyPublishedCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyPublishedCaseWhereInput
    orderBy?: CaseStudyPublishedCaseOrderByWithAggregationInput | CaseStudyPublishedCaseOrderByWithAggregationInput[]
    by: CaseStudyPublishedCaseScalarFieldEnum[] | CaseStudyPublishedCaseScalarFieldEnum
    having?: CaseStudyPublishedCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseStudyPublishedCaseCountAggregateInputType | true
    _avg?: CaseStudyPublishedCaseAvgAggregateInputType
    _sum?: CaseStudyPublishedCaseSumAggregateInputType
    _min?: CaseStudyPublishedCaseMinAggregateInputType
    _max?: CaseStudyPublishedCaseMaxAggregateInputType
  }

  export type CaseStudyPublishedCaseGroupByOutputType = {
    id: bigint
    caseStudyId: number
    publishedAssuranceCaseId: string
    _count: CaseStudyPublishedCaseCountAggregateOutputType | null
    _avg: CaseStudyPublishedCaseAvgAggregateOutputType | null
    _sum: CaseStudyPublishedCaseSumAggregateOutputType | null
    _min: CaseStudyPublishedCaseMinAggregateOutputType | null
    _max: CaseStudyPublishedCaseMaxAggregateOutputType | null
  }

  type GetCaseStudyPublishedCaseGroupByPayload<T extends CaseStudyPublishedCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseStudyPublishedCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseStudyPublishedCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseStudyPublishedCaseGroupByOutputType[P]>
            : GetScalarType<T[P], CaseStudyPublishedCaseGroupByOutputType[P]>
        }
      >
    >


  export type CaseStudyPublishedCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseStudyId?: boolean
    publishedAssuranceCaseId?: boolean
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
    publishedAssuranceCase?: boolean | PublishedAssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudyPublishedCase"]>

  export type CaseStudyPublishedCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseStudyId?: boolean
    publishedAssuranceCaseId?: boolean
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
    publishedAssuranceCase?: boolean | PublishedAssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudyPublishedCase"]>

  export type CaseStudyPublishedCaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    caseStudyId?: boolean
    publishedAssuranceCaseId?: boolean
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
    publishedAssuranceCase?: boolean | PublishedAssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudyPublishedCase"]>

  export type CaseStudyPublishedCaseSelectScalar = {
    id?: boolean
    caseStudyId?: boolean
    publishedAssuranceCaseId?: boolean
  }

  export type CaseStudyPublishedCaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "caseStudyId" | "publishedAssuranceCaseId", ExtArgs["result"]["caseStudyPublishedCase"]>
  export type CaseStudyPublishedCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
    publishedAssuranceCase?: boolean | PublishedAssuranceCaseDefaultArgs<ExtArgs>
  }
  export type CaseStudyPublishedCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
    publishedAssuranceCase?: boolean | PublishedAssuranceCaseDefaultArgs<ExtArgs>
  }
  export type CaseStudyPublishedCaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
    publishedAssuranceCase?: boolean | PublishedAssuranceCaseDefaultArgs<ExtArgs>
  }

  export type $CaseStudyPublishedCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseStudyPublishedCase"
    objects: {
      caseStudy: Prisma.$CaseStudyPayload<ExtArgs>
      publishedAssuranceCase: Prisma.$PublishedAssuranceCasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      caseStudyId: number
      publishedAssuranceCaseId: string
    }, ExtArgs["result"]["caseStudyPublishedCase"]>
    composites: {}
  }

  type CaseStudyPublishedCaseGetPayload<S extends boolean | null | undefined | CaseStudyPublishedCaseDefaultArgs> = $Result.GetResult<Prisma.$CaseStudyPublishedCasePayload, S>

  type CaseStudyPublishedCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseStudyPublishedCaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseStudyPublishedCaseCountAggregateInputType | true
    }

  export interface CaseStudyPublishedCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseStudyPublishedCase'], meta: { name: 'CaseStudyPublishedCase' } }
    /**
     * Find zero or one CaseStudyPublishedCase that matches the filter.
     * @param {CaseStudyPublishedCaseFindUniqueArgs} args - Arguments to find a CaseStudyPublishedCase
     * @example
     * // Get one CaseStudyPublishedCase
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseStudyPublishedCaseFindUniqueArgs>(args: SelectSubset<T, CaseStudyPublishedCaseFindUniqueArgs<ExtArgs>>): Prisma__CaseStudyPublishedCaseClient<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseStudyPublishedCase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseStudyPublishedCaseFindUniqueOrThrowArgs} args - Arguments to find a CaseStudyPublishedCase
     * @example
     * // Get one CaseStudyPublishedCase
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseStudyPublishedCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseStudyPublishedCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseStudyPublishedCaseClient<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudyPublishedCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyPublishedCaseFindFirstArgs} args - Arguments to find a CaseStudyPublishedCase
     * @example
     * // Get one CaseStudyPublishedCase
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseStudyPublishedCaseFindFirstArgs>(args?: SelectSubset<T, CaseStudyPublishedCaseFindFirstArgs<ExtArgs>>): Prisma__CaseStudyPublishedCaseClient<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudyPublishedCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyPublishedCaseFindFirstOrThrowArgs} args - Arguments to find a CaseStudyPublishedCase
     * @example
     * // Get one CaseStudyPublishedCase
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseStudyPublishedCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseStudyPublishedCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseStudyPublishedCaseClient<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseStudyPublishedCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyPublishedCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseStudyPublishedCases
     * const caseStudyPublishedCases = await prisma.caseStudyPublishedCase.findMany()
     *
     * // Get first 10 CaseStudyPublishedCases
     * const caseStudyPublishedCases = await prisma.caseStudyPublishedCase.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const caseStudyPublishedCaseWithIdOnly = await prisma.caseStudyPublishedCase.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CaseStudyPublishedCaseFindManyArgs>(args?: SelectSubset<T, CaseStudyPublishedCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseStudyPublishedCase.
     * @param {CaseStudyPublishedCaseCreateArgs} args - Arguments to create a CaseStudyPublishedCase.
     * @example
     * // Create one CaseStudyPublishedCase
     * const CaseStudyPublishedCase = await prisma.caseStudyPublishedCase.create({
     *   data: {
     *     // ... data to create a CaseStudyPublishedCase
     *   }
     * })
     *
     */
    create<T extends CaseStudyPublishedCaseCreateArgs>(args: SelectSubset<T, CaseStudyPublishedCaseCreateArgs<ExtArgs>>): Prisma__CaseStudyPublishedCaseClient<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseStudyPublishedCases.
     * @param {CaseStudyPublishedCaseCreateManyArgs} args - Arguments to create many CaseStudyPublishedCases.
     * @example
     * // Create many CaseStudyPublishedCases
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CaseStudyPublishedCaseCreateManyArgs>(args?: SelectSubset<T, CaseStudyPublishedCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseStudyPublishedCases and returns the data saved in the database.
     * @param {CaseStudyPublishedCaseCreateManyAndReturnArgs} args - Arguments to create many CaseStudyPublishedCases.
     * @example
     * // Create many CaseStudyPublishedCases
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CaseStudyPublishedCases and only return the `id`
     * const caseStudyPublishedCaseWithIdOnly = await prisma.caseStudyPublishedCase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CaseStudyPublishedCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseStudyPublishedCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseStudyPublishedCase.
     * @param {CaseStudyPublishedCaseDeleteArgs} args - Arguments to delete one CaseStudyPublishedCase.
     * @example
     * // Delete one CaseStudyPublishedCase
     * const CaseStudyPublishedCase = await prisma.caseStudyPublishedCase.delete({
     *   where: {
     *     // ... filter to delete one CaseStudyPublishedCase
     *   }
     * })
     *
     */
    delete<T extends CaseStudyPublishedCaseDeleteArgs>(args: SelectSubset<T, CaseStudyPublishedCaseDeleteArgs<ExtArgs>>): Prisma__CaseStudyPublishedCaseClient<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseStudyPublishedCase.
     * @param {CaseStudyPublishedCaseUpdateArgs} args - Arguments to update one CaseStudyPublishedCase.
     * @example
     * // Update one CaseStudyPublishedCase
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CaseStudyPublishedCaseUpdateArgs>(args: SelectSubset<T, CaseStudyPublishedCaseUpdateArgs<ExtArgs>>): Prisma__CaseStudyPublishedCaseClient<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseStudyPublishedCases.
     * @param {CaseStudyPublishedCaseDeleteManyArgs} args - Arguments to filter CaseStudyPublishedCases to delete.
     * @example
     * // Delete a few CaseStudyPublishedCases
     * const { count } = await prisma.caseStudyPublishedCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CaseStudyPublishedCaseDeleteManyArgs>(args?: SelectSubset<T, CaseStudyPublishedCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseStudyPublishedCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyPublishedCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseStudyPublishedCases
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CaseStudyPublishedCaseUpdateManyArgs>(args: SelectSubset<T, CaseStudyPublishedCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseStudyPublishedCases and returns the data updated in the database.
     * @param {CaseStudyPublishedCaseUpdateManyAndReturnArgs} args - Arguments to update many CaseStudyPublishedCases.
     * @example
     * // Update many CaseStudyPublishedCases
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CaseStudyPublishedCases and only return the `id`
     * const caseStudyPublishedCaseWithIdOnly = await prisma.caseStudyPublishedCase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CaseStudyPublishedCaseUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseStudyPublishedCaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseStudyPublishedCase.
     * @param {CaseStudyPublishedCaseUpsertArgs} args - Arguments to update or create a CaseStudyPublishedCase.
     * @example
     * // Update or create a CaseStudyPublishedCase
     * const caseStudyPublishedCase = await prisma.caseStudyPublishedCase.upsert({
     *   create: {
     *     // ... data to create a CaseStudyPublishedCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseStudyPublishedCase we want to update
     *   }
     * })
     */
    upsert<T extends CaseStudyPublishedCaseUpsertArgs>(args: SelectSubset<T, CaseStudyPublishedCaseUpsertArgs<ExtArgs>>): Prisma__CaseStudyPublishedCaseClient<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseStudyPublishedCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyPublishedCaseCountArgs} args - Arguments to filter CaseStudyPublishedCases to count.
     * @example
     * // Count the number of CaseStudyPublishedCases
     * const count = await prisma.caseStudyPublishedCase.count({
     *   where: {
     *     // ... the filter for the CaseStudyPublishedCases we want to count
     *   }
     * })
    **/
    count<T extends CaseStudyPublishedCaseCountArgs>(
      args?: Subset<T, CaseStudyPublishedCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseStudyPublishedCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseStudyPublishedCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyPublishedCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseStudyPublishedCaseAggregateArgs>(args: Subset<T, CaseStudyPublishedCaseAggregateArgs>): Prisma.PrismaPromise<GetCaseStudyPublishedCaseAggregateType<T>>

    /**
     * Group by CaseStudyPublishedCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyPublishedCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CaseStudyPublishedCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseStudyPublishedCaseGroupByArgs['orderBy'] }
        : { orderBy?: CaseStudyPublishedCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseStudyPublishedCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseStudyPublishedCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseStudyPublishedCase model
   */
  readonly fields: CaseStudyPublishedCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseStudyPublishedCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseStudyPublishedCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caseStudy<T extends CaseStudyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaseStudyDefaultArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publishedAssuranceCase<T extends PublishedAssuranceCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublishedAssuranceCaseDefaultArgs<ExtArgs>>): Prisma__PublishedAssuranceCaseClient<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseStudyPublishedCase model
   */
  interface CaseStudyPublishedCaseFieldRefs {
    readonly id: FieldRef<"CaseStudyPublishedCase", 'BigInt'>
    readonly caseStudyId: FieldRef<"CaseStudyPublishedCase", 'Int'>
    readonly publishedAssuranceCaseId: FieldRef<"CaseStudyPublishedCase", 'String'>
  }


  // Custom InputTypes
  /**
   * CaseStudyPublishedCase findUnique
   */
  export type CaseStudyPublishedCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyPublishedCase to fetch.
     */
    where: CaseStudyPublishedCaseWhereUniqueInput
  }

  /**
   * CaseStudyPublishedCase findUniqueOrThrow
   */
  export type CaseStudyPublishedCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyPublishedCase to fetch.
     */
    where: CaseStudyPublishedCaseWhereUniqueInput
  }

  /**
   * CaseStudyPublishedCase findFirst
   */
  export type CaseStudyPublishedCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyPublishedCase to fetch.
     */
    where?: CaseStudyPublishedCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudyPublishedCases to fetch.
     */
    orderBy?: CaseStudyPublishedCaseOrderByWithRelationInput | CaseStudyPublishedCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseStudyPublishedCases.
     */
    cursor?: CaseStudyPublishedCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudyPublishedCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudyPublishedCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseStudyPublishedCases.
     */
    distinct?: CaseStudyPublishedCaseScalarFieldEnum | CaseStudyPublishedCaseScalarFieldEnum[]
  }

  /**
   * CaseStudyPublishedCase findFirstOrThrow
   */
  export type CaseStudyPublishedCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyPublishedCase to fetch.
     */
    where?: CaseStudyPublishedCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudyPublishedCases to fetch.
     */
    orderBy?: CaseStudyPublishedCaseOrderByWithRelationInput | CaseStudyPublishedCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseStudyPublishedCases.
     */
    cursor?: CaseStudyPublishedCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudyPublishedCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudyPublishedCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseStudyPublishedCases.
     */
    distinct?: CaseStudyPublishedCaseScalarFieldEnum | CaseStudyPublishedCaseScalarFieldEnum[]
  }

  /**
   * CaseStudyPublishedCase findMany
   */
  export type CaseStudyPublishedCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyPublishedCases to fetch.
     */
    where?: CaseStudyPublishedCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudyPublishedCases to fetch.
     */
    orderBy?: CaseStudyPublishedCaseOrderByWithRelationInput | CaseStudyPublishedCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CaseStudyPublishedCases.
     */
    cursor?: CaseStudyPublishedCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudyPublishedCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudyPublishedCases.
     */
    skip?: number
    distinct?: CaseStudyPublishedCaseScalarFieldEnum | CaseStudyPublishedCaseScalarFieldEnum[]
  }

  /**
   * CaseStudyPublishedCase create
   */
  export type CaseStudyPublishedCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseStudyPublishedCase.
     */
    data: XOR<CaseStudyPublishedCaseCreateInput, CaseStudyPublishedCaseUncheckedCreateInput>
  }

  /**
   * CaseStudyPublishedCase createMany
   */
  export type CaseStudyPublishedCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseStudyPublishedCases.
     */
    data: CaseStudyPublishedCaseCreateManyInput | CaseStudyPublishedCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseStudyPublishedCase createManyAndReturn
   */
  export type CaseStudyPublishedCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * The data used to create many CaseStudyPublishedCases.
     */
    data: CaseStudyPublishedCaseCreateManyInput | CaseStudyPublishedCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseStudyPublishedCase update
   */
  export type CaseStudyPublishedCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseStudyPublishedCase.
     */
    data: XOR<CaseStudyPublishedCaseUpdateInput, CaseStudyPublishedCaseUncheckedUpdateInput>
    /**
     * Choose, which CaseStudyPublishedCase to update.
     */
    where: CaseStudyPublishedCaseWhereUniqueInput
  }

  /**
   * CaseStudyPublishedCase updateMany
   */
  export type CaseStudyPublishedCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseStudyPublishedCases.
     */
    data: XOR<CaseStudyPublishedCaseUpdateManyMutationInput, CaseStudyPublishedCaseUncheckedUpdateManyInput>
    /**
     * Filter which CaseStudyPublishedCases to update
     */
    where?: CaseStudyPublishedCaseWhereInput
    /**
     * Limit how many CaseStudyPublishedCases to update.
     */
    limit?: number
  }

  /**
   * CaseStudyPublishedCase updateManyAndReturn
   */
  export type CaseStudyPublishedCaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * The data used to update CaseStudyPublishedCases.
     */
    data: XOR<CaseStudyPublishedCaseUpdateManyMutationInput, CaseStudyPublishedCaseUncheckedUpdateManyInput>
    /**
     * Filter which CaseStudyPublishedCases to update
     */
    where?: CaseStudyPublishedCaseWhereInput
    /**
     * Limit how many CaseStudyPublishedCases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseStudyPublishedCase upsert
   */
  export type CaseStudyPublishedCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseStudyPublishedCase to update in case it exists.
     */
    where: CaseStudyPublishedCaseWhereUniqueInput
    /**
     * In case the CaseStudyPublishedCase found by the `where` argument doesn't exist, create a new CaseStudyPublishedCase with this data.
     */
    create: XOR<CaseStudyPublishedCaseCreateInput, CaseStudyPublishedCaseUncheckedCreateInput>
    /**
     * In case the CaseStudyPublishedCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseStudyPublishedCaseUpdateInput, CaseStudyPublishedCaseUncheckedUpdateInput>
  }

  /**
   * CaseStudyPublishedCase delete
   */
  export type CaseStudyPublishedCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    /**
     * Filter which CaseStudyPublishedCase to delete.
     */
    where: CaseStudyPublishedCaseWhereUniqueInput
  }

  /**
   * CaseStudyPublishedCase deleteMany
   */
  export type CaseStudyPublishedCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudyPublishedCases to delete
     */
    where?: CaseStudyPublishedCaseWhereInput
    /**
     * Limit how many CaseStudyPublishedCases to delete.
     */
    limit?: number
  }

  /**
   * CaseStudyPublishedCase without action
   */
  export type CaseStudyPublishedCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
  }


  /**
   * Model CaseStudyImage
   */

  export type AggregateCaseStudyImage = {
    _count: CaseStudyImageCountAggregateOutputType | null
    _avg: CaseStudyImageAvgAggregateOutputType | null
    _sum: CaseStudyImageSumAggregateOutputType | null
    _min: CaseStudyImageMinAggregateOutputType | null
    _max: CaseStudyImageMaxAggregateOutputType | null
  }

  export type CaseStudyImageAvgAggregateOutputType = {
    id: number | null
    caseStudyId: number | null
  }

  export type CaseStudyImageSumAggregateOutputType = {
    id: bigint | null
    caseStudyId: number | null
  }

  export type CaseStudyImageMinAggregateOutputType = {
    id: bigint | null
    image: string | null
    uploadedAt: Date | null
    caseStudyId: number | null
  }

  export type CaseStudyImageMaxAggregateOutputType = {
    id: bigint | null
    image: string | null
    uploadedAt: Date | null
    caseStudyId: number | null
  }

  export type CaseStudyImageCountAggregateOutputType = {
    id: number
    image: number
    uploadedAt: number
    caseStudyId: number
    _all: number
  }


  export type CaseStudyImageAvgAggregateInputType = {
    id?: true
    caseStudyId?: true
  }

  export type CaseStudyImageSumAggregateInputType = {
    id?: true
    caseStudyId?: true
  }

  export type CaseStudyImageMinAggregateInputType = {
    id?: true
    image?: true
    uploadedAt?: true
    caseStudyId?: true
  }

  export type CaseStudyImageMaxAggregateInputType = {
    id?: true
    image?: true
    uploadedAt?: true
    caseStudyId?: true
  }

  export type CaseStudyImageCountAggregateInputType = {
    id?: true
    image?: true
    uploadedAt?: true
    caseStudyId?: true
    _all?: true
  }

  export type CaseStudyImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudyImage to aggregate.
     */
    where?: CaseStudyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudyImages to fetch.
     */
    orderBy?: CaseStudyImageOrderByWithRelationInput | CaseStudyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CaseStudyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudyImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CaseStudyImages
    **/
    _count?: true | CaseStudyImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: CaseStudyImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: CaseStudyImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: CaseStudyImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: CaseStudyImageMaxAggregateInputType
  }

  export type GetCaseStudyImageAggregateType<T extends CaseStudyImageAggregateArgs> = {
        [P in keyof T & keyof AggregateCaseStudyImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCaseStudyImage[P]>
      : GetScalarType<T[P], AggregateCaseStudyImage[P]>
  }




  export type CaseStudyImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CaseStudyImageWhereInput
    orderBy?: CaseStudyImageOrderByWithAggregationInput | CaseStudyImageOrderByWithAggregationInput[]
    by: CaseStudyImageScalarFieldEnum[] | CaseStudyImageScalarFieldEnum
    having?: CaseStudyImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CaseStudyImageCountAggregateInputType | true
    _avg?: CaseStudyImageAvgAggregateInputType
    _sum?: CaseStudyImageSumAggregateInputType
    _min?: CaseStudyImageMinAggregateInputType
    _max?: CaseStudyImageMaxAggregateInputType
  }

  export type CaseStudyImageGroupByOutputType = {
    id: bigint
    image: string
    uploadedAt: Date
    caseStudyId: number
    _count: CaseStudyImageCountAggregateOutputType | null
    _avg: CaseStudyImageAvgAggregateOutputType | null
    _sum: CaseStudyImageSumAggregateOutputType | null
    _min: CaseStudyImageMinAggregateOutputType | null
    _max: CaseStudyImageMaxAggregateOutputType | null
  }

  type GetCaseStudyImageGroupByPayload<T extends CaseStudyImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CaseStudyImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CaseStudyImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CaseStudyImageGroupByOutputType[P]>
            : GetScalarType<T[P], CaseStudyImageGroupByOutputType[P]>
        }
      >
    >


  export type CaseStudyImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    uploadedAt?: boolean
    caseStudyId?: boolean
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudyImage"]>

  export type CaseStudyImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    uploadedAt?: boolean
    caseStudyId?: boolean
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudyImage"]>

  export type CaseStudyImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    uploadedAt?: boolean
    caseStudyId?: boolean
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["caseStudyImage"]>

  export type CaseStudyImageSelectScalar = {
    id?: boolean
    image?: boolean
    uploadedAt?: boolean
    caseStudyId?: boolean
  }

  export type CaseStudyImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "uploadedAt" | "caseStudyId", ExtArgs["result"]["caseStudyImage"]>
  export type CaseStudyImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
  }
  export type CaseStudyImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
  }
  export type CaseStudyImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    caseStudy?: boolean | CaseStudyDefaultArgs<ExtArgs>
  }

  export type $CaseStudyImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CaseStudyImage"
    objects: {
      caseStudy: Prisma.$CaseStudyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      image: string
      uploadedAt: Date
      caseStudyId: number
    }, ExtArgs["result"]["caseStudyImage"]>
    composites: {}
  }

  type CaseStudyImageGetPayload<S extends boolean | null | undefined | CaseStudyImageDefaultArgs> = $Result.GetResult<Prisma.$CaseStudyImagePayload, S>

  type CaseStudyImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CaseStudyImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CaseStudyImageCountAggregateInputType | true
    }

  export interface CaseStudyImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CaseStudyImage'], meta: { name: 'CaseStudyImage' } }
    /**
     * Find zero or one CaseStudyImage that matches the filter.
     * @param {CaseStudyImageFindUniqueArgs} args - Arguments to find a CaseStudyImage
     * @example
     * // Get one CaseStudyImage
     * const caseStudyImage = await prisma.caseStudyImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CaseStudyImageFindUniqueArgs>(args: SelectSubset<T, CaseStudyImageFindUniqueArgs<ExtArgs>>): Prisma__CaseStudyImageClient<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CaseStudyImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CaseStudyImageFindUniqueOrThrowArgs} args - Arguments to find a CaseStudyImage
     * @example
     * // Get one CaseStudyImage
     * const caseStudyImage = await prisma.caseStudyImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CaseStudyImageFindUniqueOrThrowArgs>(args: SelectSubset<T, CaseStudyImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CaseStudyImageClient<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudyImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyImageFindFirstArgs} args - Arguments to find a CaseStudyImage
     * @example
     * // Get one CaseStudyImage
     * const caseStudyImage = await prisma.caseStudyImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CaseStudyImageFindFirstArgs>(args?: SelectSubset<T, CaseStudyImageFindFirstArgs<ExtArgs>>): Prisma__CaseStudyImageClient<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CaseStudyImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyImageFindFirstOrThrowArgs} args - Arguments to find a CaseStudyImage
     * @example
     * // Get one CaseStudyImage
     * const caseStudyImage = await prisma.caseStudyImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CaseStudyImageFindFirstOrThrowArgs>(args?: SelectSubset<T, CaseStudyImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CaseStudyImageClient<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CaseStudyImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CaseStudyImages
     * const caseStudyImages = await prisma.caseStudyImage.findMany()
     *
     * // Get first 10 CaseStudyImages
     * const caseStudyImages = await prisma.caseStudyImage.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const caseStudyImageWithIdOnly = await prisma.caseStudyImage.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CaseStudyImageFindManyArgs>(args?: SelectSubset<T, CaseStudyImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CaseStudyImage.
     * @param {CaseStudyImageCreateArgs} args - Arguments to create a CaseStudyImage.
     * @example
     * // Create one CaseStudyImage
     * const CaseStudyImage = await prisma.caseStudyImage.create({
     *   data: {
     *     // ... data to create a CaseStudyImage
     *   }
     * })
     *
     */
    create<T extends CaseStudyImageCreateArgs>(args: SelectSubset<T, CaseStudyImageCreateArgs<ExtArgs>>): Prisma__CaseStudyImageClient<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CaseStudyImages.
     * @param {CaseStudyImageCreateManyArgs} args - Arguments to create many CaseStudyImages.
     * @example
     * // Create many CaseStudyImages
     * const caseStudyImage = await prisma.caseStudyImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CaseStudyImageCreateManyArgs>(args?: SelectSubset<T, CaseStudyImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CaseStudyImages and returns the data saved in the database.
     * @param {CaseStudyImageCreateManyAndReturnArgs} args - Arguments to create many CaseStudyImages.
     * @example
     * // Create many CaseStudyImages
     * const caseStudyImage = await prisma.caseStudyImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many CaseStudyImages and only return the `id`
     * const caseStudyImageWithIdOnly = await prisma.caseStudyImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends CaseStudyImageCreateManyAndReturnArgs>(args?: SelectSubset<T, CaseStudyImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CaseStudyImage.
     * @param {CaseStudyImageDeleteArgs} args - Arguments to delete one CaseStudyImage.
     * @example
     * // Delete one CaseStudyImage
     * const CaseStudyImage = await prisma.caseStudyImage.delete({
     *   where: {
     *     // ... filter to delete one CaseStudyImage
     *   }
     * })
     *
     */
    delete<T extends CaseStudyImageDeleteArgs>(args: SelectSubset<T, CaseStudyImageDeleteArgs<ExtArgs>>): Prisma__CaseStudyImageClient<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CaseStudyImage.
     * @param {CaseStudyImageUpdateArgs} args - Arguments to update one CaseStudyImage.
     * @example
     * // Update one CaseStudyImage
     * const caseStudyImage = await prisma.caseStudyImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CaseStudyImageUpdateArgs>(args: SelectSubset<T, CaseStudyImageUpdateArgs<ExtArgs>>): Prisma__CaseStudyImageClient<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CaseStudyImages.
     * @param {CaseStudyImageDeleteManyArgs} args - Arguments to filter CaseStudyImages to delete.
     * @example
     * // Delete a few CaseStudyImages
     * const { count } = await prisma.caseStudyImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CaseStudyImageDeleteManyArgs>(args?: SelectSubset<T, CaseStudyImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseStudyImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CaseStudyImages
     * const caseStudyImage = await prisma.caseStudyImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CaseStudyImageUpdateManyArgs>(args: SelectSubset<T, CaseStudyImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CaseStudyImages and returns the data updated in the database.
     * @param {CaseStudyImageUpdateManyAndReturnArgs} args - Arguments to update many CaseStudyImages.
     * @example
     * // Update many CaseStudyImages
     * const caseStudyImage = await prisma.caseStudyImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more CaseStudyImages and only return the `id`
     * const caseStudyImageWithIdOnly = await prisma.caseStudyImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends CaseStudyImageUpdateManyAndReturnArgs>(args: SelectSubset<T, CaseStudyImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CaseStudyImage.
     * @param {CaseStudyImageUpsertArgs} args - Arguments to update or create a CaseStudyImage.
     * @example
     * // Update or create a CaseStudyImage
     * const caseStudyImage = await prisma.caseStudyImage.upsert({
     *   create: {
     *     // ... data to create a CaseStudyImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CaseStudyImage we want to update
     *   }
     * })
     */
    upsert<T extends CaseStudyImageUpsertArgs>(args: SelectSubset<T, CaseStudyImageUpsertArgs<ExtArgs>>): Prisma__CaseStudyImageClient<$Result.GetResult<Prisma.$CaseStudyImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CaseStudyImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyImageCountArgs} args - Arguments to filter CaseStudyImages to count.
     * @example
     * // Count the number of CaseStudyImages
     * const count = await prisma.caseStudyImage.count({
     *   where: {
     *     // ... the filter for the CaseStudyImages we want to count
     *   }
     * })
    **/
    count<T extends CaseStudyImageCountArgs>(
      args?: Subset<T, CaseStudyImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CaseStudyImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CaseStudyImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CaseStudyImageAggregateArgs>(args: Subset<T, CaseStudyImageAggregateArgs>): Prisma.PrismaPromise<GetCaseStudyImageAggregateType<T>>

    /**
     * Group by CaseStudyImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CaseStudyImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends CaseStudyImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CaseStudyImageGroupByArgs['orderBy'] }
        : { orderBy?: CaseStudyImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CaseStudyImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCaseStudyImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CaseStudyImage model
   */
  readonly fields: CaseStudyImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CaseStudyImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CaseStudyImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    caseStudy<T extends CaseStudyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CaseStudyDefaultArgs<ExtArgs>>): Prisma__CaseStudyClient<$Result.GetResult<Prisma.$CaseStudyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CaseStudyImage model
   */
  interface CaseStudyImageFieldRefs {
    readonly id: FieldRef<"CaseStudyImage", 'BigInt'>
    readonly image: FieldRef<"CaseStudyImage", 'String'>
    readonly uploadedAt: FieldRef<"CaseStudyImage", 'DateTime'>
    readonly caseStudyId: FieldRef<"CaseStudyImage", 'Int'>
  }


  // Custom InputTypes
  /**
   * CaseStudyImage findUnique
   */
  export type CaseStudyImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyImage to fetch.
     */
    where: CaseStudyImageWhereUniqueInput
  }

  /**
   * CaseStudyImage findUniqueOrThrow
   */
  export type CaseStudyImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyImage to fetch.
     */
    where: CaseStudyImageWhereUniqueInput
  }

  /**
   * CaseStudyImage findFirst
   */
  export type CaseStudyImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyImage to fetch.
     */
    where?: CaseStudyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudyImages to fetch.
     */
    orderBy?: CaseStudyImageOrderByWithRelationInput | CaseStudyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseStudyImages.
     */
    cursor?: CaseStudyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudyImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseStudyImages.
     */
    distinct?: CaseStudyImageScalarFieldEnum | CaseStudyImageScalarFieldEnum[]
  }

  /**
   * CaseStudyImage findFirstOrThrow
   */
  export type CaseStudyImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyImage to fetch.
     */
    where?: CaseStudyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudyImages to fetch.
     */
    orderBy?: CaseStudyImageOrderByWithRelationInput | CaseStudyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CaseStudyImages.
     */
    cursor?: CaseStudyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudyImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CaseStudyImages.
     */
    distinct?: CaseStudyImageScalarFieldEnum | CaseStudyImageScalarFieldEnum[]
  }

  /**
   * CaseStudyImage findMany
   */
  export type CaseStudyImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    /**
     * Filter, which CaseStudyImages to fetch.
     */
    where?: CaseStudyImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CaseStudyImages to fetch.
     */
    orderBy?: CaseStudyImageOrderByWithRelationInput | CaseStudyImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CaseStudyImages.
     */
    cursor?: CaseStudyImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CaseStudyImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CaseStudyImages.
     */
    skip?: number
    distinct?: CaseStudyImageScalarFieldEnum | CaseStudyImageScalarFieldEnum[]
  }

  /**
   * CaseStudyImage create
   */
  export type CaseStudyImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    /**
     * The data needed to create a CaseStudyImage.
     */
    data: XOR<CaseStudyImageCreateInput, CaseStudyImageUncheckedCreateInput>
  }

  /**
   * CaseStudyImage createMany
   */
  export type CaseStudyImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CaseStudyImages.
     */
    data: CaseStudyImageCreateManyInput | CaseStudyImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CaseStudyImage createManyAndReturn
   */
  export type CaseStudyImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * The data used to create many CaseStudyImages.
     */
    data: CaseStudyImageCreateManyInput | CaseStudyImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseStudyImage update
   */
  export type CaseStudyImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    /**
     * The data needed to update a CaseStudyImage.
     */
    data: XOR<CaseStudyImageUpdateInput, CaseStudyImageUncheckedUpdateInput>
    /**
     * Choose, which CaseStudyImage to update.
     */
    where: CaseStudyImageWhereUniqueInput
  }

  /**
   * CaseStudyImage updateMany
   */
  export type CaseStudyImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CaseStudyImages.
     */
    data: XOR<CaseStudyImageUpdateManyMutationInput, CaseStudyImageUncheckedUpdateManyInput>
    /**
     * Filter which CaseStudyImages to update
     */
    where?: CaseStudyImageWhereInput
    /**
     * Limit how many CaseStudyImages to update.
     */
    limit?: number
  }

  /**
   * CaseStudyImage updateManyAndReturn
   */
  export type CaseStudyImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * The data used to update CaseStudyImages.
     */
    data: XOR<CaseStudyImageUpdateManyMutationInput, CaseStudyImageUncheckedUpdateManyInput>
    /**
     * Filter which CaseStudyImages to update
     */
    where?: CaseStudyImageWhereInput
    /**
     * Limit how many CaseStudyImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CaseStudyImage upsert
   */
  export type CaseStudyImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    /**
     * The filter to search for the CaseStudyImage to update in case it exists.
     */
    where: CaseStudyImageWhereUniqueInput
    /**
     * In case the CaseStudyImage found by the `where` argument doesn't exist, create a new CaseStudyImage with this data.
     */
    create: XOR<CaseStudyImageCreateInput, CaseStudyImageUncheckedCreateInput>
    /**
     * In case the CaseStudyImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CaseStudyImageUpdateInput, CaseStudyImageUncheckedUpdateInput>
  }

  /**
   * CaseStudyImage delete
   */
  export type CaseStudyImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
    /**
     * Filter which CaseStudyImage to delete.
     */
    where: CaseStudyImageWhereUniqueInput
  }

  /**
   * CaseStudyImage deleteMany
   */
  export type CaseStudyImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CaseStudyImages to delete
     */
    where?: CaseStudyImageWhereInput
    /**
     * Limit how many CaseStudyImages to delete.
     */
    limit?: number
  }

  /**
   * CaseStudyImage without action
   */
  export type CaseStudyImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyImage
     */
    select?: CaseStudyImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyImage
     */
    omit?: CaseStudyImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyImageInclude<ExtArgs> | null
  }


  /**
   * Model PublishedAssuranceCase
   */

  export type AggregatePublishedAssuranceCase = {
    _count: PublishedAssuranceCaseCountAggregateOutputType | null
    _min: PublishedAssuranceCaseMinAggregateOutputType | null
    _max: PublishedAssuranceCaseMaxAggregateOutputType | null
  }

  export type PublishedAssuranceCaseMinAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    assuranceCaseId: string | null
    description: string | null
  }

  export type PublishedAssuranceCaseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    createdAt: Date | null
    assuranceCaseId: string | null
    description: string | null
  }

  export type PublishedAssuranceCaseCountAggregateOutputType = {
    id: number
    title: number
    content: number
    createdAt: number
    assuranceCaseId: number
    description: number
    _all: number
  }


  export type PublishedAssuranceCaseMinAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    assuranceCaseId?: true
    description?: true
  }

  export type PublishedAssuranceCaseMaxAggregateInputType = {
    id?: true
    title?: true
    createdAt?: true
    assuranceCaseId?: true
    description?: true
  }

  export type PublishedAssuranceCaseCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    assuranceCaseId?: true
    description?: true
    _all?: true
  }

  export type PublishedAssuranceCaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublishedAssuranceCase to aggregate.
     */
    where?: PublishedAssuranceCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PublishedAssuranceCases to fetch.
     */
    orderBy?: PublishedAssuranceCaseOrderByWithRelationInput | PublishedAssuranceCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PublishedAssuranceCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PublishedAssuranceCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PublishedAssuranceCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PublishedAssuranceCases
    **/
    _count?: true | PublishedAssuranceCaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: PublishedAssuranceCaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: PublishedAssuranceCaseMaxAggregateInputType
  }

  export type GetPublishedAssuranceCaseAggregateType<T extends PublishedAssuranceCaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePublishedAssuranceCase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublishedAssuranceCase[P]>
      : GetScalarType<T[P], AggregatePublishedAssuranceCase[P]>
  }




  export type PublishedAssuranceCaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublishedAssuranceCaseWhereInput
    orderBy?: PublishedAssuranceCaseOrderByWithAggregationInput | PublishedAssuranceCaseOrderByWithAggregationInput[]
    by: PublishedAssuranceCaseScalarFieldEnum[] | PublishedAssuranceCaseScalarFieldEnum
    having?: PublishedAssuranceCaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublishedAssuranceCaseCountAggregateInputType | true
    _min?: PublishedAssuranceCaseMinAggregateInputType
    _max?: PublishedAssuranceCaseMaxAggregateInputType
  }

  export type PublishedAssuranceCaseGroupByOutputType = {
    id: string
    title: string
    content: JsonValue
    createdAt: Date
    assuranceCaseId: string
    description: string | null
    _count: PublishedAssuranceCaseCountAggregateOutputType | null
    _min: PublishedAssuranceCaseMinAggregateOutputType | null
    _max: PublishedAssuranceCaseMaxAggregateOutputType | null
  }

  type GetPublishedAssuranceCaseGroupByPayload<T extends PublishedAssuranceCaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublishedAssuranceCaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublishedAssuranceCaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublishedAssuranceCaseGroupByOutputType[P]>
            : GetScalarType<T[P], PublishedAssuranceCaseGroupByOutputType[P]>
        }
      >
    >


  export type PublishedAssuranceCaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    assuranceCaseId?: boolean
    description?: boolean
    assuranceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    caseStudyLinks?: boolean | PublishedAssuranceCase$caseStudyLinksArgs<ExtArgs>
    _count?: boolean | PublishedAssuranceCaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publishedAssuranceCase"]>

  export type PublishedAssuranceCaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    assuranceCaseId?: boolean
    description?: boolean
    assuranceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publishedAssuranceCase"]>

  export type PublishedAssuranceCaseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    assuranceCaseId?: boolean
    description?: boolean
    assuranceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publishedAssuranceCase"]>

  export type PublishedAssuranceCaseSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    assuranceCaseId?: boolean
    description?: boolean
  }

  export type PublishedAssuranceCaseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "createdAt" | "assuranceCaseId" | "description", ExtArgs["result"]["publishedAssuranceCase"]>
  export type PublishedAssuranceCaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assuranceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
    caseStudyLinks?: boolean | PublishedAssuranceCase$caseStudyLinksArgs<ExtArgs>
    _count?: boolean | PublishedAssuranceCaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PublishedAssuranceCaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assuranceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }
  export type PublishedAssuranceCaseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assuranceCase?: boolean | AssuranceCaseDefaultArgs<ExtArgs>
  }

  export type $PublishedAssuranceCasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PublishedAssuranceCase"
    objects: {
      assuranceCase: Prisma.$AssuranceCasePayload<ExtArgs>
      caseStudyLinks: Prisma.$CaseStudyPublishedCasePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: Prisma.JsonValue
      createdAt: Date
      assuranceCaseId: string
      description: string | null
    }, ExtArgs["result"]["publishedAssuranceCase"]>
    composites: {}
  }

  type PublishedAssuranceCaseGetPayload<S extends boolean | null | undefined | PublishedAssuranceCaseDefaultArgs> = $Result.GetResult<Prisma.$PublishedAssuranceCasePayload, S>

  type PublishedAssuranceCaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PublishedAssuranceCaseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PublishedAssuranceCaseCountAggregateInputType | true
    }

  export interface PublishedAssuranceCaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PublishedAssuranceCase'], meta: { name: 'PublishedAssuranceCase' } }
    /**
     * Find zero or one PublishedAssuranceCase that matches the filter.
     * @param {PublishedAssuranceCaseFindUniqueArgs} args - Arguments to find a PublishedAssuranceCase
     * @example
     * // Get one PublishedAssuranceCase
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PublishedAssuranceCaseFindUniqueArgs>(args: SelectSubset<T, PublishedAssuranceCaseFindUniqueArgs<ExtArgs>>): Prisma__PublishedAssuranceCaseClient<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PublishedAssuranceCase that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PublishedAssuranceCaseFindUniqueOrThrowArgs} args - Arguments to find a PublishedAssuranceCase
     * @example
     * // Get one PublishedAssuranceCase
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PublishedAssuranceCaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PublishedAssuranceCaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PublishedAssuranceCaseClient<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublishedAssuranceCase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedAssuranceCaseFindFirstArgs} args - Arguments to find a PublishedAssuranceCase
     * @example
     * // Get one PublishedAssuranceCase
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PublishedAssuranceCaseFindFirstArgs>(args?: SelectSubset<T, PublishedAssuranceCaseFindFirstArgs<ExtArgs>>): Prisma__PublishedAssuranceCaseClient<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PublishedAssuranceCase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedAssuranceCaseFindFirstOrThrowArgs} args - Arguments to find a PublishedAssuranceCase
     * @example
     * // Get one PublishedAssuranceCase
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PublishedAssuranceCaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PublishedAssuranceCaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PublishedAssuranceCaseClient<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PublishedAssuranceCases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedAssuranceCaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PublishedAssuranceCases
     * const publishedAssuranceCases = await prisma.publishedAssuranceCase.findMany()
     *
     * // Get first 10 PublishedAssuranceCases
     * const publishedAssuranceCases = await prisma.publishedAssuranceCase.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const publishedAssuranceCaseWithIdOnly = await prisma.publishedAssuranceCase.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PublishedAssuranceCaseFindManyArgs>(args?: SelectSubset<T, PublishedAssuranceCaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PublishedAssuranceCase.
     * @param {PublishedAssuranceCaseCreateArgs} args - Arguments to create a PublishedAssuranceCase.
     * @example
     * // Create one PublishedAssuranceCase
     * const PublishedAssuranceCase = await prisma.publishedAssuranceCase.create({
     *   data: {
     *     // ... data to create a PublishedAssuranceCase
     *   }
     * })
     *
     */
    create<T extends PublishedAssuranceCaseCreateArgs>(args: SelectSubset<T, PublishedAssuranceCaseCreateArgs<ExtArgs>>): Prisma__PublishedAssuranceCaseClient<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PublishedAssuranceCases.
     * @param {PublishedAssuranceCaseCreateManyArgs} args - Arguments to create many PublishedAssuranceCases.
     * @example
     * // Create many PublishedAssuranceCases
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PublishedAssuranceCaseCreateManyArgs>(args?: SelectSubset<T, PublishedAssuranceCaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PublishedAssuranceCases and returns the data saved in the database.
     * @param {PublishedAssuranceCaseCreateManyAndReturnArgs} args - Arguments to create many PublishedAssuranceCases.
     * @example
     * // Create many PublishedAssuranceCases
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many PublishedAssuranceCases and only return the `id`
     * const publishedAssuranceCaseWithIdOnly = await prisma.publishedAssuranceCase.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends PublishedAssuranceCaseCreateManyAndReturnArgs>(args?: SelectSubset<T, PublishedAssuranceCaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PublishedAssuranceCase.
     * @param {PublishedAssuranceCaseDeleteArgs} args - Arguments to delete one PublishedAssuranceCase.
     * @example
     * // Delete one PublishedAssuranceCase
     * const PublishedAssuranceCase = await prisma.publishedAssuranceCase.delete({
     *   where: {
     *     // ... filter to delete one PublishedAssuranceCase
     *   }
     * })
     *
     */
    delete<T extends PublishedAssuranceCaseDeleteArgs>(args: SelectSubset<T, PublishedAssuranceCaseDeleteArgs<ExtArgs>>): Prisma__PublishedAssuranceCaseClient<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PublishedAssuranceCase.
     * @param {PublishedAssuranceCaseUpdateArgs} args - Arguments to update one PublishedAssuranceCase.
     * @example
     * // Update one PublishedAssuranceCase
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PublishedAssuranceCaseUpdateArgs>(args: SelectSubset<T, PublishedAssuranceCaseUpdateArgs<ExtArgs>>): Prisma__PublishedAssuranceCaseClient<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PublishedAssuranceCases.
     * @param {PublishedAssuranceCaseDeleteManyArgs} args - Arguments to filter PublishedAssuranceCases to delete.
     * @example
     * // Delete a few PublishedAssuranceCases
     * const { count } = await prisma.publishedAssuranceCase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PublishedAssuranceCaseDeleteManyArgs>(args?: SelectSubset<T, PublishedAssuranceCaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublishedAssuranceCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedAssuranceCaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PublishedAssuranceCases
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PublishedAssuranceCaseUpdateManyArgs>(args: SelectSubset<T, PublishedAssuranceCaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PublishedAssuranceCases and returns the data updated in the database.
     * @param {PublishedAssuranceCaseUpdateManyAndReturnArgs} args - Arguments to update many PublishedAssuranceCases.
     * @example
     * // Update many PublishedAssuranceCases
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more PublishedAssuranceCases and only return the `id`
     * const publishedAssuranceCaseWithIdOnly = await prisma.publishedAssuranceCase.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends PublishedAssuranceCaseUpdateManyAndReturnArgs>(args: SelectSubset<T, PublishedAssuranceCaseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PublishedAssuranceCase.
     * @param {PublishedAssuranceCaseUpsertArgs} args - Arguments to update or create a PublishedAssuranceCase.
     * @example
     * // Update or create a PublishedAssuranceCase
     * const publishedAssuranceCase = await prisma.publishedAssuranceCase.upsert({
     *   create: {
     *     // ... data to create a PublishedAssuranceCase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PublishedAssuranceCase we want to update
     *   }
     * })
     */
    upsert<T extends PublishedAssuranceCaseUpsertArgs>(args: SelectSubset<T, PublishedAssuranceCaseUpsertArgs<ExtArgs>>): Prisma__PublishedAssuranceCaseClient<$Result.GetResult<Prisma.$PublishedAssuranceCasePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PublishedAssuranceCases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedAssuranceCaseCountArgs} args - Arguments to filter PublishedAssuranceCases to count.
     * @example
     * // Count the number of PublishedAssuranceCases
     * const count = await prisma.publishedAssuranceCase.count({
     *   where: {
     *     // ... the filter for the PublishedAssuranceCases we want to count
     *   }
     * })
    **/
    count<T extends PublishedAssuranceCaseCountArgs>(
      args?: Subset<T, PublishedAssuranceCaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublishedAssuranceCaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PublishedAssuranceCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedAssuranceCaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublishedAssuranceCaseAggregateArgs>(args: Subset<T, PublishedAssuranceCaseAggregateArgs>): Prisma.PrismaPromise<GetPublishedAssuranceCaseAggregateType<T>>

    /**
     * Group by PublishedAssuranceCase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublishedAssuranceCaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends PublishedAssuranceCaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublishedAssuranceCaseGroupByArgs['orderBy'] }
        : { orderBy?: PublishedAssuranceCaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublishedAssuranceCaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublishedAssuranceCaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PublishedAssuranceCase model
   */
  readonly fields: PublishedAssuranceCaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PublishedAssuranceCase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublishedAssuranceCaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assuranceCase<T extends AssuranceCaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssuranceCaseDefaultArgs<ExtArgs>>): Prisma__AssuranceCaseClient<$Result.GetResult<Prisma.$AssuranceCasePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    caseStudyLinks<T extends PublishedAssuranceCase$caseStudyLinksArgs<ExtArgs> = {}>(args?: Subset<T, PublishedAssuranceCase$caseStudyLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CaseStudyPublishedCasePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PublishedAssuranceCase model
   */
  interface PublishedAssuranceCaseFieldRefs {
    readonly id: FieldRef<"PublishedAssuranceCase", 'String'>
    readonly title: FieldRef<"PublishedAssuranceCase", 'String'>
    readonly content: FieldRef<"PublishedAssuranceCase", 'Json'>
    readonly createdAt: FieldRef<"PublishedAssuranceCase", 'DateTime'>
    readonly assuranceCaseId: FieldRef<"PublishedAssuranceCase", 'String'>
    readonly description: FieldRef<"PublishedAssuranceCase", 'String'>
  }


  // Custom InputTypes
  /**
   * PublishedAssuranceCase findUnique
   */
  export type PublishedAssuranceCaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which PublishedAssuranceCase to fetch.
     */
    where: PublishedAssuranceCaseWhereUniqueInput
  }

  /**
   * PublishedAssuranceCase findUniqueOrThrow
   */
  export type PublishedAssuranceCaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which PublishedAssuranceCase to fetch.
     */
    where: PublishedAssuranceCaseWhereUniqueInput
  }

  /**
   * PublishedAssuranceCase findFirst
   */
  export type PublishedAssuranceCaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which PublishedAssuranceCase to fetch.
     */
    where?: PublishedAssuranceCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PublishedAssuranceCases to fetch.
     */
    orderBy?: PublishedAssuranceCaseOrderByWithRelationInput | PublishedAssuranceCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PublishedAssuranceCases.
     */
    cursor?: PublishedAssuranceCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PublishedAssuranceCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PublishedAssuranceCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PublishedAssuranceCases.
     */
    distinct?: PublishedAssuranceCaseScalarFieldEnum | PublishedAssuranceCaseScalarFieldEnum[]
  }

  /**
   * PublishedAssuranceCase findFirstOrThrow
   */
  export type PublishedAssuranceCaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which PublishedAssuranceCase to fetch.
     */
    where?: PublishedAssuranceCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PublishedAssuranceCases to fetch.
     */
    orderBy?: PublishedAssuranceCaseOrderByWithRelationInput | PublishedAssuranceCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PublishedAssuranceCases.
     */
    cursor?: PublishedAssuranceCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PublishedAssuranceCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PublishedAssuranceCases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PublishedAssuranceCases.
     */
    distinct?: PublishedAssuranceCaseScalarFieldEnum | PublishedAssuranceCaseScalarFieldEnum[]
  }

  /**
   * PublishedAssuranceCase findMany
   */
  export type PublishedAssuranceCaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter, which PublishedAssuranceCases to fetch.
     */
    where?: PublishedAssuranceCaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PublishedAssuranceCases to fetch.
     */
    orderBy?: PublishedAssuranceCaseOrderByWithRelationInput | PublishedAssuranceCaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PublishedAssuranceCases.
     */
    cursor?: PublishedAssuranceCaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PublishedAssuranceCases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PublishedAssuranceCases.
     */
    skip?: number
    distinct?: PublishedAssuranceCaseScalarFieldEnum | PublishedAssuranceCaseScalarFieldEnum[]
  }

  /**
   * PublishedAssuranceCase create
   */
  export type PublishedAssuranceCaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    /**
     * The data needed to create a PublishedAssuranceCase.
     */
    data: XOR<PublishedAssuranceCaseCreateInput, PublishedAssuranceCaseUncheckedCreateInput>
  }

  /**
   * PublishedAssuranceCase createMany
   */
  export type PublishedAssuranceCaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PublishedAssuranceCases.
     */
    data: PublishedAssuranceCaseCreateManyInput | PublishedAssuranceCaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PublishedAssuranceCase createManyAndReturn
   */
  export type PublishedAssuranceCaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * The data used to create many PublishedAssuranceCases.
     */
    data: PublishedAssuranceCaseCreateManyInput | PublishedAssuranceCaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PublishedAssuranceCase update
   */
  export type PublishedAssuranceCaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    /**
     * The data needed to update a PublishedAssuranceCase.
     */
    data: XOR<PublishedAssuranceCaseUpdateInput, PublishedAssuranceCaseUncheckedUpdateInput>
    /**
     * Choose, which PublishedAssuranceCase to update.
     */
    where: PublishedAssuranceCaseWhereUniqueInput
  }

  /**
   * PublishedAssuranceCase updateMany
   */
  export type PublishedAssuranceCaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PublishedAssuranceCases.
     */
    data: XOR<PublishedAssuranceCaseUpdateManyMutationInput, PublishedAssuranceCaseUncheckedUpdateManyInput>
    /**
     * Filter which PublishedAssuranceCases to update
     */
    where?: PublishedAssuranceCaseWhereInput
    /**
     * Limit how many PublishedAssuranceCases to update.
     */
    limit?: number
  }

  /**
   * PublishedAssuranceCase updateManyAndReturn
   */
  export type PublishedAssuranceCaseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * The data used to update PublishedAssuranceCases.
     */
    data: XOR<PublishedAssuranceCaseUpdateManyMutationInput, PublishedAssuranceCaseUncheckedUpdateManyInput>
    /**
     * Filter which PublishedAssuranceCases to update
     */
    where?: PublishedAssuranceCaseWhereInput
    /**
     * Limit how many PublishedAssuranceCases to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PublishedAssuranceCase upsert
   */
  export type PublishedAssuranceCaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    /**
     * The filter to search for the PublishedAssuranceCase to update in case it exists.
     */
    where: PublishedAssuranceCaseWhereUniqueInput
    /**
     * In case the PublishedAssuranceCase found by the `where` argument doesn't exist, create a new PublishedAssuranceCase with this data.
     */
    create: XOR<PublishedAssuranceCaseCreateInput, PublishedAssuranceCaseUncheckedCreateInput>
    /**
     * In case the PublishedAssuranceCase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublishedAssuranceCaseUpdateInput, PublishedAssuranceCaseUncheckedUpdateInput>
  }

  /**
   * PublishedAssuranceCase delete
   */
  export type PublishedAssuranceCaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
    /**
     * Filter which PublishedAssuranceCase to delete.
     */
    where: PublishedAssuranceCaseWhereUniqueInput
  }

  /**
   * PublishedAssuranceCase deleteMany
   */
  export type PublishedAssuranceCaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PublishedAssuranceCases to delete
     */
    where?: PublishedAssuranceCaseWhereInput
    /**
     * Limit how many PublishedAssuranceCases to delete.
     */
    limit?: number
  }

  /**
   * PublishedAssuranceCase.caseStudyLinks
   */
  export type PublishedAssuranceCase$caseStudyLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CaseStudyPublishedCase
     */
    select?: CaseStudyPublishedCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CaseStudyPublishedCase
     */
    omit?: CaseStudyPublishedCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CaseStudyPublishedCaseInclude<ExtArgs> | null
    where?: CaseStudyPublishedCaseWhereInput
    orderBy?: CaseStudyPublishedCaseOrderByWithRelationInput | CaseStudyPublishedCaseOrderByWithRelationInput[]
    cursor?: CaseStudyPublishedCaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CaseStudyPublishedCaseScalarFieldEnum | CaseStudyPublishedCaseScalarFieldEnum[]
  }

  /**
   * PublishedAssuranceCase without action
   */
  export type PublishedAssuranceCaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublishedAssuranceCase
     */
    select?: PublishedAssuranceCaseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PublishedAssuranceCase
     */
    omit?: PublishedAssuranceCaseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PublishedAssuranceCaseInclude<ExtArgs> | null
  }


  /**
   * Model LegacyMapping
   */

  export type AggregateLegacyMapping = {
    _count: LegacyMappingCountAggregateOutputType | null
    _avg: LegacyMappingAvgAggregateOutputType | null
    _sum: LegacyMappingSumAggregateOutputType | null
    _min: LegacyMappingMinAggregateOutputType | null
    _max: LegacyMappingMaxAggregateOutputType | null
  }

  export type LegacyMappingAvgAggregateOutputType = {
    legacyId: number | null
  }

  export type LegacyMappingSumAggregateOutputType = {
    legacyId: bigint | null
  }

  export type LegacyMappingMinAggregateOutputType = {
    id: string | null
    entityType: string | null
    legacyId: bigint | null
    newId: string | null
    createdAt: Date | null
  }

  export type LegacyMappingMaxAggregateOutputType = {
    id: string | null
    entityType: string | null
    legacyId: bigint | null
    newId: string | null
    createdAt: Date | null
  }

  export type LegacyMappingCountAggregateOutputType = {
    id: number
    entityType: number
    legacyId: number
    newId: number
    createdAt: number
    _all: number
  }


  export type LegacyMappingAvgAggregateInputType = {
    legacyId?: true
  }

  export type LegacyMappingSumAggregateInputType = {
    legacyId?: true
  }

  export type LegacyMappingMinAggregateInputType = {
    id?: true
    entityType?: true
    legacyId?: true
    newId?: true
    createdAt?: true
  }

  export type LegacyMappingMaxAggregateInputType = {
    id?: true
    entityType?: true
    legacyId?: true
    newId?: true
    createdAt?: true
  }

  export type LegacyMappingCountAggregateInputType = {
    id?: true
    entityType?: true
    legacyId?: true
    newId?: true
    createdAt?: true
    _all?: true
  }

  export type LegacyMappingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LegacyMapping to aggregate.
     */
    where?: LegacyMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LegacyMappings to fetch.
     */
    orderBy?: LegacyMappingOrderByWithRelationInput | LegacyMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: LegacyMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LegacyMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LegacyMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned LegacyMappings
    **/
    _count?: true | LegacyMappingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
    **/
    _avg?: LegacyMappingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
    **/
    _sum?: LegacyMappingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
    **/
    _min?: LegacyMappingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
    **/
    _max?: LegacyMappingMaxAggregateInputType
  }

  export type GetLegacyMappingAggregateType<T extends LegacyMappingAggregateArgs> = {
        [P in keyof T & keyof AggregateLegacyMapping]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLegacyMapping[P]>
      : GetScalarType<T[P], AggregateLegacyMapping[P]>
  }




  export type LegacyMappingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LegacyMappingWhereInput
    orderBy?: LegacyMappingOrderByWithAggregationInput | LegacyMappingOrderByWithAggregationInput[]
    by: LegacyMappingScalarFieldEnum[] | LegacyMappingScalarFieldEnum
    having?: LegacyMappingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LegacyMappingCountAggregateInputType | true
    _avg?: LegacyMappingAvgAggregateInputType
    _sum?: LegacyMappingSumAggregateInputType
    _min?: LegacyMappingMinAggregateInputType
    _max?: LegacyMappingMaxAggregateInputType
  }

  export type LegacyMappingGroupByOutputType = {
    id: string
    entityType: string
    legacyId: bigint
    newId: string
    createdAt: Date
    _count: LegacyMappingCountAggregateOutputType | null
    _avg: LegacyMappingAvgAggregateOutputType | null
    _sum: LegacyMappingSumAggregateOutputType | null
    _min: LegacyMappingMinAggregateOutputType | null
    _max: LegacyMappingMaxAggregateOutputType | null
  }

  type GetLegacyMappingGroupByPayload<T extends LegacyMappingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LegacyMappingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LegacyMappingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LegacyMappingGroupByOutputType[P]>
            : GetScalarType<T[P], LegacyMappingGroupByOutputType[P]>
        }
      >
    >


  export type LegacyMappingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    legacyId?: boolean
    newId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["legacyMapping"]>

  export type LegacyMappingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    legacyId?: boolean
    newId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["legacyMapping"]>

  export type LegacyMappingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityType?: boolean
    legacyId?: boolean
    newId?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["legacyMapping"]>

  export type LegacyMappingSelectScalar = {
    id?: boolean
    entityType?: boolean
    legacyId?: boolean
    newId?: boolean
    createdAt?: boolean
  }

  export type LegacyMappingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityType" | "legacyId" | "newId" | "createdAt", ExtArgs["result"]["legacyMapping"]>

  export type $LegacyMappingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LegacyMapping"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityType: string
      legacyId: bigint
      newId: string
      createdAt: Date
    }, ExtArgs["result"]["legacyMapping"]>
    composites: {}
  }

  type LegacyMappingGetPayload<S extends boolean | null | undefined | LegacyMappingDefaultArgs> = $Result.GetResult<Prisma.$LegacyMappingPayload, S>

  type LegacyMappingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LegacyMappingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LegacyMappingCountAggregateInputType | true
    }

  export interface LegacyMappingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LegacyMapping'], meta: { name: 'LegacyMapping' } }
    /**
     * Find zero or one LegacyMapping that matches the filter.
     * @param {LegacyMappingFindUniqueArgs} args - Arguments to find a LegacyMapping
     * @example
     * // Get one LegacyMapping
     * const legacyMapping = await prisma.legacyMapping.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LegacyMappingFindUniqueArgs>(args: SelectSubset<T, LegacyMappingFindUniqueArgs<ExtArgs>>): Prisma__LegacyMappingClient<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LegacyMapping that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LegacyMappingFindUniqueOrThrowArgs} args - Arguments to find a LegacyMapping
     * @example
     * // Get one LegacyMapping
     * const legacyMapping = await prisma.legacyMapping.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LegacyMappingFindUniqueOrThrowArgs>(args: SelectSubset<T, LegacyMappingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LegacyMappingClient<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LegacyMapping that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegacyMappingFindFirstArgs} args - Arguments to find a LegacyMapping
     * @example
     * // Get one LegacyMapping
     * const legacyMapping = await prisma.legacyMapping.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LegacyMappingFindFirstArgs>(args?: SelectSubset<T, LegacyMappingFindFirstArgs<ExtArgs>>): Prisma__LegacyMappingClient<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LegacyMapping that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegacyMappingFindFirstOrThrowArgs} args - Arguments to find a LegacyMapping
     * @example
     * // Get one LegacyMapping
     * const legacyMapping = await prisma.legacyMapping.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LegacyMappingFindFirstOrThrowArgs>(args?: SelectSubset<T, LegacyMappingFindFirstOrThrowArgs<ExtArgs>>): Prisma__LegacyMappingClient<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LegacyMappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegacyMappingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LegacyMappings
     * const legacyMappings = await prisma.legacyMapping.findMany()
     *
     * // Get first 10 LegacyMappings
     * const legacyMappings = await prisma.legacyMapping.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const legacyMappingWithIdOnly = await prisma.legacyMapping.findMany({ select: { id: true } })
     *
     */
    findMany<T extends LegacyMappingFindManyArgs>(args?: SelectSubset<T, LegacyMappingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LegacyMapping.
     * @param {LegacyMappingCreateArgs} args - Arguments to create a LegacyMapping.
     * @example
     * // Create one LegacyMapping
     * const LegacyMapping = await prisma.legacyMapping.create({
     *   data: {
     *     // ... data to create a LegacyMapping
     *   }
     * })
     *
     */
    create<T extends LegacyMappingCreateArgs>(args: SelectSubset<T, LegacyMappingCreateArgs<ExtArgs>>): Prisma__LegacyMappingClient<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LegacyMappings.
     * @param {LegacyMappingCreateManyArgs} args - Arguments to create many LegacyMappings.
     * @example
     * // Create many LegacyMappings
     * const legacyMapping = await prisma.legacyMapping.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends LegacyMappingCreateManyArgs>(args?: SelectSubset<T, LegacyMappingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LegacyMappings and returns the data saved in the database.
     * @param {LegacyMappingCreateManyAndReturnArgs} args - Arguments to create many LegacyMappings.
     * @example
     * // Create many LegacyMappings
     * const legacyMapping = await prisma.legacyMapping.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Create many LegacyMappings and only return the `id`
     * const legacyMappingWithIdOnly = await prisma.legacyMapping.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    createManyAndReturn<T extends LegacyMappingCreateManyAndReturnArgs>(args?: SelectSubset<T, LegacyMappingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LegacyMapping.
     * @param {LegacyMappingDeleteArgs} args - Arguments to delete one LegacyMapping.
     * @example
     * // Delete one LegacyMapping
     * const LegacyMapping = await prisma.legacyMapping.delete({
     *   where: {
     *     // ... filter to delete one LegacyMapping
     *   }
     * })
     *
     */
    delete<T extends LegacyMappingDeleteArgs>(args: SelectSubset<T, LegacyMappingDeleteArgs<ExtArgs>>): Prisma__LegacyMappingClient<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LegacyMapping.
     * @param {LegacyMappingUpdateArgs} args - Arguments to update one LegacyMapping.
     * @example
     * // Update one LegacyMapping
     * const legacyMapping = await prisma.legacyMapping.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends LegacyMappingUpdateArgs>(args: SelectSubset<T, LegacyMappingUpdateArgs<ExtArgs>>): Prisma__LegacyMappingClient<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LegacyMappings.
     * @param {LegacyMappingDeleteManyArgs} args - Arguments to filter LegacyMappings to delete.
     * @example
     * // Delete a few LegacyMappings
     * const { count } = await prisma.legacyMapping.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends LegacyMappingDeleteManyArgs>(args?: SelectSubset<T, LegacyMappingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LegacyMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegacyMappingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LegacyMappings
     * const legacyMapping = await prisma.legacyMapping.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends LegacyMappingUpdateManyArgs>(args: SelectSubset<T, LegacyMappingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LegacyMappings and returns the data updated in the database.
     * @param {LegacyMappingUpdateManyAndReturnArgs} args - Arguments to update many LegacyMappings.
     * @example
     * // Update many LegacyMappings
     * const legacyMapping = await prisma.legacyMapping.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     * // Update zero or more LegacyMappings and only return the `id`
     * const legacyMappingWithIdOnly = await prisma.legacyMapping.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     *
     */
    updateManyAndReturn<T extends LegacyMappingUpdateManyAndReturnArgs>(args: SelectSubset<T, LegacyMappingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LegacyMapping.
     * @param {LegacyMappingUpsertArgs} args - Arguments to update or create a LegacyMapping.
     * @example
     * // Update or create a LegacyMapping
     * const legacyMapping = await prisma.legacyMapping.upsert({
     *   create: {
     *     // ... data to create a LegacyMapping
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LegacyMapping we want to update
     *   }
     * })
     */
    upsert<T extends LegacyMappingUpsertArgs>(args: SelectSubset<T, LegacyMappingUpsertArgs<ExtArgs>>): Prisma__LegacyMappingClient<$Result.GetResult<Prisma.$LegacyMappingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LegacyMappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegacyMappingCountArgs} args - Arguments to filter LegacyMappings to count.
     * @example
     * // Count the number of LegacyMappings
     * const count = await prisma.legacyMapping.count({
     *   where: {
     *     // ... the filter for the LegacyMappings we want to count
     *   }
     * })
    **/
    count<T extends LegacyMappingCountArgs>(
      args?: Subset<T, LegacyMappingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LegacyMappingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LegacyMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegacyMappingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LegacyMappingAggregateArgs>(args: Subset<T, LegacyMappingAggregateArgs>): Prisma.PrismaPromise<GetLegacyMappingAggregateType<T>>

    /**
     * Group by LegacyMapping.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LegacyMappingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
    **/
    groupBy<
      T extends LegacyMappingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LegacyMappingGroupByArgs['orderBy'] }
        : { orderBy?: LegacyMappingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LegacyMappingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLegacyMappingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LegacyMapping model
   */
  readonly fields: LegacyMappingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LegacyMapping.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LegacyMappingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LegacyMapping model
   */
  interface LegacyMappingFieldRefs {
    readonly id: FieldRef<"LegacyMapping", 'String'>
    readonly entityType: FieldRef<"LegacyMapping", 'String'>
    readonly legacyId: FieldRef<"LegacyMapping", 'BigInt'>
    readonly newId: FieldRef<"LegacyMapping", 'String'>
    readonly createdAt: FieldRef<"LegacyMapping", 'DateTime'>
  }


  // Custom InputTypes
  /**
   * LegacyMapping findUnique
   */
  export type LegacyMappingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * Filter, which LegacyMapping to fetch.
     */
    where: LegacyMappingWhereUniqueInput
  }

  /**
   * LegacyMapping findUniqueOrThrow
   */
  export type LegacyMappingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * Filter, which LegacyMapping to fetch.
     */
    where: LegacyMappingWhereUniqueInput
  }

  /**
   * LegacyMapping findFirst
   */
  export type LegacyMappingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * Filter, which LegacyMapping to fetch.
     */
    where?: LegacyMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LegacyMappings to fetch.
     */
    orderBy?: LegacyMappingOrderByWithRelationInput | LegacyMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LegacyMappings.
     */
    cursor?: LegacyMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LegacyMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LegacyMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LegacyMappings.
     */
    distinct?: LegacyMappingScalarFieldEnum | LegacyMappingScalarFieldEnum[]
  }

  /**
   * LegacyMapping findFirstOrThrow
   */
  export type LegacyMappingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * Filter, which LegacyMapping to fetch.
     */
    where?: LegacyMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LegacyMappings to fetch.
     */
    orderBy?: LegacyMappingOrderByWithRelationInput | LegacyMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for LegacyMappings.
     */
    cursor?: LegacyMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LegacyMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LegacyMappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of LegacyMappings.
     */
    distinct?: LegacyMappingScalarFieldEnum | LegacyMappingScalarFieldEnum[]
  }

  /**
   * LegacyMapping findMany
   */
  export type LegacyMappingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * Filter, which LegacyMappings to fetch.
     */
    where?: LegacyMappingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of LegacyMappings to fetch.
     */
    orderBy?: LegacyMappingOrderByWithRelationInput | LegacyMappingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing LegacyMappings.
     */
    cursor?: LegacyMappingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` LegacyMappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` LegacyMappings.
     */
    skip?: number
    distinct?: LegacyMappingScalarFieldEnum | LegacyMappingScalarFieldEnum[]
  }

  /**
   * LegacyMapping create
   */
  export type LegacyMappingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * The data needed to create a LegacyMapping.
     */
    data: XOR<LegacyMappingCreateInput, LegacyMappingUncheckedCreateInput>
  }

  /**
   * LegacyMapping createMany
   */
  export type LegacyMappingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LegacyMappings.
     */
    data: LegacyMappingCreateManyInput | LegacyMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LegacyMapping createManyAndReturn
   */
  export type LegacyMappingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * The data used to create many LegacyMappings.
     */
    data: LegacyMappingCreateManyInput | LegacyMappingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LegacyMapping update
   */
  export type LegacyMappingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * The data needed to update a LegacyMapping.
     */
    data: XOR<LegacyMappingUpdateInput, LegacyMappingUncheckedUpdateInput>
    /**
     * Choose, which LegacyMapping to update.
     */
    where: LegacyMappingWhereUniqueInput
  }

  /**
   * LegacyMapping updateMany
   */
  export type LegacyMappingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LegacyMappings.
     */
    data: XOR<LegacyMappingUpdateManyMutationInput, LegacyMappingUncheckedUpdateManyInput>
    /**
     * Filter which LegacyMappings to update
     */
    where?: LegacyMappingWhereInput
    /**
     * Limit how many LegacyMappings to update.
     */
    limit?: number
  }

  /**
   * LegacyMapping updateManyAndReturn
   */
  export type LegacyMappingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * The data used to update LegacyMappings.
     */
    data: XOR<LegacyMappingUpdateManyMutationInput, LegacyMappingUncheckedUpdateManyInput>
    /**
     * Filter which LegacyMappings to update
     */
    where?: LegacyMappingWhereInput
    /**
     * Limit how many LegacyMappings to update.
     */
    limit?: number
  }

  /**
   * LegacyMapping upsert
   */
  export type LegacyMappingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * The filter to search for the LegacyMapping to update in case it exists.
     */
    where: LegacyMappingWhereUniqueInput
    /**
     * In case the LegacyMapping found by the `where` argument doesn't exist, create a new LegacyMapping with this data.
     */
    create: XOR<LegacyMappingCreateInput, LegacyMappingUncheckedCreateInput>
    /**
     * In case the LegacyMapping was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LegacyMappingUpdateInput, LegacyMappingUncheckedUpdateInput>
  }

  /**
   * LegacyMapping delete
   */
  export type LegacyMappingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
    /**
     * Filter which LegacyMapping to delete.
     */
    where: LegacyMappingWhereUniqueInput
  }

  /**
   * LegacyMapping deleteMany
   */
  export type LegacyMappingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LegacyMappings to delete
     */
    where?: LegacyMappingWhereInput
    /**
     * Limit how many LegacyMappings to delete.
     */
    limit?: number
  }

  /**
   * LegacyMapping without action
   */
  export type LegacyMappingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LegacyMapping
     */
    select?: LegacyMappingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LegacyMapping
     */
    omit?: LegacyMappingOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    passwordHash: 'passwordHash',
    passwordAlgorithm: 'passwordAlgorithm',
    firstName: 'firstName',
    lastName: 'lastName',
    avatarUrl: 'avatarUrl',
    authProvider: 'authProvider',
    githubId: 'githubId',
    githubUsername: 'githubUsername',
    emailVerified: 'emailVerified',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpires: 'passwordResetExpires',
    defaultCaseMode: 'defaultCaseMode',
    hasSeenMigrationNotice: 'hasSeenMigrationNotice',
    isSystemUser: 'isSystemUser',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLoginAt: 'lastLoginAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    userId: 'userId',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt',
    userAgent: 'userAgent',
    ipAddress: 'ipAddress'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const PasswordResetAttemptScalarFieldEnum: {
    id: 'id',
    email: 'email',
    ipAddress: 'ipAddress',
    attemptedAt: 'attemptedAt',
    successful: 'successful'
  };

  export type PasswordResetAttemptScalarFieldEnum = (typeof PasswordResetAttemptScalarFieldEnum)[keyof typeof PasswordResetAttemptScalarFieldEnum]


  export const SecurityAuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    eventType: 'eventType',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type SecurityAuditLogScalarFieldEnum = (typeof SecurityAuditLogScalarFieldEnum)[keyof typeof SecurityAuditLogScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    organisationId: 'organisationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    role: 'role',
    invitedById: 'invitedById',
    joinedAt: 'joinedAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const AssuranceCaseScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    createdById: 'createdById',
    mode: 'mode',
    colorProfile: 'colorProfile',
    lockUuid: 'lockUuid',
    lockedById: 'lockedById',
    lockedAt: 'lockedAt',
    sourcePatternId: 'sourcePatternId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    published: 'published',
    publishedAt: 'publishedAt',
    publishStatus: 'publishStatus',
    markedReadyAt: 'markedReadyAt',
    markedReadyById: 'markedReadyById'
  };

  export type AssuranceCaseScalarFieldEnum = (typeof AssuranceCaseScalarFieldEnum)[keyof typeof AssuranceCaseScalarFieldEnum]


  export const CasePermissionScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    userId: 'userId',
    permission: 'permission',
    grantedById: 'grantedById',
    grantedAt: 'grantedAt'
  };

  export type CasePermissionScalarFieldEnum = (typeof CasePermissionScalarFieldEnum)[keyof typeof CasePermissionScalarFieldEnum]


  export const CaseTeamPermissionScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    teamId: 'teamId',
    permission: 'permission',
    grantedById: 'grantedById',
    grantedAt: 'grantedAt'
  };

  export type CaseTeamPermissionScalarFieldEnum = (typeof CaseTeamPermissionScalarFieldEnum)[keyof typeof CaseTeamPermissionScalarFieldEnum]


  export const CaseInviteScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    email: 'email',
    permission: 'permission',
    inviteToken: 'inviteToken',
    inviteExpiresAt: 'inviteExpiresAt',
    acceptedAt: 'acceptedAt',
    acceptedById: 'acceptedById',
    invitedById: 'invitedById',
    createdAt: 'createdAt'
  };

  export type CaseInviteScalarFieldEnum = (typeof CaseInviteScalarFieldEnum)[keyof typeof CaseInviteScalarFieldEnum]


  export const AssuranceElementScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    elementType: 'elementType',
    role: 'role',
    parentId: 'parentId',
    name: 'name',
    description: 'description',
    assumption: 'assumption',
    justification: 'justification',
    url: 'url',
    moduleReferenceId: 'moduleReferenceId',
    moduleEmbedType: 'moduleEmbedType',
    modulePublicSummary: 'modulePublicSummary',
    fromPattern: 'fromPattern',
    modifiedFromPattern: 'modifiedFromPattern',
    inSandbox: 'inSandbox',
    isDefeater: 'isDefeater',
    defeatsElementId: 'defeatsElementId',
    level: 'level',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdById: 'createdById'
  };

  export type AssuranceElementScalarFieldEnum = (typeof AssuranceElementScalarFieldEnum)[keyof typeof AssuranceElementScalarFieldEnum]


  export const EvidenceLinkScalarFieldEnum: {
    id: 'id',
    evidenceId: 'evidenceId',
    claimId: 'claimId',
    createdAt: 'createdAt'
  };

  export type EvidenceLinkScalarFieldEnum = (typeof EvidenceLinkScalarFieldEnum)[keyof typeof EvidenceLinkScalarFieldEnum]


  export const ArgumentPatternScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    version: 'version',
    category: 'category',
    tags: 'tags',
    published: 'published',
    publishedAt: 'publishedAt',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ArgumentPatternScalarFieldEnum = (typeof ArgumentPatternScalarFieldEnum)[keyof typeof ArgumentPatternScalarFieldEnum]


  export const PatternElementScalarFieldEnum: {
    id: 'id',
    patternId: 'patternId',
    elementType: 'elementType',
    role: 'role',
    parentId: 'parentId',
    name: 'name',
    description: 'description',
    assumption: 'assumption',
    justification: 'justification',
    url: 'url',
    isPlaceholder: 'isPlaceholder',
    placeholderHint: 'placeholderHint',
    displayOrder: 'displayOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatternElementScalarFieldEnum = (typeof PatternElementScalarFieldEnum)[keyof typeof PatternElementScalarFieldEnum]


  export const PatternPermissionScalarFieldEnum: {
    id: 'id',
    patternId: 'patternId',
    userId: 'userId',
    permission: 'permission',
    grantedById: 'grantedById',
    grantedAt: 'grantedAt'
  };

  export type PatternPermissionScalarFieldEnum = (typeof PatternPermissionScalarFieldEnum)[keyof typeof PatternPermissionScalarFieldEnum]


  export const PatternTeamPermissionScalarFieldEnum: {
    id: 'id',
    patternId: 'patternId',
    teamId: 'teamId',
    permission: 'permission',
    grantedById: 'grantedById',
    grantedAt: 'grantedAt'
  };

  export type PatternTeamPermissionScalarFieldEnum = (typeof PatternTeamPermissionScalarFieldEnum)[keyof typeof PatternTeamPermissionScalarFieldEnum]


  export const ReleaseScalarFieldEnum: {
    id: 'id',
    sourceCaseId: 'sourceCaseId',
    publishedCaseId: 'publishedCaseId',
    title: 'title',
    description: 'description',
    currentVersion: 'currentVersion',
    authors: 'authors',
    contactEmail: 'contactEmail',
    category: 'category',
    sector: 'sector',
    tags: 'tags',
    status: 'status',
    firstPublishedAt: 'firstPublishedAt',
    lastUpdatedAt: 'lastUpdatedAt',
    allowComments: 'allowComments',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReleaseScalarFieldEnum = (typeof ReleaseScalarFieldEnum)[keyof typeof ReleaseScalarFieldEnum]


  export const ReleaseSnapshotScalarFieldEnum: {
    id: 'id',
    releaseId: 'releaseId',
    versionNumber: 'versionNumber',
    versionLabel: 'versionLabel',
    content: 'content',
    snapshotTakenAt: 'snapshotTakenAt',
    snapshotTakenById: 'snapshotTakenById',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type ReleaseSnapshotScalarFieldEnum = (typeof ReleaseSnapshotScalarFieldEnum)[keyof typeof ReleaseSnapshotScalarFieldEnum]


  export const ReleaseCommentScalarFieldEnum: {
    id: 'id',
    releaseId: 'releaseId',
    elementId: 'elementId',
    parentCommentId: 'parentCommentId',
    content: 'content',
    authorId: 'authorId',
    status: 'status',
    hiddenById: 'hiddenById',
    hiddenAt: 'hiddenAt',
    hiddenReason: 'hiddenReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReleaseCommentScalarFieldEnum = (typeof ReleaseCommentScalarFieldEnum)[keyof typeof ReleaseCommentScalarFieldEnum]


  export const ReleaseImageScalarFieldEnum: {
    id: 'id',
    releaseId: 'releaseId',
    imageUrl: 'imageUrl',
    altText: 'altText',
    uploadedAt: 'uploadedAt',
    uploadedById: 'uploadedById'
  };

  export type ReleaseImageScalarFieldEnum = (typeof ReleaseImageScalarFieldEnum)[keyof typeof ReleaseImageScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    elementId: 'elementId',
    parentCommentId: 'parentCommentId',
    content: 'content',
    authorId: 'authorId',
    resolved: 'resolved',
    resolvedById: 'resolvedById',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CaseImageScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    imageUrl: 'imageUrl',
    uploadedAt: 'uploadedAt',
    uploadedById: 'uploadedById'
  };

  export type CaseImageScalarFieldEnum = (typeof CaseImageScalarFieldEnum)[keyof typeof CaseImageScalarFieldEnum]


  export const CaseTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    category: 'category',
    externalUrl: 'externalUrl',
    createdAt: 'createdAt'
  };

  export type CaseTypeScalarFieldEnum = (typeof CaseTypeScalarFieldEnum)[keyof typeof CaseTypeScalarFieldEnum]


  export const CaseTypeAssignmentScalarFieldEnum: {
    id: 'id',
    caseId: 'caseId',
    caseTypeId: 'caseTypeId',
    assignedById: 'assignedById',
    assignedAt: 'assignedAt'
  };

  export type CaseTypeAssignmentScalarFieldEnum = (typeof CaseTypeAssignmentScalarFieldEnum)[keyof typeof CaseTypeAssignmentScalarFieldEnum]


  export const GitHubRepositoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    url: 'url',
    description: 'description',
    githubId: 'githubId',
    defaultBranch: 'defaultBranch',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GitHubRepositoryScalarFieldEnum = (typeof GitHubRepositoryScalarFieldEnum)[keyof typeof GitHubRepositoryScalarFieldEnum]


  export const CaseStudyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    authors: 'authors',
    category: 'category',
    publishedDate: 'publishedDate',
    lastModifiedOn: 'lastModifiedOn',
    createdOn: 'createdOn',
    sector: 'sector',
    contact: 'contact',
    image: 'image',
    published: 'published',
    ownerId: 'ownerId',
    type: 'type'
  };

  export type CaseStudyScalarFieldEnum = (typeof CaseStudyScalarFieldEnum)[keyof typeof CaseStudyScalarFieldEnum]


  export const CaseStudyPublishedCaseScalarFieldEnum: {
    id: 'id',
    caseStudyId: 'caseStudyId',
    publishedAssuranceCaseId: 'publishedAssuranceCaseId'
  };

  export type CaseStudyPublishedCaseScalarFieldEnum = (typeof CaseStudyPublishedCaseScalarFieldEnum)[keyof typeof CaseStudyPublishedCaseScalarFieldEnum]


  export const CaseStudyImageScalarFieldEnum: {
    id: 'id',
    image: 'image',
    uploadedAt: 'uploadedAt',
    caseStudyId: 'caseStudyId'
  };

  export type CaseStudyImageScalarFieldEnum = (typeof CaseStudyImageScalarFieldEnum)[keyof typeof CaseStudyImageScalarFieldEnum]


  export const PublishedAssuranceCaseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    assuranceCaseId: 'assuranceCaseId',
    description: 'description'
  };

  export type PublishedAssuranceCaseScalarFieldEnum = (typeof PublishedAssuranceCaseScalarFieldEnum)[keyof typeof PublishedAssuranceCaseScalarFieldEnum]


  export const LegacyMappingScalarFieldEnum: {
    id: 'id',
    entityType: 'entityType',
    legacyId: 'legacyId',
    newId: 'newId',
    createdAt: 'createdAt'
  };

  export type LegacyMappingScalarFieldEnum = (typeof LegacyMappingScalarFieldEnum)[keyof typeof LegacyMappingScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>



  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>



  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider'>



  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProvider[]'>



  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>



  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>



  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>



  /**
   * Reference to a field of type 'CaseMode'
   */
  export type EnumCaseModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaseMode'>



  /**
   * Reference to a field of type 'CaseMode[]'
   */
  export type ListEnumCaseModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaseMode[]'>



  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>



  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>



  /**
   * Reference to a field of type 'TeamRole'
   */
  export type EnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole'>



  /**
   * Reference to a field of type 'TeamRole[]'
   */
  export type ListEnumTeamRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamRole[]'>



  /**
   * Reference to a field of type 'PublishStatus'
   */
  export type EnumPublishStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatus'>



  /**
   * Reference to a field of type 'PublishStatus[]'
   */
  export type ListEnumPublishStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PublishStatus[]'>



  /**
   * Reference to a field of type 'PermissionLevel'
   */
  export type EnumPermissionLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionLevel'>



  /**
   * Reference to a field of type 'PermissionLevel[]'
   */
  export type ListEnumPermissionLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionLevel[]'>



  /**
   * Reference to a field of type 'ElementType'
   */
  export type EnumElementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementType'>



  /**
   * Reference to a field of type 'ElementType[]'
   */
  export type ListEnumElementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementType[]'>



  /**
   * Reference to a field of type 'ElementRole'
   */
  export type EnumElementRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementRole'>



  /**
   * Reference to a field of type 'ElementRole[]'
   */
  export type ListEnumElementRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementRole[]'>



  /**
   * Reference to a field of type 'ModuleEmbedType'
   */
  export type EnumModuleEmbedTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModuleEmbedType'>



  /**
   * Reference to a field of type 'ModuleEmbedType[]'
   */
  export type ListEnumModuleEmbedTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModuleEmbedType[]'>



  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>



  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>



  /**
   * Reference to a field of type 'ReleaseStatus'
   */
  export type EnumReleaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReleaseStatus'>



  /**
   * Reference to a field of type 'ReleaseStatus[]'
   */
  export type ListEnumReleaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReleaseStatus[]'>



  /**
   * Reference to a field of type 'SnapshotReason'
   */
  export type EnumSnapshotReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnapshotReason'>



  /**
   * Reference to a field of type 'SnapshotReason[]'
   */
  export type ListEnumSnapshotReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnapshotReason[]'>



  /**
   * Reference to a field of type 'CommentStatus'
   */
  export type EnumCommentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommentStatus'>



  /**
   * Reference to a field of type 'CommentStatus[]'
   */
  export type ListEnumCommentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommentStatus[]'>



  /**
   * Reference to a field of type 'CaseTypeCategory'
   */
  export type EnumCaseTypeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaseTypeCategory'>



  /**
   * Reference to a field of type 'CaseTypeCategory[]'
   */
  export type ListEnumCaseTypeCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CaseTypeCategory[]'>



  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>



  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>



  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>



  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>

  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    passwordAlgorithm?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    githubId?: StringNullableFilter<"User"> | string | null
    githubUsername?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    defaultCaseMode?: EnumCaseModeFilter<"User"> | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFilter<"User"> | boolean
    isSystemUser?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    teamMemberships?: TeamMemberListRelationFilter
    createdTeams?: TeamListRelationFilter
    createdCases?: AssuranceCaseListRelationFilter
    casePermissions?: CasePermissionListRelationFilter
    grantedPermissions?: CasePermissionListRelationFilter
    createdElements?: AssuranceElementListRelationFilter
    authoredComments?: CommentListRelationFilter
    resolvedComments?: CommentListRelationFilter
    releaseComments?: ReleaseCommentListRelationFilter
    githubRepositories?: GitHubRepositoryListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    caseStudies?: CaseStudyListRelationFilter
    markedReadyCases?: AssuranceCaseListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    passwordAlgorithm?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    authProvider?: SortOrder
    githubId?: SortOrderInput | SortOrder
    githubUsername?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    defaultCaseMode?: SortOrder
    hasSeenMigrationNotice?: SortOrder
    isSystemUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    teamMemberships?: TeamMemberOrderByRelationAggregateInput
    createdTeams?: TeamOrderByRelationAggregateInput
    createdCases?: AssuranceCaseOrderByRelationAggregateInput
    casePermissions?: CasePermissionOrderByRelationAggregateInput
    grantedPermissions?: CasePermissionOrderByRelationAggregateInput
    createdElements?: AssuranceElementOrderByRelationAggregateInput
    authoredComments?: CommentOrderByRelationAggregateInput
    resolvedComments?: CommentOrderByRelationAggregateInput
    releaseComments?: ReleaseCommentOrderByRelationAggregateInput
    githubRepositories?: GitHubRepositoryOrderByRelationAggregateInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    caseStudies?: CaseStudyOrderByRelationAggregateInput
    markedReadyCases?: AssuranceCaseOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    githubId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    passwordAlgorithm?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    authProvider?: EnumAuthProviderFilter<"User"> | $Enums.AuthProvider
    githubUsername?: StringNullableFilter<"User"> | string | null
    emailVerified?: BoolFilter<"User"> | boolean
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    defaultCaseMode?: EnumCaseModeFilter<"User"> | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFilter<"User"> | boolean
    isSystemUser?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    teamMemberships?: TeamMemberListRelationFilter
    createdTeams?: TeamListRelationFilter
    createdCases?: AssuranceCaseListRelationFilter
    casePermissions?: CasePermissionListRelationFilter
    grantedPermissions?: CasePermissionListRelationFilter
    createdElements?: AssuranceElementListRelationFilter
    authoredComments?: CommentListRelationFilter
    resolvedComments?: CommentListRelationFilter
    releaseComments?: ReleaseCommentListRelationFilter
    githubRepositories?: GitHubRepositoryListRelationFilter
    refreshTokens?: RefreshTokenListRelationFilter
    caseStudies?: CaseStudyListRelationFilter
    markedReadyCases?: AssuranceCaseListRelationFilter
  }, "id" | "email" | "username" | "githubId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    passwordAlgorithm?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    authProvider?: SortOrder
    githubId?: SortOrderInput | SortOrder
    githubUsername?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    defaultCaseMode?: SortOrder
    hasSeenMigrationNotice?: SortOrder
    isSystemUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordAlgorithm?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    authProvider?: EnumAuthProviderWithAggregatesFilter<"User"> | $Enums.AuthProvider
    githubId?: StringNullableWithAggregatesFilter<"User"> | string | null
    githubUsername?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    defaultCaseMode?: EnumCaseModeWithAggregatesFilter<"User"> | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolWithAggregatesFilter<"User"> | boolean
    isSystemUser?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    userAgent?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"RefreshToken"> | string | null
  }

  export type PasswordResetAttemptWhereInput = {
    AND?: PasswordResetAttemptWhereInput | PasswordResetAttemptWhereInput[]
    OR?: PasswordResetAttemptWhereInput[]
    NOT?: PasswordResetAttemptWhereInput | PasswordResetAttemptWhereInput[]
    id?: StringFilter<"PasswordResetAttempt"> | string
    email?: StringFilter<"PasswordResetAttempt"> | string
    ipAddress?: StringFilter<"PasswordResetAttempt"> | string
    attemptedAt?: DateTimeFilter<"PasswordResetAttempt"> | Date | string
    successful?: BoolFilter<"PasswordResetAttempt"> | boolean
  }

  export type PasswordResetAttemptOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    attemptedAt?: SortOrder
    successful?: SortOrder
  }

  export type PasswordResetAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordResetAttemptWhereInput | PasswordResetAttemptWhereInput[]
    OR?: PasswordResetAttemptWhereInput[]
    NOT?: PasswordResetAttemptWhereInput | PasswordResetAttemptWhereInput[]
    email?: StringFilter<"PasswordResetAttempt"> | string
    ipAddress?: StringFilter<"PasswordResetAttempt"> | string
    attemptedAt?: DateTimeFilter<"PasswordResetAttempt"> | Date | string
    successful?: BoolFilter<"PasswordResetAttempt"> | boolean
  }, "id">

  export type PasswordResetAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    attemptedAt?: SortOrder
    successful?: SortOrder
    _count?: PasswordResetAttemptCountOrderByAggregateInput
    _max?: PasswordResetAttemptMaxOrderByAggregateInput
    _min?: PasswordResetAttemptMinOrderByAggregateInput
  }

  export type PasswordResetAttemptScalarWhereWithAggregatesInput = {
    AND?: PasswordResetAttemptScalarWhereWithAggregatesInput | PasswordResetAttemptScalarWhereWithAggregatesInput[]
    OR?: PasswordResetAttemptScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetAttemptScalarWhereWithAggregatesInput | PasswordResetAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetAttempt"> | string
    email?: StringWithAggregatesFilter<"PasswordResetAttempt"> | string
    ipAddress?: StringWithAggregatesFilter<"PasswordResetAttempt"> | string
    attemptedAt?: DateTimeWithAggregatesFilter<"PasswordResetAttempt"> | Date | string
    successful?: BoolWithAggregatesFilter<"PasswordResetAttempt"> | boolean
  }

  export type SecurityAuditLogWhereInput = {
    AND?: SecurityAuditLogWhereInput | SecurityAuditLogWhereInput[]
    OR?: SecurityAuditLogWhereInput[]
    NOT?: SecurityAuditLogWhereInput | SecurityAuditLogWhereInput[]
    id?: StringFilter<"SecurityAuditLog"> | string
    userId?: StringNullableFilter<"SecurityAuditLog"> | string | null
    eventType?: StringFilter<"SecurityAuditLog"> | string
    ipAddress?: StringNullableFilter<"SecurityAuditLog"> | string | null
    userAgent?: StringNullableFilter<"SecurityAuditLog"> | string | null
    metadata?: JsonNullableFilter<"SecurityAuditLog">
    createdAt?: DateTimeFilter<"SecurityAuditLog"> | Date | string
  }

  export type SecurityAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SecurityAuditLogWhereInput | SecurityAuditLogWhereInput[]
    OR?: SecurityAuditLogWhereInput[]
    NOT?: SecurityAuditLogWhereInput | SecurityAuditLogWhereInput[]
    userId?: StringNullableFilter<"SecurityAuditLog"> | string | null
    eventType?: StringFilter<"SecurityAuditLog"> | string
    ipAddress?: StringNullableFilter<"SecurityAuditLog"> | string | null
    userAgent?: StringNullableFilter<"SecurityAuditLog"> | string | null
    metadata?: JsonNullableFilter<"SecurityAuditLog">
    createdAt?: DateTimeFilter<"SecurityAuditLog"> | Date | string
  }, "id">

  export type SecurityAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SecurityAuditLogCountOrderByAggregateInput
    _max?: SecurityAuditLogMaxOrderByAggregateInput
    _min?: SecurityAuditLogMinOrderByAggregateInput
  }

  export type SecurityAuditLogScalarWhereWithAggregatesInput = {
    AND?: SecurityAuditLogScalarWhereWithAggregatesInput | SecurityAuditLogScalarWhereWithAggregatesInput[]
    OR?: SecurityAuditLogScalarWhereWithAggregatesInput[]
    NOT?: SecurityAuditLogScalarWhereWithAggregatesInput | SecurityAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SecurityAuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"SecurityAuditLog"> | string | null
    eventType?: StringWithAggregatesFilter<"SecurityAuditLog"> | string
    ipAddress?: StringNullableWithAggregatesFilter<"SecurityAuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"SecurityAuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SecurityAuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"SecurityAuditLog"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    slug?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    organisationId?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    createdById?: StringFilter<"Team"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
    casePermissions?: CaseTeamPermissionListRelationFilter
    patternPermissions?: PatternTeamPermissionListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    organisationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
    casePermissions?: CaseTeamPermissionOrderByRelationAggregateInput
    patternPermissions?: PatternTeamPermissionOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    organisationId?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    createdById?: StringFilter<"Team"> | string
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
    casePermissions?: CaseTeamPermissionListRelationFilter
    patternPermissions?: PatternTeamPermissionListRelationFilter
  }, "id" | "slug">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    organisationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    slug?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    organisationId?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    createdById?: StringWithAggregatesFilter<"Team"> | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    invitedById?: StringNullableFilter<"TeamMember"> | string | null
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedById?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    invitedById?: StringNullableFilter<"TeamMember"> | string | null
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedById?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    userId?: StringWithAggregatesFilter<"TeamMember"> | string
    role?: EnumTeamRoleWithAggregatesFilter<"TeamMember"> | $Enums.TeamRole
    invitedById?: StringNullableWithAggregatesFilter<"TeamMember"> | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
  }

  export type AssuranceCaseWhereInput = {
    AND?: AssuranceCaseWhereInput | AssuranceCaseWhereInput[]
    OR?: AssuranceCaseWhereInput[]
    NOT?: AssuranceCaseWhereInput | AssuranceCaseWhereInput[]
    id?: StringFilter<"AssuranceCase"> | string
    name?: StringFilter<"AssuranceCase"> | string
    description?: StringFilter<"AssuranceCase"> | string
    createdById?: StringFilter<"AssuranceCase"> | string
    mode?: EnumCaseModeFilter<"AssuranceCase"> | $Enums.CaseMode
    colorProfile?: StringFilter<"AssuranceCase"> | string
    lockUuid?: StringNullableFilter<"AssuranceCase"> | string | null
    lockedById?: StringNullableFilter<"AssuranceCase"> | string | null
    lockedAt?: DateTimeNullableFilter<"AssuranceCase"> | Date | string | null
    sourcePatternId?: StringNullableFilter<"AssuranceCase"> | string | null
    createdAt?: DateTimeFilter<"AssuranceCase"> | Date | string
    updatedAt?: DateTimeFilter<"AssuranceCase"> | Date | string
    published?: BoolFilter<"AssuranceCase"> | boolean
    publishedAt?: DateTimeNullableFilter<"AssuranceCase"> | Date | string | null
    publishStatus?: EnumPublishStatusFilter<"AssuranceCase"> | $Enums.PublishStatus
    markedReadyAt?: DateTimeNullableFilter<"AssuranceCase"> | Date | string | null
    markedReadyById?: StringNullableFilter<"AssuranceCase"> | string | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    markedReadyBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sourcePattern?: XOR<ArgumentPatternNullableScalarRelationFilter, ArgumentPatternWhereInput> | null
    elements?: AssuranceElementListRelationFilter
    userPermissions?: CasePermissionListRelationFilter
    teamPermissions?: CaseTeamPermissionListRelationFilter
    invites?: CaseInviteListRelationFilter
    comments?: CommentListRelationFilter
    caseImage?: XOR<CaseImageNullableScalarRelationFilter, CaseImageWhereInput> | null
    caseTypes?: CaseTypeAssignmentListRelationFilter
    sourceReleases?: ReleaseListRelationFilter
    publishedReleases?: ReleaseListRelationFilter
    publishedVersions?: PublishedAssuranceCaseListRelationFilter
    embeddedIn?: AssuranceElementListRelationFilter
  }

  export type AssuranceCaseOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    mode?: SortOrder
    colorProfile?: SortOrder
    lockUuid?: SortOrderInput | SortOrder
    lockedById?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    sourcePatternId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    publishStatus?: SortOrder
    markedReadyAt?: SortOrderInput | SortOrder
    markedReadyById?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    markedReadyBy?: UserOrderByWithRelationInput
    sourcePattern?: ArgumentPatternOrderByWithRelationInput
    elements?: AssuranceElementOrderByRelationAggregateInput
    userPermissions?: CasePermissionOrderByRelationAggregateInput
    teamPermissions?: CaseTeamPermissionOrderByRelationAggregateInput
    invites?: CaseInviteOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    caseImage?: CaseImageOrderByWithRelationInput
    caseTypes?: CaseTypeAssignmentOrderByRelationAggregateInput
    sourceReleases?: ReleaseOrderByRelationAggregateInput
    publishedReleases?: ReleaseOrderByRelationAggregateInput
    publishedVersions?: PublishedAssuranceCaseOrderByRelationAggregateInput
    embeddedIn?: AssuranceElementOrderByRelationAggregateInput
  }

  export type AssuranceCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssuranceCaseWhereInput | AssuranceCaseWhereInput[]
    OR?: AssuranceCaseWhereInput[]
    NOT?: AssuranceCaseWhereInput | AssuranceCaseWhereInput[]
    name?: StringFilter<"AssuranceCase"> | string
    description?: StringFilter<"AssuranceCase"> | string
    createdById?: StringFilter<"AssuranceCase"> | string
    mode?: EnumCaseModeFilter<"AssuranceCase"> | $Enums.CaseMode
    colorProfile?: StringFilter<"AssuranceCase"> | string
    lockUuid?: StringNullableFilter<"AssuranceCase"> | string | null
    lockedById?: StringNullableFilter<"AssuranceCase"> | string | null
    lockedAt?: DateTimeNullableFilter<"AssuranceCase"> | Date | string | null
    sourcePatternId?: StringNullableFilter<"AssuranceCase"> | string | null
    createdAt?: DateTimeFilter<"AssuranceCase"> | Date | string
    updatedAt?: DateTimeFilter<"AssuranceCase"> | Date | string
    published?: BoolFilter<"AssuranceCase"> | boolean
    publishedAt?: DateTimeNullableFilter<"AssuranceCase"> | Date | string | null
    publishStatus?: EnumPublishStatusFilter<"AssuranceCase"> | $Enums.PublishStatus
    markedReadyAt?: DateTimeNullableFilter<"AssuranceCase"> | Date | string | null
    markedReadyById?: StringNullableFilter<"AssuranceCase"> | string | null
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    markedReadyBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sourcePattern?: XOR<ArgumentPatternNullableScalarRelationFilter, ArgumentPatternWhereInput> | null
    elements?: AssuranceElementListRelationFilter
    userPermissions?: CasePermissionListRelationFilter
    teamPermissions?: CaseTeamPermissionListRelationFilter
    invites?: CaseInviteListRelationFilter
    comments?: CommentListRelationFilter
    caseImage?: XOR<CaseImageNullableScalarRelationFilter, CaseImageWhereInput> | null
    caseTypes?: CaseTypeAssignmentListRelationFilter
    sourceReleases?: ReleaseListRelationFilter
    publishedReleases?: ReleaseListRelationFilter
    publishedVersions?: PublishedAssuranceCaseListRelationFilter
    embeddedIn?: AssuranceElementListRelationFilter
  }, "id">

  export type AssuranceCaseOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    mode?: SortOrder
    colorProfile?: SortOrder
    lockUuid?: SortOrderInput | SortOrder
    lockedById?: SortOrderInput | SortOrder
    lockedAt?: SortOrderInput | SortOrder
    sourcePatternId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    publishStatus?: SortOrder
    markedReadyAt?: SortOrderInput | SortOrder
    markedReadyById?: SortOrderInput | SortOrder
    _count?: AssuranceCaseCountOrderByAggregateInput
    _max?: AssuranceCaseMaxOrderByAggregateInput
    _min?: AssuranceCaseMinOrderByAggregateInput
  }

  export type AssuranceCaseScalarWhereWithAggregatesInput = {
    AND?: AssuranceCaseScalarWhereWithAggregatesInput | AssuranceCaseScalarWhereWithAggregatesInput[]
    OR?: AssuranceCaseScalarWhereWithAggregatesInput[]
    NOT?: AssuranceCaseScalarWhereWithAggregatesInput | AssuranceCaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssuranceCase"> | string
    name?: StringWithAggregatesFilter<"AssuranceCase"> | string
    description?: StringWithAggregatesFilter<"AssuranceCase"> | string
    createdById?: StringWithAggregatesFilter<"AssuranceCase"> | string
    mode?: EnumCaseModeWithAggregatesFilter<"AssuranceCase"> | $Enums.CaseMode
    colorProfile?: StringWithAggregatesFilter<"AssuranceCase"> | string
    lockUuid?: StringNullableWithAggregatesFilter<"AssuranceCase"> | string | null
    lockedById?: StringNullableWithAggregatesFilter<"AssuranceCase"> | string | null
    lockedAt?: DateTimeNullableWithAggregatesFilter<"AssuranceCase"> | Date | string | null
    sourcePatternId?: StringNullableWithAggregatesFilter<"AssuranceCase"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AssuranceCase"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssuranceCase"> | Date | string
    published?: BoolWithAggregatesFilter<"AssuranceCase"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"AssuranceCase"> | Date | string | null
    publishStatus?: EnumPublishStatusWithAggregatesFilter<"AssuranceCase"> | $Enums.PublishStatus
    markedReadyAt?: DateTimeNullableWithAggregatesFilter<"AssuranceCase"> | Date | string | null
    markedReadyById?: StringNullableWithAggregatesFilter<"AssuranceCase"> | string | null
  }

  export type CasePermissionWhereInput = {
    AND?: CasePermissionWhereInput | CasePermissionWhereInput[]
    OR?: CasePermissionWhereInput[]
    NOT?: CasePermissionWhereInput | CasePermissionWhereInput[]
    id?: StringFilter<"CasePermission"> | string
    caseId?: StringFilter<"CasePermission"> | string
    userId?: StringFilter<"CasePermission"> | string
    permission?: EnumPermissionLevelFilter<"CasePermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"CasePermission"> | string
    grantedAt?: DateTimeFilter<"CasePermission"> | Date | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    grantedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CasePermissionOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    case?: AssuranceCaseOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    grantedBy?: UserOrderByWithRelationInput
  }

  export type CasePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    caseId_userId?: CasePermissionCaseIdUserIdCompoundUniqueInput
    AND?: CasePermissionWhereInput | CasePermissionWhereInput[]
    OR?: CasePermissionWhereInput[]
    NOT?: CasePermissionWhereInput | CasePermissionWhereInput[]
    caseId?: StringFilter<"CasePermission"> | string
    userId?: StringFilter<"CasePermission"> | string
    permission?: EnumPermissionLevelFilter<"CasePermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"CasePermission"> | string
    grantedAt?: DateTimeFilter<"CasePermission"> | Date | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    grantedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "caseId_userId">

  export type CasePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    _count?: CasePermissionCountOrderByAggregateInput
    _max?: CasePermissionMaxOrderByAggregateInput
    _min?: CasePermissionMinOrderByAggregateInput
  }

  export type CasePermissionScalarWhereWithAggregatesInput = {
    AND?: CasePermissionScalarWhereWithAggregatesInput | CasePermissionScalarWhereWithAggregatesInput[]
    OR?: CasePermissionScalarWhereWithAggregatesInput[]
    NOT?: CasePermissionScalarWhereWithAggregatesInput | CasePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CasePermission"> | string
    caseId?: StringWithAggregatesFilter<"CasePermission"> | string
    userId?: StringWithAggregatesFilter<"CasePermission"> | string
    permission?: EnumPermissionLevelWithAggregatesFilter<"CasePermission"> | $Enums.PermissionLevel
    grantedById?: StringWithAggregatesFilter<"CasePermission"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"CasePermission"> | Date | string
  }

  export type CaseTeamPermissionWhereInput = {
    AND?: CaseTeamPermissionWhereInput | CaseTeamPermissionWhereInput[]
    OR?: CaseTeamPermissionWhereInput[]
    NOT?: CaseTeamPermissionWhereInput | CaseTeamPermissionWhereInput[]
    id?: StringFilter<"CaseTeamPermission"> | string
    caseId?: StringFilter<"CaseTeamPermission"> | string
    teamId?: StringFilter<"CaseTeamPermission"> | string
    permission?: EnumPermissionLevelFilter<"CaseTeamPermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"CaseTeamPermission"> | string
    grantedAt?: DateTimeFilter<"CaseTeamPermission"> | Date | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type CaseTeamPermissionOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    case?: AssuranceCaseOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type CaseTeamPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    caseId_teamId?: CaseTeamPermissionCaseIdTeamIdCompoundUniqueInput
    AND?: CaseTeamPermissionWhereInput | CaseTeamPermissionWhereInput[]
    OR?: CaseTeamPermissionWhereInput[]
    NOT?: CaseTeamPermissionWhereInput | CaseTeamPermissionWhereInput[]
    caseId?: StringFilter<"CaseTeamPermission"> | string
    teamId?: StringFilter<"CaseTeamPermission"> | string
    permission?: EnumPermissionLevelFilter<"CaseTeamPermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"CaseTeamPermission"> | string
    grantedAt?: DateTimeFilter<"CaseTeamPermission"> | Date | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "caseId_teamId">

  export type CaseTeamPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    _count?: CaseTeamPermissionCountOrderByAggregateInput
    _max?: CaseTeamPermissionMaxOrderByAggregateInput
    _min?: CaseTeamPermissionMinOrderByAggregateInput
  }

  export type CaseTeamPermissionScalarWhereWithAggregatesInput = {
    AND?: CaseTeamPermissionScalarWhereWithAggregatesInput | CaseTeamPermissionScalarWhereWithAggregatesInput[]
    OR?: CaseTeamPermissionScalarWhereWithAggregatesInput[]
    NOT?: CaseTeamPermissionScalarWhereWithAggregatesInput | CaseTeamPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseTeamPermission"> | string
    caseId?: StringWithAggregatesFilter<"CaseTeamPermission"> | string
    teamId?: StringWithAggregatesFilter<"CaseTeamPermission"> | string
    permission?: EnumPermissionLevelWithAggregatesFilter<"CaseTeamPermission"> | $Enums.PermissionLevel
    grantedById?: StringWithAggregatesFilter<"CaseTeamPermission"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"CaseTeamPermission"> | Date | string
  }

  export type CaseInviteWhereInput = {
    AND?: CaseInviteWhereInput | CaseInviteWhereInput[]
    OR?: CaseInviteWhereInput[]
    NOT?: CaseInviteWhereInput | CaseInviteWhereInput[]
    id?: StringFilter<"CaseInvite"> | string
    caseId?: StringFilter<"CaseInvite"> | string
    email?: StringFilter<"CaseInvite"> | string
    permission?: EnumPermissionLevelFilter<"CaseInvite"> | $Enums.PermissionLevel
    inviteToken?: StringFilter<"CaseInvite"> | string
    inviteExpiresAt?: DateTimeFilter<"CaseInvite"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"CaseInvite"> | Date | string | null
    acceptedById?: StringNullableFilter<"CaseInvite"> | string | null
    invitedById?: StringFilter<"CaseInvite"> | string
    createdAt?: DateTimeFilter<"CaseInvite"> | Date | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
  }

  export type CaseInviteOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    email?: SortOrder
    permission?: SortOrder
    inviteToken?: SortOrder
    inviteExpiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    acceptedById?: SortOrderInput | SortOrder
    invitedById?: SortOrder
    createdAt?: SortOrder
    case?: AssuranceCaseOrderByWithRelationInput
  }

  export type CaseInviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inviteToken?: string
    AND?: CaseInviteWhereInput | CaseInviteWhereInput[]
    OR?: CaseInviteWhereInput[]
    NOT?: CaseInviteWhereInput | CaseInviteWhereInput[]
    caseId?: StringFilter<"CaseInvite"> | string
    email?: StringFilter<"CaseInvite"> | string
    permission?: EnumPermissionLevelFilter<"CaseInvite"> | $Enums.PermissionLevel
    inviteExpiresAt?: DateTimeFilter<"CaseInvite"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"CaseInvite"> | Date | string | null
    acceptedById?: StringNullableFilter<"CaseInvite"> | string | null
    invitedById?: StringFilter<"CaseInvite"> | string
    createdAt?: DateTimeFilter<"CaseInvite"> | Date | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
  }, "id" | "inviteToken">

  export type CaseInviteOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    email?: SortOrder
    permission?: SortOrder
    inviteToken?: SortOrder
    inviteExpiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    acceptedById?: SortOrderInput | SortOrder
    invitedById?: SortOrder
    createdAt?: SortOrder
    _count?: CaseInviteCountOrderByAggregateInput
    _max?: CaseInviteMaxOrderByAggregateInput
    _min?: CaseInviteMinOrderByAggregateInput
  }

  export type CaseInviteScalarWhereWithAggregatesInput = {
    AND?: CaseInviteScalarWhereWithAggregatesInput | CaseInviteScalarWhereWithAggregatesInput[]
    OR?: CaseInviteScalarWhereWithAggregatesInput[]
    NOT?: CaseInviteScalarWhereWithAggregatesInput | CaseInviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseInvite"> | string
    caseId?: StringWithAggregatesFilter<"CaseInvite"> | string
    email?: StringWithAggregatesFilter<"CaseInvite"> | string
    permission?: EnumPermissionLevelWithAggregatesFilter<"CaseInvite"> | $Enums.PermissionLevel
    inviteToken?: StringWithAggregatesFilter<"CaseInvite"> | string
    inviteExpiresAt?: DateTimeWithAggregatesFilter<"CaseInvite"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"CaseInvite"> | Date | string | null
    acceptedById?: StringNullableWithAggregatesFilter<"CaseInvite"> | string | null
    invitedById?: StringWithAggregatesFilter<"CaseInvite"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CaseInvite"> | Date | string
  }

  export type AssuranceElementWhereInput = {
    AND?: AssuranceElementWhereInput | AssuranceElementWhereInput[]
    OR?: AssuranceElementWhereInput[]
    NOT?: AssuranceElementWhereInput | AssuranceElementWhereInput[]
    id?: StringFilter<"AssuranceElement"> | string
    caseId?: StringFilter<"AssuranceElement"> | string
    elementType?: EnumElementTypeFilter<"AssuranceElement"> | $Enums.ElementType
    role?: EnumElementRoleNullableFilter<"AssuranceElement"> | $Enums.ElementRole | null
    parentId?: StringNullableFilter<"AssuranceElement"> | string | null
    name?: StringNullableFilter<"AssuranceElement"> | string | null
    description?: StringFilter<"AssuranceElement"> | string
    assumption?: StringNullableFilter<"AssuranceElement"> | string | null
    justification?: StringNullableFilter<"AssuranceElement"> | string | null
    url?: StringNullableFilter<"AssuranceElement"> | string | null
    moduleReferenceId?: StringNullableFilter<"AssuranceElement"> | string | null
    moduleEmbedType?: EnumModuleEmbedTypeNullableFilter<"AssuranceElement"> | $Enums.ModuleEmbedType | null
    modulePublicSummary?: StringNullableFilter<"AssuranceElement"> | string | null
    fromPattern?: BoolFilter<"AssuranceElement"> | boolean
    modifiedFromPattern?: BoolFilter<"AssuranceElement"> | boolean
    inSandbox?: BoolFilter<"AssuranceElement"> | boolean
    isDefeater?: BoolFilter<"AssuranceElement"> | boolean
    defeatsElementId?: StringNullableFilter<"AssuranceElement"> | string | null
    level?: IntNullableFilter<"AssuranceElement"> | number | null
    createdAt?: DateTimeFilter<"AssuranceElement"> | Date | string
    updatedAt?: DateTimeFilter<"AssuranceElement"> | Date | string
    createdById?: StringFilter<"AssuranceElement"> | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<AssuranceElementNullableScalarRelationFilter, AssuranceElementWhereInput> | null
    children?: AssuranceElementListRelationFilter
    defeatsElement?: XOR<AssuranceElementNullableScalarRelationFilter, AssuranceElementWhereInput> | null
    defeatedBy?: AssuranceElementListRelationFilter
    moduleReference?: XOR<AssuranceCaseNullableScalarRelationFilter, AssuranceCaseWhereInput> | null
    evidenceLinksFrom?: EvidenceLinkListRelationFilter
    evidenceLinksTo?: EvidenceLinkListRelationFilter
    comments?: CommentListRelationFilter
    releaseComments?: ReleaseCommentListRelationFilter
  }

  export type AssuranceElementOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    elementType?: SortOrder
    role?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrder
    assumption?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    moduleReferenceId?: SortOrderInput | SortOrder
    moduleEmbedType?: SortOrderInput | SortOrder
    modulePublicSummary?: SortOrderInput | SortOrder
    fromPattern?: SortOrder
    modifiedFromPattern?: SortOrder
    inSandbox?: SortOrder
    isDefeater?: SortOrder
    defeatsElementId?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    case?: AssuranceCaseOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    parent?: AssuranceElementOrderByWithRelationInput
    children?: AssuranceElementOrderByRelationAggregateInput
    defeatsElement?: AssuranceElementOrderByWithRelationInput
    defeatedBy?: AssuranceElementOrderByRelationAggregateInput
    moduleReference?: AssuranceCaseOrderByWithRelationInput
    evidenceLinksFrom?: EvidenceLinkOrderByRelationAggregateInput
    evidenceLinksTo?: EvidenceLinkOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    releaseComments?: ReleaseCommentOrderByRelationAggregateInput
  }

  export type AssuranceElementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AssuranceElementWhereInput | AssuranceElementWhereInput[]
    OR?: AssuranceElementWhereInput[]
    NOT?: AssuranceElementWhereInput | AssuranceElementWhereInput[]
    caseId?: StringFilter<"AssuranceElement"> | string
    elementType?: EnumElementTypeFilter<"AssuranceElement"> | $Enums.ElementType
    role?: EnumElementRoleNullableFilter<"AssuranceElement"> | $Enums.ElementRole | null
    parentId?: StringNullableFilter<"AssuranceElement"> | string | null
    name?: StringNullableFilter<"AssuranceElement"> | string | null
    description?: StringFilter<"AssuranceElement"> | string
    assumption?: StringNullableFilter<"AssuranceElement"> | string | null
    justification?: StringNullableFilter<"AssuranceElement"> | string | null
    url?: StringNullableFilter<"AssuranceElement"> | string | null
    moduleReferenceId?: StringNullableFilter<"AssuranceElement"> | string | null
    moduleEmbedType?: EnumModuleEmbedTypeNullableFilter<"AssuranceElement"> | $Enums.ModuleEmbedType | null
    modulePublicSummary?: StringNullableFilter<"AssuranceElement"> | string | null
    fromPattern?: BoolFilter<"AssuranceElement"> | boolean
    modifiedFromPattern?: BoolFilter<"AssuranceElement"> | boolean
    inSandbox?: BoolFilter<"AssuranceElement"> | boolean
    isDefeater?: BoolFilter<"AssuranceElement"> | boolean
    defeatsElementId?: StringNullableFilter<"AssuranceElement"> | string | null
    level?: IntNullableFilter<"AssuranceElement"> | number | null
    createdAt?: DateTimeFilter<"AssuranceElement"> | Date | string
    updatedAt?: DateTimeFilter<"AssuranceElement"> | Date | string
    createdById?: StringFilter<"AssuranceElement"> | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<AssuranceElementNullableScalarRelationFilter, AssuranceElementWhereInput> | null
    children?: AssuranceElementListRelationFilter
    defeatsElement?: XOR<AssuranceElementNullableScalarRelationFilter, AssuranceElementWhereInput> | null
    defeatedBy?: AssuranceElementListRelationFilter
    moduleReference?: XOR<AssuranceCaseNullableScalarRelationFilter, AssuranceCaseWhereInput> | null
    evidenceLinksFrom?: EvidenceLinkListRelationFilter
    evidenceLinksTo?: EvidenceLinkListRelationFilter
    comments?: CommentListRelationFilter
    releaseComments?: ReleaseCommentListRelationFilter
  }, "id">

  export type AssuranceElementOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    elementType?: SortOrder
    role?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrder
    assumption?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    moduleReferenceId?: SortOrderInput | SortOrder
    moduleEmbedType?: SortOrderInput | SortOrder
    modulePublicSummary?: SortOrderInput | SortOrder
    fromPattern?: SortOrder
    modifiedFromPattern?: SortOrder
    inSandbox?: SortOrder
    isDefeater?: SortOrder
    defeatsElementId?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
    _count?: AssuranceElementCountOrderByAggregateInput
    _avg?: AssuranceElementAvgOrderByAggregateInput
    _max?: AssuranceElementMaxOrderByAggregateInput
    _min?: AssuranceElementMinOrderByAggregateInput
    _sum?: AssuranceElementSumOrderByAggregateInput
  }

  export type AssuranceElementScalarWhereWithAggregatesInput = {
    AND?: AssuranceElementScalarWhereWithAggregatesInput | AssuranceElementScalarWhereWithAggregatesInput[]
    OR?: AssuranceElementScalarWhereWithAggregatesInput[]
    NOT?: AssuranceElementScalarWhereWithAggregatesInput | AssuranceElementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AssuranceElement"> | string
    caseId?: StringWithAggregatesFilter<"AssuranceElement"> | string
    elementType?: EnumElementTypeWithAggregatesFilter<"AssuranceElement"> | $Enums.ElementType
    role?: EnumElementRoleNullableWithAggregatesFilter<"AssuranceElement"> | $Enums.ElementRole | null
    parentId?: StringNullableWithAggregatesFilter<"AssuranceElement"> | string | null
    name?: StringNullableWithAggregatesFilter<"AssuranceElement"> | string | null
    description?: StringWithAggregatesFilter<"AssuranceElement"> | string
    assumption?: StringNullableWithAggregatesFilter<"AssuranceElement"> | string | null
    justification?: StringNullableWithAggregatesFilter<"AssuranceElement"> | string | null
    url?: StringNullableWithAggregatesFilter<"AssuranceElement"> | string | null
    moduleReferenceId?: StringNullableWithAggregatesFilter<"AssuranceElement"> | string | null
    moduleEmbedType?: EnumModuleEmbedTypeNullableWithAggregatesFilter<"AssuranceElement"> | $Enums.ModuleEmbedType | null
    modulePublicSummary?: StringNullableWithAggregatesFilter<"AssuranceElement"> | string | null
    fromPattern?: BoolWithAggregatesFilter<"AssuranceElement"> | boolean
    modifiedFromPattern?: BoolWithAggregatesFilter<"AssuranceElement"> | boolean
    inSandbox?: BoolWithAggregatesFilter<"AssuranceElement"> | boolean
    isDefeater?: BoolWithAggregatesFilter<"AssuranceElement"> | boolean
    defeatsElementId?: StringNullableWithAggregatesFilter<"AssuranceElement"> | string | null
    level?: IntNullableWithAggregatesFilter<"AssuranceElement"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AssuranceElement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AssuranceElement"> | Date | string
    createdById?: StringWithAggregatesFilter<"AssuranceElement"> | string
  }

  export type EvidenceLinkWhereInput = {
    AND?: EvidenceLinkWhereInput | EvidenceLinkWhereInput[]
    OR?: EvidenceLinkWhereInput[]
    NOT?: EvidenceLinkWhereInput | EvidenceLinkWhereInput[]
    id?: StringFilter<"EvidenceLink"> | string
    evidenceId?: StringFilter<"EvidenceLink"> | string
    claimId?: StringFilter<"EvidenceLink"> | string
    createdAt?: DateTimeFilter<"EvidenceLink"> | Date | string
    evidence?: XOR<AssuranceElementScalarRelationFilter, AssuranceElementWhereInput>
    claim?: XOR<AssuranceElementScalarRelationFilter, AssuranceElementWhereInput>
  }

  export type EvidenceLinkOrderByWithRelationInput = {
    id?: SortOrder
    evidenceId?: SortOrder
    claimId?: SortOrder
    createdAt?: SortOrder
    evidence?: AssuranceElementOrderByWithRelationInput
    claim?: AssuranceElementOrderByWithRelationInput
  }

  export type EvidenceLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    evidenceId_claimId?: EvidenceLinkEvidenceIdClaimIdCompoundUniqueInput
    AND?: EvidenceLinkWhereInput | EvidenceLinkWhereInput[]
    OR?: EvidenceLinkWhereInput[]
    NOT?: EvidenceLinkWhereInput | EvidenceLinkWhereInput[]
    evidenceId?: StringFilter<"EvidenceLink"> | string
    claimId?: StringFilter<"EvidenceLink"> | string
    createdAt?: DateTimeFilter<"EvidenceLink"> | Date | string
    evidence?: XOR<AssuranceElementScalarRelationFilter, AssuranceElementWhereInput>
    claim?: XOR<AssuranceElementScalarRelationFilter, AssuranceElementWhereInput>
  }, "id" | "evidenceId_claimId">

  export type EvidenceLinkOrderByWithAggregationInput = {
    id?: SortOrder
    evidenceId?: SortOrder
    claimId?: SortOrder
    createdAt?: SortOrder
    _count?: EvidenceLinkCountOrderByAggregateInput
    _max?: EvidenceLinkMaxOrderByAggregateInput
    _min?: EvidenceLinkMinOrderByAggregateInput
  }

  export type EvidenceLinkScalarWhereWithAggregatesInput = {
    AND?: EvidenceLinkScalarWhereWithAggregatesInput | EvidenceLinkScalarWhereWithAggregatesInput[]
    OR?: EvidenceLinkScalarWhereWithAggregatesInput[]
    NOT?: EvidenceLinkScalarWhereWithAggregatesInput | EvidenceLinkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EvidenceLink"> | string
    evidenceId?: StringWithAggregatesFilter<"EvidenceLink"> | string
    claimId?: StringWithAggregatesFilter<"EvidenceLink"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EvidenceLink"> | Date | string
  }

  export type ArgumentPatternWhereInput = {
    AND?: ArgumentPatternWhereInput | ArgumentPatternWhereInput[]
    OR?: ArgumentPatternWhereInput[]
    NOT?: ArgumentPatternWhereInput | ArgumentPatternWhereInput[]
    id?: StringFilter<"ArgumentPattern"> | string
    name?: StringFilter<"ArgumentPattern"> | string
    description?: StringFilter<"ArgumentPattern"> | string
    version?: StringFilter<"ArgumentPattern"> | string
    category?: StringNullableFilter<"ArgumentPattern"> | string | null
    tags?: StringNullableListFilter<"ArgumentPattern">
    published?: BoolFilter<"ArgumentPattern"> | boolean
    publishedAt?: DateTimeNullableFilter<"ArgumentPattern"> | Date | string | null
    createdById?: StringFilter<"ArgumentPattern"> | string
    createdAt?: DateTimeFilter<"ArgumentPattern"> | Date | string
    updatedAt?: DateTimeFilter<"ArgumentPattern"> | Date | string
    elements?: PatternElementListRelationFilter
    userPermissions?: PatternPermissionListRelationFilter
    teamPermissions?: PatternTeamPermissionListRelationFilter
    derivedCases?: AssuranceCaseListRelationFilter
  }

  export type ArgumentPatternOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    elements?: PatternElementOrderByRelationAggregateInput
    userPermissions?: PatternPermissionOrderByRelationAggregateInput
    teamPermissions?: PatternTeamPermissionOrderByRelationAggregateInput
    derivedCases?: AssuranceCaseOrderByRelationAggregateInput
  }

  export type ArgumentPatternWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ArgumentPatternWhereInput | ArgumentPatternWhereInput[]
    OR?: ArgumentPatternWhereInput[]
    NOT?: ArgumentPatternWhereInput | ArgumentPatternWhereInput[]
    name?: StringFilter<"ArgumentPattern"> | string
    description?: StringFilter<"ArgumentPattern"> | string
    version?: StringFilter<"ArgumentPattern"> | string
    category?: StringNullableFilter<"ArgumentPattern"> | string | null
    tags?: StringNullableListFilter<"ArgumentPattern">
    published?: BoolFilter<"ArgumentPattern"> | boolean
    publishedAt?: DateTimeNullableFilter<"ArgumentPattern"> | Date | string | null
    createdById?: StringFilter<"ArgumentPattern"> | string
    createdAt?: DateTimeFilter<"ArgumentPattern"> | Date | string
    updatedAt?: DateTimeFilter<"ArgumentPattern"> | Date | string
    elements?: PatternElementListRelationFilter
    userPermissions?: PatternPermissionListRelationFilter
    teamPermissions?: PatternTeamPermissionListRelationFilter
    derivedCases?: AssuranceCaseListRelationFilter
  }, "id">

  export type ArgumentPatternOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ArgumentPatternCountOrderByAggregateInput
    _max?: ArgumentPatternMaxOrderByAggregateInput
    _min?: ArgumentPatternMinOrderByAggregateInput
  }

  export type ArgumentPatternScalarWhereWithAggregatesInput = {
    AND?: ArgumentPatternScalarWhereWithAggregatesInput | ArgumentPatternScalarWhereWithAggregatesInput[]
    OR?: ArgumentPatternScalarWhereWithAggregatesInput[]
    NOT?: ArgumentPatternScalarWhereWithAggregatesInput | ArgumentPatternScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ArgumentPattern"> | string
    name?: StringWithAggregatesFilter<"ArgumentPattern"> | string
    description?: StringWithAggregatesFilter<"ArgumentPattern"> | string
    version?: StringWithAggregatesFilter<"ArgumentPattern"> | string
    category?: StringNullableWithAggregatesFilter<"ArgumentPattern"> | string | null
    tags?: StringNullableListFilter<"ArgumentPattern">
    published?: BoolWithAggregatesFilter<"ArgumentPattern"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"ArgumentPattern"> | Date | string | null
    createdById?: StringWithAggregatesFilter<"ArgumentPattern"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ArgumentPattern"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ArgumentPattern"> | Date | string
  }

  export type PatternElementWhereInput = {
    AND?: PatternElementWhereInput | PatternElementWhereInput[]
    OR?: PatternElementWhereInput[]
    NOT?: PatternElementWhereInput | PatternElementWhereInput[]
    id?: StringFilter<"PatternElement"> | string
    patternId?: StringFilter<"PatternElement"> | string
    elementType?: EnumElementTypeFilter<"PatternElement"> | $Enums.ElementType
    role?: EnumElementRoleNullableFilter<"PatternElement"> | $Enums.ElementRole | null
    parentId?: StringNullableFilter<"PatternElement"> | string | null
    name?: StringNullableFilter<"PatternElement"> | string | null
    description?: StringFilter<"PatternElement"> | string
    assumption?: StringNullableFilter<"PatternElement"> | string | null
    justification?: StringNullableFilter<"PatternElement"> | string | null
    url?: StringNullableFilter<"PatternElement"> | string | null
    isPlaceholder?: BoolFilter<"PatternElement"> | boolean
    placeholderHint?: StringNullableFilter<"PatternElement"> | string | null
    displayOrder?: IntFilter<"PatternElement"> | number
    createdAt?: DateTimeFilter<"PatternElement"> | Date | string
    updatedAt?: DateTimeFilter<"PatternElement"> | Date | string
    pattern?: XOR<ArgumentPatternScalarRelationFilter, ArgumentPatternWhereInput>
    parent?: XOR<PatternElementNullableScalarRelationFilter, PatternElementWhereInput> | null
    children?: PatternElementListRelationFilter
  }

  export type PatternElementOrderByWithRelationInput = {
    id?: SortOrder
    patternId?: SortOrder
    elementType?: SortOrder
    role?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrder
    assumption?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    isPlaceholder?: SortOrder
    placeholderHint?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pattern?: ArgumentPatternOrderByWithRelationInput
    parent?: PatternElementOrderByWithRelationInput
    children?: PatternElementOrderByRelationAggregateInput
  }

  export type PatternElementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatternElementWhereInput | PatternElementWhereInput[]
    OR?: PatternElementWhereInput[]
    NOT?: PatternElementWhereInput | PatternElementWhereInput[]
    patternId?: StringFilter<"PatternElement"> | string
    elementType?: EnumElementTypeFilter<"PatternElement"> | $Enums.ElementType
    role?: EnumElementRoleNullableFilter<"PatternElement"> | $Enums.ElementRole | null
    parentId?: StringNullableFilter<"PatternElement"> | string | null
    name?: StringNullableFilter<"PatternElement"> | string | null
    description?: StringFilter<"PatternElement"> | string
    assumption?: StringNullableFilter<"PatternElement"> | string | null
    justification?: StringNullableFilter<"PatternElement"> | string | null
    url?: StringNullableFilter<"PatternElement"> | string | null
    isPlaceholder?: BoolFilter<"PatternElement"> | boolean
    placeholderHint?: StringNullableFilter<"PatternElement"> | string | null
    displayOrder?: IntFilter<"PatternElement"> | number
    createdAt?: DateTimeFilter<"PatternElement"> | Date | string
    updatedAt?: DateTimeFilter<"PatternElement"> | Date | string
    pattern?: XOR<ArgumentPatternScalarRelationFilter, ArgumentPatternWhereInput>
    parent?: XOR<PatternElementNullableScalarRelationFilter, PatternElementWhereInput> | null
    children?: PatternElementListRelationFilter
  }, "id">

  export type PatternElementOrderByWithAggregationInput = {
    id?: SortOrder
    patternId?: SortOrder
    elementType?: SortOrder
    role?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrder
    assumption?: SortOrderInput | SortOrder
    justification?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    isPlaceholder?: SortOrder
    placeholderHint?: SortOrderInput | SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatternElementCountOrderByAggregateInput
    _avg?: PatternElementAvgOrderByAggregateInput
    _max?: PatternElementMaxOrderByAggregateInput
    _min?: PatternElementMinOrderByAggregateInput
    _sum?: PatternElementSumOrderByAggregateInput
  }

  export type PatternElementScalarWhereWithAggregatesInput = {
    AND?: PatternElementScalarWhereWithAggregatesInput | PatternElementScalarWhereWithAggregatesInput[]
    OR?: PatternElementScalarWhereWithAggregatesInput[]
    NOT?: PatternElementScalarWhereWithAggregatesInput | PatternElementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatternElement"> | string
    patternId?: StringWithAggregatesFilter<"PatternElement"> | string
    elementType?: EnumElementTypeWithAggregatesFilter<"PatternElement"> | $Enums.ElementType
    role?: EnumElementRoleNullableWithAggregatesFilter<"PatternElement"> | $Enums.ElementRole | null
    parentId?: StringNullableWithAggregatesFilter<"PatternElement"> | string | null
    name?: StringNullableWithAggregatesFilter<"PatternElement"> | string | null
    description?: StringWithAggregatesFilter<"PatternElement"> | string
    assumption?: StringNullableWithAggregatesFilter<"PatternElement"> | string | null
    justification?: StringNullableWithAggregatesFilter<"PatternElement"> | string | null
    url?: StringNullableWithAggregatesFilter<"PatternElement"> | string | null
    isPlaceholder?: BoolWithAggregatesFilter<"PatternElement"> | boolean
    placeholderHint?: StringNullableWithAggregatesFilter<"PatternElement"> | string | null
    displayOrder?: IntWithAggregatesFilter<"PatternElement"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PatternElement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PatternElement"> | Date | string
  }

  export type PatternPermissionWhereInput = {
    AND?: PatternPermissionWhereInput | PatternPermissionWhereInput[]
    OR?: PatternPermissionWhereInput[]
    NOT?: PatternPermissionWhereInput | PatternPermissionWhereInput[]
    id?: StringFilter<"PatternPermission"> | string
    patternId?: StringFilter<"PatternPermission"> | string
    userId?: StringFilter<"PatternPermission"> | string
    permission?: EnumPermissionLevelFilter<"PatternPermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"PatternPermission"> | string
    grantedAt?: DateTimeFilter<"PatternPermission"> | Date | string
    pattern?: XOR<ArgumentPatternScalarRelationFilter, ArgumentPatternWhereInput>
  }

  export type PatternPermissionOrderByWithRelationInput = {
    id?: SortOrder
    patternId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    pattern?: ArgumentPatternOrderByWithRelationInput
  }

  export type PatternPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patternId_userId?: PatternPermissionPatternIdUserIdCompoundUniqueInput
    AND?: PatternPermissionWhereInput | PatternPermissionWhereInput[]
    OR?: PatternPermissionWhereInput[]
    NOT?: PatternPermissionWhereInput | PatternPermissionWhereInput[]
    patternId?: StringFilter<"PatternPermission"> | string
    userId?: StringFilter<"PatternPermission"> | string
    permission?: EnumPermissionLevelFilter<"PatternPermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"PatternPermission"> | string
    grantedAt?: DateTimeFilter<"PatternPermission"> | Date | string
    pattern?: XOR<ArgumentPatternScalarRelationFilter, ArgumentPatternWhereInput>
  }, "id" | "patternId_userId">

  export type PatternPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    patternId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    _count?: PatternPermissionCountOrderByAggregateInput
    _max?: PatternPermissionMaxOrderByAggregateInput
    _min?: PatternPermissionMinOrderByAggregateInput
  }

  export type PatternPermissionScalarWhereWithAggregatesInput = {
    AND?: PatternPermissionScalarWhereWithAggregatesInput | PatternPermissionScalarWhereWithAggregatesInput[]
    OR?: PatternPermissionScalarWhereWithAggregatesInput[]
    NOT?: PatternPermissionScalarWhereWithAggregatesInput | PatternPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatternPermission"> | string
    patternId?: StringWithAggregatesFilter<"PatternPermission"> | string
    userId?: StringWithAggregatesFilter<"PatternPermission"> | string
    permission?: EnumPermissionLevelWithAggregatesFilter<"PatternPermission"> | $Enums.PermissionLevel
    grantedById?: StringWithAggregatesFilter<"PatternPermission"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"PatternPermission"> | Date | string
  }

  export type PatternTeamPermissionWhereInput = {
    AND?: PatternTeamPermissionWhereInput | PatternTeamPermissionWhereInput[]
    OR?: PatternTeamPermissionWhereInput[]
    NOT?: PatternTeamPermissionWhereInput | PatternTeamPermissionWhereInput[]
    id?: StringFilter<"PatternTeamPermission"> | string
    patternId?: StringFilter<"PatternTeamPermission"> | string
    teamId?: StringFilter<"PatternTeamPermission"> | string
    permission?: EnumPermissionLevelFilter<"PatternTeamPermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"PatternTeamPermission"> | string
    grantedAt?: DateTimeFilter<"PatternTeamPermission"> | Date | string
    pattern?: XOR<ArgumentPatternScalarRelationFilter, ArgumentPatternWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }

  export type PatternTeamPermissionOrderByWithRelationInput = {
    id?: SortOrder
    patternId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    pattern?: ArgumentPatternOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type PatternTeamPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patternId_teamId?: PatternTeamPermissionPatternIdTeamIdCompoundUniqueInput
    AND?: PatternTeamPermissionWhereInput | PatternTeamPermissionWhereInput[]
    OR?: PatternTeamPermissionWhereInput[]
    NOT?: PatternTeamPermissionWhereInput | PatternTeamPermissionWhereInput[]
    patternId?: StringFilter<"PatternTeamPermission"> | string
    teamId?: StringFilter<"PatternTeamPermission"> | string
    permission?: EnumPermissionLevelFilter<"PatternTeamPermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"PatternTeamPermission"> | string
    grantedAt?: DateTimeFilter<"PatternTeamPermission"> | Date | string
    pattern?: XOR<ArgumentPatternScalarRelationFilter, ArgumentPatternWhereInput>
    team?: XOR<TeamScalarRelationFilter, TeamWhereInput>
  }, "id" | "patternId_teamId">

  export type PatternTeamPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    patternId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
    _count?: PatternTeamPermissionCountOrderByAggregateInput
    _max?: PatternTeamPermissionMaxOrderByAggregateInput
    _min?: PatternTeamPermissionMinOrderByAggregateInput
  }

  export type PatternTeamPermissionScalarWhereWithAggregatesInput = {
    AND?: PatternTeamPermissionScalarWhereWithAggregatesInput | PatternTeamPermissionScalarWhereWithAggregatesInput[]
    OR?: PatternTeamPermissionScalarWhereWithAggregatesInput[]
    NOT?: PatternTeamPermissionScalarWhereWithAggregatesInput | PatternTeamPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatternTeamPermission"> | string
    patternId?: StringWithAggregatesFilter<"PatternTeamPermission"> | string
    teamId?: StringWithAggregatesFilter<"PatternTeamPermission"> | string
    permission?: EnumPermissionLevelWithAggregatesFilter<"PatternTeamPermission"> | $Enums.PermissionLevel
    grantedById?: StringWithAggregatesFilter<"PatternTeamPermission"> | string
    grantedAt?: DateTimeWithAggregatesFilter<"PatternTeamPermission"> | Date | string
  }

  export type ReleaseWhereInput = {
    AND?: ReleaseWhereInput | ReleaseWhereInput[]
    OR?: ReleaseWhereInput[]
    NOT?: ReleaseWhereInput | ReleaseWhereInput[]
    id?: StringFilter<"Release"> | string
    sourceCaseId?: StringFilter<"Release"> | string
    publishedCaseId?: StringNullableFilter<"Release"> | string | null
    title?: StringFilter<"Release"> | string
    description?: StringFilter<"Release"> | string
    currentVersion?: IntFilter<"Release"> | number
    authors?: StringFilter<"Release"> | string
    contactEmail?: StringNullableFilter<"Release"> | string | null
    category?: StringNullableFilter<"Release"> | string | null
    sector?: StringNullableFilter<"Release"> | string | null
    tags?: StringNullableListFilter<"Release">
    status?: EnumReleaseStatusFilter<"Release"> | $Enums.ReleaseStatus
    firstPublishedAt?: DateTimeNullableFilter<"Release"> | Date | string | null
    lastUpdatedAt?: DateTimeNullableFilter<"Release"> | Date | string | null
    allowComments?: BoolFilter<"Release"> | boolean
    createdById?: StringFilter<"Release"> | string
    createdAt?: DateTimeFilter<"Release"> | Date | string
    updatedAt?: DateTimeFilter<"Release"> | Date | string
    sourceCase?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    publishedCase?: XOR<AssuranceCaseNullableScalarRelationFilter, AssuranceCaseWhereInput> | null
    snapshots?: ReleaseSnapshotListRelationFilter
    comments?: ReleaseCommentListRelationFilter
    image?: XOR<ReleaseImageNullableScalarRelationFilter, ReleaseImageWhereInput> | null
  }

  export type ReleaseOrderByWithRelationInput = {
    id?: SortOrder
    sourceCaseId?: SortOrder
    publishedCaseId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    currentVersion?: SortOrder
    authors?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    tags?: SortOrder
    status?: SortOrder
    firstPublishedAt?: SortOrderInput | SortOrder
    lastUpdatedAt?: SortOrderInput | SortOrder
    allowComments?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sourceCase?: AssuranceCaseOrderByWithRelationInput
    publishedCase?: AssuranceCaseOrderByWithRelationInput
    snapshots?: ReleaseSnapshotOrderByRelationAggregateInput
    comments?: ReleaseCommentOrderByRelationAggregateInput
    image?: ReleaseImageOrderByWithRelationInput
  }

  export type ReleaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReleaseWhereInput | ReleaseWhereInput[]
    OR?: ReleaseWhereInput[]
    NOT?: ReleaseWhereInput | ReleaseWhereInput[]
    sourceCaseId?: StringFilter<"Release"> | string
    publishedCaseId?: StringNullableFilter<"Release"> | string | null
    title?: StringFilter<"Release"> | string
    description?: StringFilter<"Release"> | string
    currentVersion?: IntFilter<"Release"> | number
    authors?: StringFilter<"Release"> | string
    contactEmail?: StringNullableFilter<"Release"> | string | null
    category?: StringNullableFilter<"Release"> | string | null
    sector?: StringNullableFilter<"Release"> | string | null
    tags?: StringNullableListFilter<"Release">
    status?: EnumReleaseStatusFilter<"Release"> | $Enums.ReleaseStatus
    firstPublishedAt?: DateTimeNullableFilter<"Release"> | Date | string | null
    lastUpdatedAt?: DateTimeNullableFilter<"Release"> | Date | string | null
    allowComments?: BoolFilter<"Release"> | boolean
    createdById?: StringFilter<"Release"> | string
    createdAt?: DateTimeFilter<"Release"> | Date | string
    updatedAt?: DateTimeFilter<"Release"> | Date | string
    sourceCase?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    publishedCase?: XOR<AssuranceCaseNullableScalarRelationFilter, AssuranceCaseWhereInput> | null
    snapshots?: ReleaseSnapshotListRelationFilter
    comments?: ReleaseCommentListRelationFilter
    image?: XOR<ReleaseImageNullableScalarRelationFilter, ReleaseImageWhereInput> | null
  }, "id">

  export type ReleaseOrderByWithAggregationInput = {
    id?: SortOrder
    sourceCaseId?: SortOrder
    publishedCaseId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    currentVersion?: SortOrder
    authors?: SortOrder
    contactEmail?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    sector?: SortOrderInput | SortOrder
    tags?: SortOrder
    status?: SortOrder
    firstPublishedAt?: SortOrderInput | SortOrder
    lastUpdatedAt?: SortOrderInput | SortOrder
    allowComments?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReleaseCountOrderByAggregateInput
    _avg?: ReleaseAvgOrderByAggregateInput
    _max?: ReleaseMaxOrderByAggregateInput
    _min?: ReleaseMinOrderByAggregateInput
    _sum?: ReleaseSumOrderByAggregateInput
  }

  export type ReleaseScalarWhereWithAggregatesInput = {
    AND?: ReleaseScalarWhereWithAggregatesInput | ReleaseScalarWhereWithAggregatesInput[]
    OR?: ReleaseScalarWhereWithAggregatesInput[]
    NOT?: ReleaseScalarWhereWithAggregatesInput | ReleaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Release"> | string
    sourceCaseId?: StringWithAggregatesFilter<"Release"> | string
    publishedCaseId?: StringNullableWithAggregatesFilter<"Release"> | string | null
    title?: StringWithAggregatesFilter<"Release"> | string
    description?: StringWithAggregatesFilter<"Release"> | string
    currentVersion?: IntWithAggregatesFilter<"Release"> | number
    authors?: StringWithAggregatesFilter<"Release"> | string
    contactEmail?: StringNullableWithAggregatesFilter<"Release"> | string | null
    category?: StringNullableWithAggregatesFilter<"Release"> | string | null
    sector?: StringNullableWithAggregatesFilter<"Release"> | string | null
    tags?: StringNullableListFilter<"Release">
    status?: EnumReleaseStatusWithAggregatesFilter<"Release"> | $Enums.ReleaseStatus
    firstPublishedAt?: DateTimeNullableWithAggregatesFilter<"Release"> | Date | string | null
    lastUpdatedAt?: DateTimeNullableWithAggregatesFilter<"Release"> | Date | string | null
    allowComments?: BoolWithAggregatesFilter<"Release"> | boolean
    createdById?: StringWithAggregatesFilter<"Release"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Release"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Release"> | Date | string
  }

  export type ReleaseSnapshotWhereInput = {
    AND?: ReleaseSnapshotWhereInput | ReleaseSnapshotWhereInput[]
    OR?: ReleaseSnapshotWhereInput[]
    NOT?: ReleaseSnapshotWhereInput | ReleaseSnapshotWhereInput[]
    id?: StringFilter<"ReleaseSnapshot"> | string
    releaseId?: StringFilter<"ReleaseSnapshot"> | string
    versionNumber?: IntFilter<"ReleaseSnapshot"> | number
    versionLabel?: StringNullableFilter<"ReleaseSnapshot"> | string | null
    content?: JsonFilter<"ReleaseSnapshot">
    snapshotTakenAt?: DateTimeFilter<"ReleaseSnapshot"> | Date | string
    snapshotTakenById?: StringFilter<"ReleaseSnapshot"> | string
    reason?: EnumSnapshotReasonFilter<"ReleaseSnapshot"> | $Enums.SnapshotReason
    createdAt?: DateTimeFilter<"ReleaseSnapshot"> | Date | string
    release?: XOR<ReleaseScalarRelationFilter, ReleaseWhereInput>
  }

  export type ReleaseSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    releaseId?: SortOrder
    versionNumber?: SortOrder
    versionLabel?: SortOrderInput | SortOrder
    content?: SortOrder
    snapshotTakenAt?: SortOrder
    snapshotTakenById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    release?: ReleaseOrderByWithRelationInput
  }

  export type ReleaseSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReleaseSnapshotWhereInput | ReleaseSnapshotWhereInput[]
    OR?: ReleaseSnapshotWhereInput[]
    NOT?: ReleaseSnapshotWhereInput | ReleaseSnapshotWhereInput[]
    releaseId?: StringFilter<"ReleaseSnapshot"> | string
    versionNumber?: IntFilter<"ReleaseSnapshot"> | number
    versionLabel?: StringNullableFilter<"ReleaseSnapshot"> | string | null
    content?: JsonFilter<"ReleaseSnapshot">
    snapshotTakenAt?: DateTimeFilter<"ReleaseSnapshot"> | Date | string
    snapshotTakenById?: StringFilter<"ReleaseSnapshot"> | string
    reason?: EnumSnapshotReasonFilter<"ReleaseSnapshot"> | $Enums.SnapshotReason
    createdAt?: DateTimeFilter<"ReleaseSnapshot"> | Date | string
    release?: XOR<ReleaseScalarRelationFilter, ReleaseWhereInput>
  }, "id">

  export type ReleaseSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    releaseId?: SortOrder
    versionNumber?: SortOrder
    versionLabel?: SortOrderInput | SortOrder
    content?: SortOrder
    snapshotTakenAt?: SortOrder
    snapshotTakenById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    _count?: ReleaseSnapshotCountOrderByAggregateInput
    _avg?: ReleaseSnapshotAvgOrderByAggregateInput
    _max?: ReleaseSnapshotMaxOrderByAggregateInput
    _min?: ReleaseSnapshotMinOrderByAggregateInput
    _sum?: ReleaseSnapshotSumOrderByAggregateInput
  }

  export type ReleaseSnapshotScalarWhereWithAggregatesInput = {
    AND?: ReleaseSnapshotScalarWhereWithAggregatesInput | ReleaseSnapshotScalarWhereWithAggregatesInput[]
    OR?: ReleaseSnapshotScalarWhereWithAggregatesInput[]
    NOT?: ReleaseSnapshotScalarWhereWithAggregatesInput | ReleaseSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReleaseSnapshot"> | string
    releaseId?: StringWithAggregatesFilter<"ReleaseSnapshot"> | string
    versionNumber?: IntWithAggregatesFilter<"ReleaseSnapshot"> | number
    versionLabel?: StringNullableWithAggregatesFilter<"ReleaseSnapshot"> | string | null
    content?: JsonWithAggregatesFilter<"ReleaseSnapshot">
    snapshotTakenAt?: DateTimeWithAggregatesFilter<"ReleaseSnapshot"> | Date | string
    snapshotTakenById?: StringWithAggregatesFilter<"ReleaseSnapshot"> | string
    reason?: EnumSnapshotReasonWithAggregatesFilter<"ReleaseSnapshot"> | $Enums.SnapshotReason
    createdAt?: DateTimeWithAggregatesFilter<"ReleaseSnapshot"> | Date | string
  }

  export type ReleaseCommentWhereInput = {
    AND?: ReleaseCommentWhereInput | ReleaseCommentWhereInput[]
    OR?: ReleaseCommentWhereInput[]
    NOT?: ReleaseCommentWhereInput | ReleaseCommentWhereInput[]
    id?: StringFilter<"ReleaseComment"> | string
    releaseId?: StringFilter<"ReleaseComment"> | string
    elementId?: StringNullableFilter<"ReleaseComment"> | string | null
    parentCommentId?: StringNullableFilter<"ReleaseComment"> | string | null
    content?: StringFilter<"ReleaseComment"> | string
    authorId?: StringFilter<"ReleaseComment"> | string
    status?: EnumCommentStatusFilter<"ReleaseComment"> | $Enums.CommentStatus
    hiddenById?: StringNullableFilter<"ReleaseComment"> | string | null
    hiddenAt?: DateTimeNullableFilter<"ReleaseComment"> | Date | string | null
    hiddenReason?: StringNullableFilter<"ReleaseComment"> | string | null
    createdAt?: DateTimeFilter<"ReleaseComment"> | Date | string
    updatedAt?: DateTimeFilter<"ReleaseComment"> | Date | string
    release?: XOR<ReleaseScalarRelationFilter, ReleaseWhereInput>
    element?: XOR<AssuranceElementNullableScalarRelationFilter, AssuranceElementWhereInput> | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parentComment?: XOR<ReleaseCommentNullableScalarRelationFilter, ReleaseCommentWhereInput> | null
    replies?: ReleaseCommentListRelationFilter
  }

  export type ReleaseCommentOrderByWithRelationInput = {
    id?: SortOrder
    releaseId?: SortOrder
    elementId?: SortOrderInput | SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    authorId?: SortOrder
    status?: SortOrder
    hiddenById?: SortOrderInput | SortOrder
    hiddenAt?: SortOrderInput | SortOrder
    hiddenReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    release?: ReleaseOrderByWithRelationInput
    element?: AssuranceElementOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    parentComment?: ReleaseCommentOrderByWithRelationInput
    replies?: ReleaseCommentOrderByRelationAggregateInput
  }

  export type ReleaseCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReleaseCommentWhereInput | ReleaseCommentWhereInput[]
    OR?: ReleaseCommentWhereInput[]
    NOT?: ReleaseCommentWhereInput | ReleaseCommentWhereInput[]
    releaseId?: StringFilter<"ReleaseComment"> | string
    elementId?: StringNullableFilter<"ReleaseComment"> | string | null
    parentCommentId?: StringNullableFilter<"ReleaseComment"> | string | null
    content?: StringFilter<"ReleaseComment"> | string
    authorId?: StringFilter<"ReleaseComment"> | string
    status?: EnumCommentStatusFilter<"ReleaseComment"> | $Enums.CommentStatus
    hiddenById?: StringNullableFilter<"ReleaseComment"> | string | null
    hiddenAt?: DateTimeNullableFilter<"ReleaseComment"> | Date | string | null
    hiddenReason?: StringNullableFilter<"ReleaseComment"> | string | null
    createdAt?: DateTimeFilter<"ReleaseComment"> | Date | string
    updatedAt?: DateTimeFilter<"ReleaseComment"> | Date | string
    release?: XOR<ReleaseScalarRelationFilter, ReleaseWhereInput>
    element?: XOR<AssuranceElementNullableScalarRelationFilter, AssuranceElementWhereInput> | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parentComment?: XOR<ReleaseCommentNullableScalarRelationFilter, ReleaseCommentWhereInput> | null
    replies?: ReleaseCommentListRelationFilter
  }, "id">

  export type ReleaseCommentOrderByWithAggregationInput = {
    id?: SortOrder
    releaseId?: SortOrder
    elementId?: SortOrderInput | SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    authorId?: SortOrder
    status?: SortOrder
    hiddenById?: SortOrderInput | SortOrder
    hiddenAt?: SortOrderInput | SortOrder
    hiddenReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReleaseCommentCountOrderByAggregateInput
    _max?: ReleaseCommentMaxOrderByAggregateInput
    _min?: ReleaseCommentMinOrderByAggregateInput
  }

  export type ReleaseCommentScalarWhereWithAggregatesInput = {
    AND?: ReleaseCommentScalarWhereWithAggregatesInput | ReleaseCommentScalarWhereWithAggregatesInput[]
    OR?: ReleaseCommentScalarWhereWithAggregatesInput[]
    NOT?: ReleaseCommentScalarWhereWithAggregatesInput | ReleaseCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReleaseComment"> | string
    releaseId?: StringWithAggregatesFilter<"ReleaseComment"> | string
    elementId?: StringNullableWithAggregatesFilter<"ReleaseComment"> | string | null
    parentCommentId?: StringNullableWithAggregatesFilter<"ReleaseComment"> | string | null
    content?: StringWithAggregatesFilter<"ReleaseComment"> | string
    authorId?: StringWithAggregatesFilter<"ReleaseComment"> | string
    status?: EnumCommentStatusWithAggregatesFilter<"ReleaseComment"> | $Enums.CommentStatus
    hiddenById?: StringNullableWithAggregatesFilter<"ReleaseComment"> | string | null
    hiddenAt?: DateTimeNullableWithAggregatesFilter<"ReleaseComment"> | Date | string | null
    hiddenReason?: StringNullableWithAggregatesFilter<"ReleaseComment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReleaseComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReleaseComment"> | Date | string
  }

  export type ReleaseImageWhereInput = {
    AND?: ReleaseImageWhereInput | ReleaseImageWhereInput[]
    OR?: ReleaseImageWhereInput[]
    NOT?: ReleaseImageWhereInput | ReleaseImageWhereInput[]
    id?: StringFilter<"ReleaseImage"> | string
    releaseId?: StringFilter<"ReleaseImage"> | string
    imageUrl?: StringFilter<"ReleaseImage"> | string
    altText?: StringNullableFilter<"ReleaseImage"> | string | null
    uploadedAt?: DateTimeFilter<"ReleaseImage"> | Date | string
    uploadedById?: StringFilter<"ReleaseImage"> | string
    release?: XOR<ReleaseScalarRelationFilter, ReleaseWhereInput>
  }

  export type ReleaseImageOrderByWithRelationInput = {
    id?: SortOrder
    releaseId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
    release?: ReleaseOrderByWithRelationInput
  }

  export type ReleaseImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    releaseId?: string
    AND?: ReleaseImageWhereInput | ReleaseImageWhereInput[]
    OR?: ReleaseImageWhereInput[]
    NOT?: ReleaseImageWhereInput | ReleaseImageWhereInput[]
    imageUrl?: StringFilter<"ReleaseImage"> | string
    altText?: StringNullableFilter<"ReleaseImage"> | string | null
    uploadedAt?: DateTimeFilter<"ReleaseImage"> | Date | string
    uploadedById?: StringFilter<"ReleaseImage"> | string
    release?: XOR<ReleaseScalarRelationFilter, ReleaseWhereInput>
  }, "id" | "releaseId">

  export type ReleaseImageOrderByWithAggregationInput = {
    id?: SortOrder
    releaseId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
    _count?: ReleaseImageCountOrderByAggregateInput
    _max?: ReleaseImageMaxOrderByAggregateInput
    _min?: ReleaseImageMinOrderByAggregateInput
  }

  export type ReleaseImageScalarWhereWithAggregatesInput = {
    AND?: ReleaseImageScalarWhereWithAggregatesInput | ReleaseImageScalarWhereWithAggregatesInput[]
    OR?: ReleaseImageScalarWhereWithAggregatesInput[]
    NOT?: ReleaseImageScalarWhereWithAggregatesInput | ReleaseImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReleaseImage"> | string
    releaseId?: StringWithAggregatesFilter<"ReleaseImage"> | string
    imageUrl?: StringWithAggregatesFilter<"ReleaseImage"> | string
    altText?: StringNullableWithAggregatesFilter<"ReleaseImage"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"ReleaseImage"> | Date | string
    uploadedById?: StringWithAggregatesFilter<"ReleaseImage"> | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    caseId?: StringNullableFilter<"Comment"> | string | null
    elementId?: StringNullableFilter<"Comment"> | string | null
    parentCommentId?: StringNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    resolved?: BoolFilter<"Comment"> | boolean
    resolvedById?: StringNullableFilter<"Comment"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    case?: XOR<AssuranceCaseNullableScalarRelationFilter, AssuranceCaseWhereInput> | null
    element?: XOR<AssuranceElementNullableScalarRelationFilter, AssuranceElementWhereInput> | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    parentComment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrderInput | SortOrder
    elementId?: SortOrderInput | SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    authorId?: SortOrder
    resolved?: SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    case?: AssuranceCaseOrderByWithRelationInput
    element?: AssuranceElementOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    resolvedBy?: UserOrderByWithRelationInput
    parentComment?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    caseId?: StringNullableFilter<"Comment"> | string | null
    elementId?: StringNullableFilter<"Comment"> | string | null
    parentCommentId?: StringNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    resolved?: BoolFilter<"Comment"> | boolean
    resolvedById?: StringNullableFilter<"Comment"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    case?: XOR<AssuranceCaseNullableScalarRelationFilter, AssuranceCaseWhereInput> | null
    element?: XOR<AssuranceElementNullableScalarRelationFilter, AssuranceElementWhereInput> | null
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    resolvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    parentComment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrderInput | SortOrder
    elementId?: SortOrderInput | SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    authorId?: SortOrder
    resolved?: SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    caseId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    elementId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    parentCommentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    content?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    resolved?: BoolWithAggregatesFilter<"Comment"> | boolean
    resolvedById?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Comment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type CaseImageWhereInput = {
    AND?: CaseImageWhereInput | CaseImageWhereInput[]
    OR?: CaseImageWhereInput[]
    NOT?: CaseImageWhereInput | CaseImageWhereInput[]
    id?: StringFilter<"CaseImage"> | string
    caseId?: StringFilter<"CaseImage"> | string
    imageUrl?: StringFilter<"CaseImage"> | string
    uploadedAt?: DateTimeFilter<"CaseImage"> | Date | string
    uploadedById?: StringFilter<"CaseImage"> | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
  }

  export type CaseImageOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    imageUrl?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
    case?: AssuranceCaseOrderByWithRelationInput
  }

  export type CaseImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    caseId?: string
    AND?: CaseImageWhereInput | CaseImageWhereInput[]
    OR?: CaseImageWhereInput[]
    NOT?: CaseImageWhereInput | CaseImageWhereInput[]
    imageUrl?: StringFilter<"CaseImage"> | string
    uploadedAt?: DateTimeFilter<"CaseImage"> | Date | string
    uploadedById?: StringFilter<"CaseImage"> | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
  }, "id" | "caseId">

  export type CaseImageOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    imageUrl?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
    _count?: CaseImageCountOrderByAggregateInput
    _max?: CaseImageMaxOrderByAggregateInput
    _min?: CaseImageMinOrderByAggregateInput
  }

  export type CaseImageScalarWhereWithAggregatesInput = {
    AND?: CaseImageScalarWhereWithAggregatesInput | CaseImageScalarWhereWithAggregatesInput[]
    OR?: CaseImageScalarWhereWithAggregatesInput[]
    NOT?: CaseImageScalarWhereWithAggregatesInput | CaseImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseImage"> | string
    caseId?: StringWithAggregatesFilter<"CaseImage"> | string
    imageUrl?: StringWithAggregatesFilter<"CaseImage"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"CaseImage"> | Date | string
    uploadedById?: StringWithAggregatesFilter<"CaseImage"> | string
  }

  export type CaseTypeWhereInput = {
    AND?: CaseTypeWhereInput | CaseTypeWhereInput[]
    OR?: CaseTypeWhereInput[]
    NOT?: CaseTypeWhereInput | CaseTypeWhereInput[]
    id?: StringFilter<"CaseType"> | string
    name?: StringFilter<"CaseType"> | string
    description?: StringNullableFilter<"CaseType"> | string | null
    category?: EnumCaseTypeCategoryFilter<"CaseType"> | $Enums.CaseTypeCategory
    externalUrl?: StringNullableFilter<"CaseType"> | string | null
    createdAt?: DateTimeFilter<"CaseType"> | Date | string
    assignments?: CaseTypeAssignmentListRelationFilter
  }

  export type CaseTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    externalUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    assignments?: CaseTypeAssignmentOrderByRelationAggregateInput
  }

  export type CaseTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CaseTypeWhereInput | CaseTypeWhereInput[]
    OR?: CaseTypeWhereInput[]
    NOT?: CaseTypeWhereInput | CaseTypeWhereInput[]
    description?: StringNullableFilter<"CaseType"> | string | null
    category?: EnumCaseTypeCategoryFilter<"CaseType"> | $Enums.CaseTypeCategory
    externalUrl?: StringNullableFilter<"CaseType"> | string | null
    createdAt?: DateTimeFilter<"CaseType"> | Date | string
    assignments?: CaseTypeAssignmentListRelationFilter
  }, "id" | "name">

  export type CaseTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    externalUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CaseTypeCountOrderByAggregateInput
    _max?: CaseTypeMaxOrderByAggregateInput
    _min?: CaseTypeMinOrderByAggregateInput
  }

  export type CaseTypeScalarWhereWithAggregatesInput = {
    AND?: CaseTypeScalarWhereWithAggregatesInput | CaseTypeScalarWhereWithAggregatesInput[]
    OR?: CaseTypeScalarWhereWithAggregatesInput[]
    NOT?: CaseTypeScalarWhereWithAggregatesInput | CaseTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseType"> | string
    name?: StringWithAggregatesFilter<"CaseType"> | string
    description?: StringNullableWithAggregatesFilter<"CaseType"> | string | null
    category?: EnumCaseTypeCategoryWithAggregatesFilter<"CaseType"> | $Enums.CaseTypeCategory
    externalUrl?: StringNullableWithAggregatesFilter<"CaseType"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CaseType"> | Date | string
  }

  export type CaseTypeAssignmentWhereInput = {
    AND?: CaseTypeAssignmentWhereInput | CaseTypeAssignmentWhereInput[]
    OR?: CaseTypeAssignmentWhereInput[]
    NOT?: CaseTypeAssignmentWhereInput | CaseTypeAssignmentWhereInput[]
    id?: StringFilter<"CaseTypeAssignment"> | string
    caseId?: StringFilter<"CaseTypeAssignment"> | string
    caseTypeId?: StringFilter<"CaseTypeAssignment"> | string
    assignedById?: StringFilter<"CaseTypeAssignment"> | string
    assignedAt?: DateTimeFilter<"CaseTypeAssignment"> | Date | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    caseType?: XOR<CaseTypeScalarRelationFilter, CaseTypeWhereInput>
  }

  export type CaseTypeAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    caseId?: SortOrder
    caseTypeId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    case?: AssuranceCaseOrderByWithRelationInput
    caseType?: CaseTypeOrderByWithRelationInput
  }

  export type CaseTypeAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    caseId_caseTypeId?: CaseTypeAssignmentCaseIdCaseTypeIdCompoundUniqueInput
    AND?: CaseTypeAssignmentWhereInput | CaseTypeAssignmentWhereInput[]
    OR?: CaseTypeAssignmentWhereInput[]
    NOT?: CaseTypeAssignmentWhereInput | CaseTypeAssignmentWhereInput[]
    caseId?: StringFilter<"CaseTypeAssignment"> | string
    caseTypeId?: StringFilter<"CaseTypeAssignment"> | string
    assignedById?: StringFilter<"CaseTypeAssignment"> | string
    assignedAt?: DateTimeFilter<"CaseTypeAssignment"> | Date | string
    case?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    caseType?: XOR<CaseTypeScalarRelationFilter, CaseTypeWhereInput>
  }, "id" | "caseId_caseTypeId">

  export type CaseTypeAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    caseId?: SortOrder
    caseTypeId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
    _count?: CaseTypeAssignmentCountOrderByAggregateInput
    _max?: CaseTypeAssignmentMaxOrderByAggregateInput
    _min?: CaseTypeAssignmentMinOrderByAggregateInput
  }

  export type CaseTypeAssignmentScalarWhereWithAggregatesInput = {
    AND?: CaseTypeAssignmentScalarWhereWithAggregatesInput | CaseTypeAssignmentScalarWhereWithAggregatesInput[]
    OR?: CaseTypeAssignmentScalarWhereWithAggregatesInput[]
    NOT?: CaseTypeAssignmentScalarWhereWithAggregatesInput | CaseTypeAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CaseTypeAssignment"> | string
    caseId?: StringWithAggregatesFilter<"CaseTypeAssignment"> | string
    caseTypeId?: StringWithAggregatesFilter<"CaseTypeAssignment"> | string
    assignedById?: StringWithAggregatesFilter<"CaseTypeAssignment"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"CaseTypeAssignment"> | Date | string
  }

  export type GitHubRepositoryWhereInput = {
    AND?: GitHubRepositoryWhereInput | GitHubRepositoryWhereInput[]
    OR?: GitHubRepositoryWhereInput[]
    NOT?: GitHubRepositoryWhereInput | GitHubRepositoryWhereInput[]
    id?: StringFilter<"GitHubRepository"> | string
    name?: StringFilter<"GitHubRepository"> | string
    url?: StringFilter<"GitHubRepository"> | string
    description?: StringNullableFilter<"GitHubRepository"> | string | null
    githubId?: StringNullableFilter<"GitHubRepository"> | string | null
    defaultBranch?: StringFilter<"GitHubRepository"> | string
    userId?: StringFilter<"GitHubRepository"> | string
    createdAt?: DateTimeFilter<"GitHubRepository"> | Date | string
    updatedAt?: DateTimeFilter<"GitHubRepository"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GitHubRepositoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    githubId?: SortOrderInput | SortOrder
    defaultBranch?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type GitHubRepositoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GitHubRepositoryWhereInput | GitHubRepositoryWhereInput[]
    OR?: GitHubRepositoryWhereInput[]
    NOT?: GitHubRepositoryWhereInput | GitHubRepositoryWhereInput[]
    name?: StringFilter<"GitHubRepository"> | string
    url?: StringFilter<"GitHubRepository"> | string
    description?: StringNullableFilter<"GitHubRepository"> | string | null
    githubId?: StringNullableFilter<"GitHubRepository"> | string | null
    defaultBranch?: StringFilter<"GitHubRepository"> | string
    userId?: StringFilter<"GitHubRepository"> | string
    createdAt?: DateTimeFilter<"GitHubRepository"> | Date | string
    updatedAt?: DateTimeFilter<"GitHubRepository"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type GitHubRepositoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrderInput | SortOrder
    githubId?: SortOrderInput | SortOrder
    defaultBranch?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GitHubRepositoryCountOrderByAggregateInput
    _max?: GitHubRepositoryMaxOrderByAggregateInput
    _min?: GitHubRepositoryMinOrderByAggregateInput
  }

  export type GitHubRepositoryScalarWhereWithAggregatesInput = {
    AND?: GitHubRepositoryScalarWhereWithAggregatesInput | GitHubRepositoryScalarWhereWithAggregatesInput[]
    OR?: GitHubRepositoryScalarWhereWithAggregatesInput[]
    NOT?: GitHubRepositoryScalarWhereWithAggregatesInput | GitHubRepositoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GitHubRepository"> | string
    name?: StringWithAggregatesFilter<"GitHubRepository"> | string
    url?: StringWithAggregatesFilter<"GitHubRepository"> | string
    description?: StringNullableWithAggregatesFilter<"GitHubRepository"> | string | null
    githubId?: StringNullableWithAggregatesFilter<"GitHubRepository"> | string | null
    defaultBranch?: StringWithAggregatesFilter<"GitHubRepository"> | string
    userId?: StringWithAggregatesFilter<"GitHubRepository"> | string
    createdAt?: DateTimeWithAggregatesFilter<"GitHubRepository"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GitHubRepository"> | Date | string
  }

  export type CaseStudyWhereInput = {
    AND?: CaseStudyWhereInput | CaseStudyWhereInput[]
    OR?: CaseStudyWhereInput[]
    NOT?: CaseStudyWhereInput | CaseStudyWhereInput[]
    id?: IntFilter<"CaseStudy"> | number
    title?: StringFilter<"CaseStudy"> | string
    description?: StringNullableFilter<"CaseStudy"> | string | null
    authors?: StringNullableFilter<"CaseStudy"> | string | null
    category?: StringNullableFilter<"CaseStudy"> | string | null
    publishedDate?: DateTimeNullableFilter<"CaseStudy"> | Date | string | null
    lastModifiedOn?: DateTimeFilter<"CaseStudy"> | Date | string
    createdOn?: DateTimeFilter<"CaseStudy"> | Date | string
    sector?: StringNullableFilter<"CaseStudy"> | string | null
    contact?: StringNullableFilter<"CaseStudy"> | string | null
    image?: StringNullableFilter<"CaseStudy"> | string | null
    published?: BoolFilter<"CaseStudy"> | boolean
    ownerId?: StringNullableFilter<"CaseStudy"> | string | null
    type?: StringNullableFilter<"CaseStudy"> | string | null
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    publishedCases?: CaseStudyPublishedCaseListRelationFilter
    featureImage?: XOR<CaseStudyImageNullableScalarRelationFilter, CaseStudyImageWhereInput> | null
  }

  export type CaseStudyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    authors?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    publishedDate?: SortOrderInput | SortOrder
    lastModifiedOn?: SortOrder
    createdOn?: SortOrder
    sector?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    published?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    owner?: UserOrderByWithRelationInput
    publishedCases?: CaseStudyPublishedCaseOrderByRelationAggregateInput
    featureImage?: CaseStudyImageOrderByWithRelationInput
  }

  export type CaseStudyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CaseStudyWhereInput | CaseStudyWhereInput[]
    OR?: CaseStudyWhereInput[]
    NOT?: CaseStudyWhereInput | CaseStudyWhereInput[]
    title?: StringFilter<"CaseStudy"> | string
    description?: StringNullableFilter<"CaseStudy"> | string | null
    authors?: StringNullableFilter<"CaseStudy"> | string | null
    category?: StringNullableFilter<"CaseStudy"> | string | null
    publishedDate?: DateTimeNullableFilter<"CaseStudy"> | Date | string | null
    lastModifiedOn?: DateTimeFilter<"CaseStudy"> | Date | string
    createdOn?: DateTimeFilter<"CaseStudy"> | Date | string
    sector?: StringNullableFilter<"CaseStudy"> | string | null
    contact?: StringNullableFilter<"CaseStudy"> | string | null
    image?: StringNullableFilter<"CaseStudy"> | string | null
    published?: BoolFilter<"CaseStudy"> | boolean
    ownerId?: StringNullableFilter<"CaseStudy"> | string | null
    type?: StringNullableFilter<"CaseStudy"> | string | null
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    publishedCases?: CaseStudyPublishedCaseListRelationFilter
    featureImage?: XOR<CaseStudyImageNullableScalarRelationFilter, CaseStudyImageWhereInput> | null
  }, "id">

  export type CaseStudyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    authors?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    publishedDate?: SortOrderInput | SortOrder
    lastModifiedOn?: SortOrder
    createdOn?: SortOrder
    sector?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    published?: SortOrder
    ownerId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: CaseStudyCountOrderByAggregateInput
    _avg?: CaseStudyAvgOrderByAggregateInput
    _max?: CaseStudyMaxOrderByAggregateInput
    _min?: CaseStudyMinOrderByAggregateInput
    _sum?: CaseStudySumOrderByAggregateInput
  }

  export type CaseStudyScalarWhereWithAggregatesInput = {
    AND?: CaseStudyScalarWhereWithAggregatesInput | CaseStudyScalarWhereWithAggregatesInput[]
    OR?: CaseStudyScalarWhereWithAggregatesInput[]
    NOT?: CaseStudyScalarWhereWithAggregatesInput | CaseStudyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CaseStudy"> | number
    title?: StringWithAggregatesFilter<"CaseStudy"> | string
    description?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    authors?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    category?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    publishedDate?: DateTimeNullableWithAggregatesFilter<"CaseStudy"> | Date | string | null
    lastModifiedOn?: DateTimeWithAggregatesFilter<"CaseStudy"> | Date | string
    createdOn?: DateTimeWithAggregatesFilter<"CaseStudy"> | Date | string
    sector?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    contact?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    image?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    published?: BoolWithAggregatesFilter<"CaseStudy"> | boolean
    ownerId?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
    type?: StringNullableWithAggregatesFilter<"CaseStudy"> | string | null
  }

  export type CaseStudyPublishedCaseWhereInput = {
    AND?: CaseStudyPublishedCaseWhereInput | CaseStudyPublishedCaseWhereInput[]
    OR?: CaseStudyPublishedCaseWhereInput[]
    NOT?: CaseStudyPublishedCaseWhereInput | CaseStudyPublishedCaseWhereInput[]
    id?: BigIntFilter<"CaseStudyPublishedCase"> | bigint | number
    caseStudyId?: IntFilter<"CaseStudyPublishedCase"> | number
    publishedAssuranceCaseId?: UuidFilter<"CaseStudyPublishedCase"> | string
    caseStudy?: XOR<CaseStudyScalarRelationFilter, CaseStudyWhereInput>
    publishedAssuranceCase?: XOR<PublishedAssuranceCaseScalarRelationFilter, PublishedAssuranceCaseWhereInput>
  }

  export type CaseStudyPublishedCaseOrderByWithRelationInput = {
    id?: SortOrder
    caseStudyId?: SortOrder
    publishedAssuranceCaseId?: SortOrder
    caseStudy?: CaseStudyOrderByWithRelationInput
    publishedAssuranceCase?: PublishedAssuranceCaseOrderByWithRelationInput
  }

  export type CaseStudyPublishedCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    caseStudyId_publishedAssuranceCaseId?: CaseStudyPublishedCaseCaseStudyIdPublishedAssuranceCaseIdCompoundUniqueInput
    AND?: CaseStudyPublishedCaseWhereInput | CaseStudyPublishedCaseWhereInput[]
    OR?: CaseStudyPublishedCaseWhereInput[]
    NOT?: CaseStudyPublishedCaseWhereInput | CaseStudyPublishedCaseWhereInput[]
    caseStudyId?: IntFilter<"CaseStudyPublishedCase"> | number
    publishedAssuranceCaseId?: UuidFilter<"CaseStudyPublishedCase"> | string
    caseStudy?: XOR<CaseStudyScalarRelationFilter, CaseStudyWhereInput>
    publishedAssuranceCase?: XOR<PublishedAssuranceCaseScalarRelationFilter, PublishedAssuranceCaseWhereInput>
  }, "id" | "caseStudyId_publishedAssuranceCaseId">

  export type CaseStudyPublishedCaseOrderByWithAggregationInput = {
    id?: SortOrder
    caseStudyId?: SortOrder
    publishedAssuranceCaseId?: SortOrder
    _count?: CaseStudyPublishedCaseCountOrderByAggregateInput
    _avg?: CaseStudyPublishedCaseAvgOrderByAggregateInput
    _max?: CaseStudyPublishedCaseMaxOrderByAggregateInput
    _min?: CaseStudyPublishedCaseMinOrderByAggregateInput
    _sum?: CaseStudyPublishedCaseSumOrderByAggregateInput
  }

  export type CaseStudyPublishedCaseScalarWhereWithAggregatesInput = {
    AND?: CaseStudyPublishedCaseScalarWhereWithAggregatesInput | CaseStudyPublishedCaseScalarWhereWithAggregatesInput[]
    OR?: CaseStudyPublishedCaseScalarWhereWithAggregatesInput[]
    NOT?: CaseStudyPublishedCaseScalarWhereWithAggregatesInput | CaseStudyPublishedCaseScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"CaseStudyPublishedCase"> | bigint | number
    caseStudyId?: IntWithAggregatesFilter<"CaseStudyPublishedCase"> | number
    publishedAssuranceCaseId?: UuidWithAggregatesFilter<"CaseStudyPublishedCase"> | string
  }

  export type CaseStudyImageWhereInput = {
    AND?: CaseStudyImageWhereInput | CaseStudyImageWhereInput[]
    OR?: CaseStudyImageWhereInput[]
    NOT?: CaseStudyImageWhereInput | CaseStudyImageWhereInput[]
    id?: BigIntFilter<"CaseStudyImage"> | bigint | number
    image?: StringFilter<"CaseStudyImage"> | string
    uploadedAt?: DateTimeFilter<"CaseStudyImage"> | Date | string
    caseStudyId?: IntFilter<"CaseStudyImage"> | number
    caseStudy?: XOR<CaseStudyScalarRelationFilter, CaseStudyWhereInput>
  }

  export type CaseStudyImageOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    uploadedAt?: SortOrder
    caseStudyId?: SortOrder
    caseStudy?: CaseStudyOrderByWithRelationInput
  }

  export type CaseStudyImageWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    caseStudyId?: number
    AND?: CaseStudyImageWhereInput | CaseStudyImageWhereInput[]
    OR?: CaseStudyImageWhereInput[]
    NOT?: CaseStudyImageWhereInput | CaseStudyImageWhereInput[]
    image?: StringFilter<"CaseStudyImage"> | string
    uploadedAt?: DateTimeFilter<"CaseStudyImage"> | Date | string
    caseStudy?: XOR<CaseStudyScalarRelationFilter, CaseStudyWhereInput>
  }, "id" | "caseStudyId">

  export type CaseStudyImageOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    uploadedAt?: SortOrder
    caseStudyId?: SortOrder
    _count?: CaseStudyImageCountOrderByAggregateInput
    _avg?: CaseStudyImageAvgOrderByAggregateInput
    _max?: CaseStudyImageMaxOrderByAggregateInput
    _min?: CaseStudyImageMinOrderByAggregateInput
    _sum?: CaseStudyImageSumOrderByAggregateInput
  }

  export type CaseStudyImageScalarWhereWithAggregatesInput = {
    AND?: CaseStudyImageScalarWhereWithAggregatesInput | CaseStudyImageScalarWhereWithAggregatesInput[]
    OR?: CaseStudyImageScalarWhereWithAggregatesInput[]
    NOT?: CaseStudyImageScalarWhereWithAggregatesInput | CaseStudyImageScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"CaseStudyImage"> | bigint | number
    image?: StringWithAggregatesFilter<"CaseStudyImage"> | string
    uploadedAt?: DateTimeWithAggregatesFilter<"CaseStudyImage"> | Date | string
    caseStudyId?: IntWithAggregatesFilter<"CaseStudyImage"> | number
  }

  export type PublishedAssuranceCaseWhereInput = {
    AND?: PublishedAssuranceCaseWhereInput | PublishedAssuranceCaseWhereInput[]
    OR?: PublishedAssuranceCaseWhereInput[]
    NOT?: PublishedAssuranceCaseWhereInput | PublishedAssuranceCaseWhereInput[]
    id?: UuidFilter<"PublishedAssuranceCase"> | string
    title?: StringFilter<"PublishedAssuranceCase"> | string
    content?: JsonFilter<"PublishedAssuranceCase">
    createdAt?: DateTimeFilter<"PublishedAssuranceCase"> | Date | string
    assuranceCaseId?: StringFilter<"PublishedAssuranceCase"> | string
    description?: StringNullableFilter<"PublishedAssuranceCase"> | string | null
    assuranceCase?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    caseStudyLinks?: CaseStudyPublishedCaseListRelationFilter
  }

  export type PublishedAssuranceCaseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    assuranceCaseId?: SortOrder
    description?: SortOrderInput | SortOrder
    assuranceCase?: AssuranceCaseOrderByWithRelationInput
    caseStudyLinks?: CaseStudyPublishedCaseOrderByRelationAggregateInput
  }

  export type PublishedAssuranceCaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PublishedAssuranceCaseWhereInput | PublishedAssuranceCaseWhereInput[]
    OR?: PublishedAssuranceCaseWhereInput[]
    NOT?: PublishedAssuranceCaseWhereInput | PublishedAssuranceCaseWhereInput[]
    title?: StringFilter<"PublishedAssuranceCase"> | string
    content?: JsonFilter<"PublishedAssuranceCase">
    createdAt?: DateTimeFilter<"PublishedAssuranceCase"> | Date | string
    assuranceCaseId?: StringFilter<"PublishedAssuranceCase"> | string
    description?: StringNullableFilter<"PublishedAssuranceCase"> | string | null
    assuranceCase?: XOR<AssuranceCaseScalarRelationFilter, AssuranceCaseWhereInput>
    caseStudyLinks?: CaseStudyPublishedCaseListRelationFilter
  }, "id">

  export type PublishedAssuranceCaseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    assuranceCaseId?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: PublishedAssuranceCaseCountOrderByAggregateInput
    _max?: PublishedAssuranceCaseMaxOrderByAggregateInput
    _min?: PublishedAssuranceCaseMinOrderByAggregateInput
  }

  export type PublishedAssuranceCaseScalarWhereWithAggregatesInput = {
    AND?: PublishedAssuranceCaseScalarWhereWithAggregatesInput | PublishedAssuranceCaseScalarWhereWithAggregatesInput[]
    OR?: PublishedAssuranceCaseScalarWhereWithAggregatesInput[]
    NOT?: PublishedAssuranceCaseScalarWhereWithAggregatesInput | PublishedAssuranceCaseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PublishedAssuranceCase"> | string
    title?: StringWithAggregatesFilter<"PublishedAssuranceCase"> | string
    content?: JsonWithAggregatesFilter<"PublishedAssuranceCase">
    createdAt?: DateTimeWithAggregatesFilter<"PublishedAssuranceCase"> | Date | string
    assuranceCaseId?: StringWithAggregatesFilter<"PublishedAssuranceCase"> | string
    description?: StringNullableWithAggregatesFilter<"PublishedAssuranceCase"> | string | null
  }

  export type LegacyMappingWhereInput = {
    AND?: LegacyMappingWhereInput | LegacyMappingWhereInput[]
    OR?: LegacyMappingWhereInput[]
    NOT?: LegacyMappingWhereInput | LegacyMappingWhereInput[]
    id?: StringFilter<"LegacyMapping"> | string
    entityType?: StringFilter<"LegacyMapping"> | string
    legacyId?: BigIntFilter<"LegacyMapping"> | bigint | number
    newId?: StringFilter<"LegacyMapping"> | string
    createdAt?: DateTimeFilter<"LegacyMapping"> | Date | string
  }

  export type LegacyMappingOrderByWithRelationInput = {
    id?: SortOrder
    entityType?: SortOrder
    legacyId?: SortOrder
    newId?: SortOrder
    createdAt?: SortOrder
  }

  export type LegacyMappingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityType_legacyId?: LegacyMappingEntityTypeLegacyIdCompoundUniqueInput
    AND?: LegacyMappingWhereInput | LegacyMappingWhereInput[]
    OR?: LegacyMappingWhereInput[]
    NOT?: LegacyMappingWhereInput | LegacyMappingWhereInput[]
    entityType?: StringFilter<"LegacyMapping"> | string
    legacyId?: BigIntFilter<"LegacyMapping"> | bigint | number
    newId?: StringFilter<"LegacyMapping"> | string
    createdAt?: DateTimeFilter<"LegacyMapping"> | Date | string
  }, "id" | "entityType_legacyId">

  export type LegacyMappingOrderByWithAggregationInput = {
    id?: SortOrder
    entityType?: SortOrder
    legacyId?: SortOrder
    newId?: SortOrder
    createdAt?: SortOrder
    _count?: LegacyMappingCountOrderByAggregateInput
    _avg?: LegacyMappingAvgOrderByAggregateInput
    _max?: LegacyMappingMaxOrderByAggregateInput
    _min?: LegacyMappingMinOrderByAggregateInput
    _sum?: LegacyMappingSumOrderByAggregateInput
  }

  export type LegacyMappingScalarWhereWithAggregatesInput = {
    AND?: LegacyMappingScalarWhereWithAggregatesInput | LegacyMappingScalarWhereWithAggregatesInput[]
    OR?: LegacyMappingScalarWhereWithAggregatesInput[]
    NOT?: LegacyMappingScalarWhereWithAggregatesInput | LegacyMappingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LegacyMapping"> | string
    entityType?: StringWithAggregatesFilter<"LegacyMapping"> | string
    legacyId?: BigIntWithAggregatesFilter<"LegacyMapping"> | bigint | number
    newId?: StringWithAggregatesFilter<"LegacyMapping"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LegacyMapping"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    token: string
    userId: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordResetAttemptCreateInput = {
    id?: string
    email: string
    ipAddress: string
    attemptedAt?: Date | string
    successful?: boolean
  }

  export type PasswordResetAttemptUncheckedCreateInput = {
    id?: string
    email: string
    ipAddress: string
    attemptedAt?: Date | string
    successful?: boolean
  }

  export type PasswordResetAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    attemptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    successful?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PasswordResetAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    attemptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    successful?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PasswordResetAttemptCreateManyInput = {
    id?: string
    email: string
    ipAddress: string
    attemptedAt?: Date | string
    successful?: boolean
  }

  export type PasswordResetAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    attemptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    successful?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PasswordResetAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    attemptedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    successful?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SecurityAuditLogCreateInput = {
    id?: string
    userId?: string | null
    eventType: string
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SecurityAuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    eventType: string
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SecurityAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    eventType: string
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type SecurityAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SecurityAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    casePermissions?: CaseTeamPermissionCreateNestedManyWithoutTeamInput
    patternPermissions?: PatternTeamPermissionCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    casePermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutTeamInput
    patternPermissions?: PatternTeamPermissionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    casePermissions?: CaseTeamPermissionUpdateManyWithoutTeamNestedInput
    patternPermissions?: PatternTeamPermissionUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    casePermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput
    patternPermissions?: PatternTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    role?: $Enums.TeamRole
    invitedById?: string | null
    joinedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    teamId: string
    userId: string
    role?: $Enums.TeamRole
    invitedById?: string | null
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    teamId: string
    userId: string
    role?: $Enums.TeamRole
    invitedById?: string | null
    joinedAt?: Date | string
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssuranceCaseCreateInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseCreateManyInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
  }

  export type AssuranceCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AssuranceCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CasePermissionCreateInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutUserPermissionsInput
    user: UserCreateNestedOneWithoutCasePermissionsInput
    grantedBy: UserCreateNestedOneWithoutGrantedPermissionsInput
  }

  export type CasePermissionUncheckedCreateInput = {
    id?: string
    caseId: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CasePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutUserPermissionsNestedInput
    user?: UserUpdateOneRequiredWithoutCasePermissionsNestedInput
    grantedBy?: UserUpdateOneRequiredWithoutGrantedPermissionsNestedInput
  }

  export type CasePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CasePermissionCreateManyInput = {
    id?: string
    caseId: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CasePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CasePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTeamPermissionCreateInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutTeamPermissionsInput
    team: TeamCreateNestedOneWithoutCasePermissionsInput
  }

  export type CaseTeamPermissionUncheckedCreateInput = {
    id?: string
    caseId: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CaseTeamPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutTeamPermissionsNestedInput
    team?: TeamUpdateOneRequiredWithoutCasePermissionsNestedInput
  }

  export type CaseTeamPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTeamPermissionCreateManyInput = {
    id?: string
    caseId: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CaseTeamPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTeamPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseInviteCreateInput = {
    id?: string
    email: string
    permission: $Enums.PermissionLevel
    inviteToken: string
    inviteExpiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedById?: string | null
    invitedById: string
    createdAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutInvitesInput
  }

  export type CaseInviteUncheckedCreateInput = {
    id?: string
    caseId: string
    email: string
    permission: $Enums.PermissionLevel
    inviteToken: string
    inviteExpiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedById?: string | null
    invitedById: string
    createdAt?: Date | string
  }

  export type CaseInviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    inviteToken?: StringFieldUpdateOperationsInput | string
    inviteExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type CaseInviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    inviteToken?: StringFieldUpdateOperationsInput | string
    inviteExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseInviteCreateManyInput = {
    id?: string
    caseId: string
    email: string
    permission: $Enums.PermissionLevel
    inviteToken: string
    inviteExpiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedById?: string | null
    invitedById: string
    createdAt?: Date | string
  }

  export type CaseInviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    inviteToken?: StringFieldUpdateOperationsInput | string
    inviteExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseInviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    inviteToken?: StringFieldUpdateOperationsInput | string
    inviteExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssuranceElementCreateInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementCreateManyInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type AssuranceElementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssuranceElementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type EvidenceLinkCreateInput = {
    id?: string
    createdAt?: Date | string
    evidence: AssuranceElementCreateNestedOneWithoutEvidenceLinksFromInput
    claim: AssuranceElementCreateNestedOneWithoutEvidenceLinksToInput
  }

  export type EvidenceLinkUncheckedCreateInput = {
    id?: string
    evidenceId: string
    claimId: string
    createdAt?: Date | string
  }

  export type EvidenceLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: AssuranceElementUpdateOneRequiredWithoutEvidenceLinksFromNestedInput
    claim?: AssuranceElementUpdateOneRequiredWithoutEvidenceLinksToNestedInput
  }

  export type EvidenceLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    evidenceId?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceLinkCreateManyInput = {
    id?: string
    evidenceId: string
    claimId: string
    createdAt?: Date | string
  }

  export type EvidenceLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    evidenceId?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArgumentPatternCreateInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PatternElementCreateNestedManyWithoutPatternInput
    userPermissions?: PatternPermissionCreateNestedManyWithoutPatternInput
    teamPermissions?: PatternTeamPermissionCreateNestedManyWithoutPatternInput
    derivedCases?: AssuranceCaseCreateNestedManyWithoutSourcePatternInput
  }

  export type ArgumentPatternUncheckedCreateInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PatternElementUncheckedCreateNestedManyWithoutPatternInput
    userPermissions?: PatternPermissionUncheckedCreateNestedManyWithoutPatternInput
    teamPermissions?: PatternTeamPermissionUncheckedCreateNestedManyWithoutPatternInput
    derivedCases?: AssuranceCaseUncheckedCreateNestedManyWithoutSourcePatternInput
  }

  export type ArgumentPatternUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PatternElementUpdateManyWithoutPatternNestedInput
    userPermissions?: PatternPermissionUpdateManyWithoutPatternNestedInput
    teamPermissions?: PatternTeamPermissionUpdateManyWithoutPatternNestedInput
    derivedCases?: AssuranceCaseUpdateManyWithoutSourcePatternNestedInput
  }

  export type ArgumentPatternUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PatternElementUncheckedUpdateManyWithoutPatternNestedInput
    userPermissions?: PatternPermissionUncheckedUpdateManyWithoutPatternNestedInput
    teamPermissions?: PatternTeamPermissionUncheckedUpdateManyWithoutPatternNestedInput
    derivedCases?: AssuranceCaseUncheckedUpdateManyWithoutSourcePatternNestedInput
  }

  export type ArgumentPatternCreateManyInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ArgumentPatternUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArgumentPatternUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternElementCreateInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pattern: ArgumentPatternCreateNestedOneWithoutElementsInput
    parent?: PatternElementCreateNestedOneWithoutChildrenInput
    children?: PatternElementCreateNestedManyWithoutParentInput
  }

  export type PatternElementUncheckedCreateInput = {
    id?: string
    patternId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PatternElementUncheckedCreateNestedManyWithoutParentInput
  }

  export type PatternElementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: ArgumentPatternUpdateOneRequiredWithoutElementsNestedInput
    parent?: PatternElementUpdateOneWithoutChildrenNestedInput
    children?: PatternElementUpdateManyWithoutParentNestedInput
  }

  export type PatternElementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PatternElementUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PatternElementCreateManyInput = {
    id?: string
    patternId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatternElementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternElementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternPermissionCreateInput = {
    id?: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
    pattern: ArgumentPatternCreateNestedOneWithoutUserPermissionsInput
  }

  export type PatternPermissionUncheckedCreateInput = {
    id?: string
    patternId: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: ArgumentPatternUpdateOneRequiredWithoutUserPermissionsNestedInput
  }

  export type PatternPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternPermissionCreateManyInput = {
    id?: string
    patternId: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternTeamPermissionCreateInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
    pattern: ArgumentPatternCreateNestedOneWithoutTeamPermissionsInput
    team: TeamCreateNestedOneWithoutPatternPermissionsInput
  }

  export type PatternTeamPermissionUncheckedCreateInput = {
    id?: string
    patternId: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternTeamPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: ArgumentPatternUpdateOneRequiredWithoutTeamPermissionsNestedInput
    team?: TeamUpdateOneRequiredWithoutPatternPermissionsNestedInput
  }

  export type PatternTeamPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternTeamPermissionCreateManyInput = {
    id?: string
    patternId: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternTeamPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternTeamPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseCreateInput = {
    id?: string
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceCase: AssuranceCaseCreateNestedOneWithoutSourceReleasesInput
    publishedCase?: AssuranceCaseCreateNestedOneWithoutPublishedReleasesInput
    snapshots?: ReleaseSnapshotCreateNestedManyWithoutReleaseInput
    comments?: ReleaseCommentCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseUncheckedCreateInput = {
    id?: string
    sourceCaseId: string
    publishedCaseId?: string | null
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshots?: ReleaseSnapshotUncheckedCreateNestedManyWithoutReleaseInput
    comments?: ReleaseCommentUncheckedCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageUncheckedCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceCase?: AssuranceCaseUpdateOneRequiredWithoutSourceReleasesNestedInput
    publishedCase?: AssuranceCaseUpdateOneWithoutPublishedReleasesNestedInput
    snapshots?: ReleaseSnapshotUpdateManyWithoutReleaseNestedInput
    comments?: ReleaseCommentUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUpdateOneWithoutReleaseNestedInput
  }

  export type ReleaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCaseId?: StringFieldUpdateOperationsInput | string
    publishedCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshots?: ReleaseSnapshotUncheckedUpdateManyWithoutReleaseNestedInput
    comments?: ReleaseCommentUncheckedUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUncheckedUpdateOneWithoutReleaseNestedInput
  }

  export type ReleaseCreateManyInput = {
    id?: string
    sourceCaseId: string
    publishedCaseId?: string | null
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCaseId?: StringFieldUpdateOperationsInput | string
    publishedCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseSnapshotCreateInput = {
    id?: string
    versionNumber: number
    versionLabel?: string | null
    content: JsonNullValueInput | InputJsonValue
    snapshotTakenAt: Date | string
    snapshotTakenById: string
    reason: $Enums.SnapshotReason
    createdAt?: Date | string
    release: ReleaseCreateNestedOneWithoutSnapshotsInput
  }

  export type ReleaseSnapshotUncheckedCreateInput = {
    id?: string
    releaseId: string
    versionNumber: number
    versionLabel?: string | null
    content: JsonNullValueInput | InputJsonValue
    snapshotTakenAt: Date | string
    snapshotTakenById: string
    reason: $Enums.SnapshotReason
    createdAt?: Date | string
  }

  export type ReleaseSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    snapshotTakenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotTakenById?: StringFieldUpdateOperationsInput | string
    reason?: EnumSnapshotReasonFieldUpdateOperationsInput | $Enums.SnapshotReason
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    release?: ReleaseUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type ReleaseSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    snapshotTakenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotTakenById?: StringFieldUpdateOperationsInput | string
    reason?: EnumSnapshotReasonFieldUpdateOperationsInput | $Enums.SnapshotReason
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseSnapshotCreateManyInput = {
    id?: string
    releaseId: string
    versionNumber: number
    versionLabel?: string | null
    content: JsonNullValueInput | InputJsonValue
    snapshotTakenAt: Date | string
    snapshotTakenById: string
    reason: $Enums.SnapshotReason
    createdAt?: Date | string
  }

  export type ReleaseSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    snapshotTakenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotTakenById?: StringFieldUpdateOperationsInput | string
    reason?: EnumSnapshotReasonFieldUpdateOperationsInput | $Enums.SnapshotReason
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    snapshotTakenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotTakenById?: StringFieldUpdateOperationsInput | string
    reason?: EnumSnapshotReasonFieldUpdateOperationsInput | $Enums.SnapshotReason
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseCommentCreateInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    release: ReleaseCreateNestedOneWithoutCommentsInput
    element?: AssuranceElementCreateNestedOneWithoutReleaseCommentsInput
    author: UserCreateNestedOneWithoutReleaseCommentsInput
    parentComment?: ReleaseCommentCreateNestedOneWithoutRepliesInput
    replies?: ReleaseCommentCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentUncheckedCreateInput = {
    id?: string
    releaseId: string
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReleaseCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    release?: ReleaseUpdateOneRequiredWithoutCommentsNestedInput
    element?: AssuranceElementUpdateOneWithoutReleaseCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutReleaseCommentsNestedInput
    parentComment?: ReleaseCommentUpdateOneWithoutRepliesNestedInput
    replies?: ReleaseCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReleaseCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentCreateManyInput = {
    id?: string
    releaseId: string
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseImageCreateInput = {
    id?: string
    imageUrl: string
    altText?: string | null
    uploadedAt: Date | string
    uploadedById: string
    release: ReleaseCreateNestedOneWithoutImageInput
  }

  export type ReleaseImageUncheckedCreateInput = {
    id?: string
    releaseId: string
    imageUrl: string
    altText?: string | null
    uploadedAt: Date | string
    uploadedById: string
  }

  export type ReleaseImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    release?: ReleaseUpdateOneRequiredWithoutImageNestedInput
  }

  export type ReleaseImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type ReleaseImageCreateManyInput = {
    id?: string
    releaseId: string
    imageUrl: string
    altText?: string | null
    uploadedAt: Date | string
    uploadedById: string
  }

  export type ReleaseImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type ReleaseImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case?: AssuranceCaseCreateNestedOneWithoutCommentsInput
    element?: AssuranceElementCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutAuthoredCommentsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    caseId?: string | null
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneWithoutCommentsNestedInput
    element?: AssuranceElementUpdateOneWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthoredCommentsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    caseId?: string | null
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseImageCreateInput = {
    id?: string
    imageUrl: string
    uploadedAt: Date | string
    uploadedById: string
    case: AssuranceCaseCreateNestedOneWithoutCaseImageInput
  }

  export type CaseImageUncheckedCreateInput = {
    id?: string
    caseId: string
    imageUrl: string
    uploadedAt: Date | string
    uploadedById: string
  }

  export type CaseImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
    case?: AssuranceCaseUpdateOneRequiredWithoutCaseImageNestedInput
  }

  export type CaseImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type CaseImageCreateManyInput = {
    id?: string
    caseId: string
    imageUrl: string
    uploadedAt: Date | string
    uploadedById: string
  }

  export type CaseImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type CaseImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type CaseTypeCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CaseTypeCategory
    externalUrl?: string | null
    createdAt?: Date | string
    assignments?: CaseTypeAssignmentCreateNestedManyWithoutCaseTypeInput
  }

  export type CaseTypeUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CaseTypeCategory
    externalUrl?: string | null
    createdAt?: Date | string
    assignments?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseTypeInput
  }

  export type CaseTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCaseTypeCategoryFieldUpdateOperationsInput | $Enums.CaseTypeCategory
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: CaseTypeAssignmentUpdateManyWithoutCaseTypeNestedInput
  }

  export type CaseTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCaseTypeCategoryFieldUpdateOperationsInput | $Enums.CaseTypeCategory
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseTypeNestedInput
  }

  export type CaseTypeCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CaseTypeCategory
    externalUrl?: string | null
    createdAt?: Date | string
  }

  export type CaseTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCaseTypeCategoryFieldUpdateOperationsInput | $Enums.CaseTypeCategory
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCaseTypeCategoryFieldUpdateOperationsInput | $Enums.CaseTypeCategory
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTypeAssignmentCreateInput = {
    id?: string
    assignedById: string
    assignedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutCaseTypesInput
    caseType: CaseTypeCreateNestedOneWithoutAssignmentsInput
  }

  export type CaseTypeAssignmentUncheckedCreateInput = {
    id?: string
    caseId: string
    caseTypeId: string
    assignedById: string
    assignedAt?: Date | string
  }

  export type CaseTypeAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutCaseTypesNestedInput
    caseType?: CaseTypeUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type CaseTypeAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    caseTypeId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTypeAssignmentCreateManyInput = {
    id?: string
    caseId: string
    caseTypeId: string
    assignedById: string
    assignedAt?: Date | string
  }

  export type CaseTypeAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTypeAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    caseTypeId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GitHubRepositoryCreateInput = {
    id?: string
    name: string
    url: string
    description?: string | null
    githubId?: string | null
    defaultBranch?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutGithubRepositoriesInput
  }

  export type GitHubRepositoryUncheckedCreateInput = {
    id?: string
    name: string
    url: string
    description?: string | null
    githubId?: string | null
    defaultBranch?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GitHubRepositoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultBranch?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutGithubRepositoriesNestedInput
  }

  export type GitHubRepositoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultBranch?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GitHubRepositoryCreateManyInput = {
    id?: string
    name: string
    url: string
    description?: string | null
    githubId?: string | null
    defaultBranch?: string
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GitHubRepositoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultBranch?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GitHubRepositoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultBranch?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyCreateInput = {
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    type?: string | null
    owner?: UserCreateNestedOneWithoutCaseStudiesInput
    publishedCases?: CaseStudyPublishedCaseCreateNestedManyWithoutCaseStudyInput
    featureImage?: CaseStudyImageCreateNestedOneWithoutCaseStudyInput
  }

  export type CaseStudyUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    ownerId?: string | null
    type?: string | null
    publishedCases?: CaseStudyPublishedCaseUncheckedCreateNestedManyWithoutCaseStudyInput
    featureImage?: CaseStudyImageUncheckedCreateNestedOneWithoutCaseStudyInput
  }

  export type CaseStudyUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneWithoutCaseStudiesNestedInput
    publishedCases?: CaseStudyPublishedCaseUpdateManyWithoutCaseStudyNestedInput
    featureImage?: CaseStudyImageUpdateOneWithoutCaseStudyNestedInput
  }

  export type CaseStudyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    publishedCases?: CaseStudyPublishedCaseUncheckedUpdateManyWithoutCaseStudyNestedInput
    featureImage?: CaseStudyImageUncheckedUpdateOneWithoutCaseStudyNestedInput
  }

  export type CaseStudyCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    ownerId?: string | null
    type?: string | null
  }

  export type CaseStudyUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaseStudyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaseStudyPublishedCaseCreateInput = {
    id?: bigint | number
    caseStudy: CaseStudyCreateNestedOneWithoutPublishedCasesInput
    publishedAssuranceCase: PublishedAssuranceCaseCreateNestedOneWithoutCaseStudyLinksInput
  }

  export type CaseStudyPublishedCaseUncheckedCreateInput = {
    id?: bigint | number
    caseStudyId: number
    publishedAssuranceCaseId: string
  }

  export type CaseStudyPublishedCaseUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    caseStudy?: CaseStudyUpdateOneRequiredWithoutPublishedCasesNestedInput
    publishedAssuranceCase?: PublishedAssuranceCaseUpdateOneRequiredWithoutCaseStudyLinksNestedInput
  }

  export type CaseStudyPublishedCaseUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    caseStudyId?: IntFieldUpdateOperationsInput | number
    publishedAssuranceCaseId?: StringFieldUpdateOperationsInput | string
  }

  export type CaseStudyPublishedCaseCreateManyInput = {
    id?: bigint | number
    caseStudyId: number
    publishedAssuranceCaseId: string
  }

  export type CaseStudyPublishedCaseUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CaseStudyPublishedCaseUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    caseStudyId?: IntFieldUpdateOperationsInput | number
    publishedAssuranceCaseId?: StringFieldUpdateOperationsInput | string
  }

  export type CaseStudyImageCreateInput = {
    id?: bigint | number
    image: string
    uploadedAt: Date | string
    caseStudy: CaseStudyCreateNestedOneWithoutFeatureImageInput
  }

  export type CaseStudyImageUncheckedCreateInput = {
    id?: bigint | number
    image: string
    uploadedAt: Date | string
    caseStudyId: number
  }

  export type CaseStudyImageUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    image?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caseStudy?: CaseStudyUpdateOneRequiredWithoutFeatureImageNestedInput
  }

  export type CaseStudyImageUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    image?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caseStudyId?: IntFieldUpdateOperationsInput | number
  }

  export type CaseStudyImageCreateManyInput = {
    id?: bigint | number
    image: string
    uploadedAt: Date | string
    caseStudyId: number
  }

  export type CaseStudyImageUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    image?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyImageUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    image?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caseStudyId?: IntFieldUpdateOperationsInput | number
  }

  export type PublishedAssuranceCaseCreateInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    assuranceCase: AssuranceCaseCreateNestedOneWithoutPublishedVersionsInput
    caseStudyLinks?: CaseStudyPublishedCaseCreateNestedManyWithoutPublishedAssuranceCaseInput
  }

  export type PublishedAssuranceCaseUncheckedCreateInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    assuranceCaseId: string
    description?: string | null
    caseStudyLinks?: CaseStudyPublishedCaseUncheckedCreateNestedManyWithoutPublishedAssuranceCaseInput
  }

  export type PublishedAssuranceCaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assuranceCase?: AssuranceCaseUpdateOneRequiredWithoutPublishedVersionsNestedInput
    caseStudyLinks?: CaseStudyPublishedCaseUpdateManyWithoutPublishedAssuranceCaseNestedInput
  }

  export type PublishedAssuranceCaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assuranceCaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudyLinks?: CaseStudyPublishedCaseUncheckedUpdateManyWithoutPublishedAssuranceCaseNestedInput
  }

  export type PublishedAssuranceCaseCreateManyInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    assuranceCaseId: string
    description?: string | null
  }

  export type PublishedAssuranceCaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PublishedAssuranceCaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assuranceCaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LegacyMappingCreateInput = {
    id?: string
    entityType: string
    legacyId: bigint | number
    newId: string
    createdAt?: Date | string
  }

  export type LegacyMappingUncheckedCreateInput = {
    id?: string
    entityType: string
    legacyId: bigint | number
    newId: string
    createdAt?: Date | string
  }

  export type LegacyMappingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    legacyId?: BigIntFieldUpdateOperationsInput | bigint | number
    newId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegacyMappingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    legacyId?: BigIntFieldUpdateOperationsInput | bigint | number
    newId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegacyMappingCreateManyInput = {
    id?: string
    entityType: string
    legacyId: bigint | number
    newId: string
    createdAt?: Date | string
  }

  export type LegacyMappingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    legacyId?: BigIntFieldUpdateOperationsInput | bigint | number
    newId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LegacyMappingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    legacyId?: BigIntFieldUpdateOperationsInput | bigint | number
    newId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumCaseModeFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseMode | EnumCaseModeFieldRefInput<$PrismaModel>
    in?: $Enums.CaseMode[] | ListEnumCaseModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseMode[] | ListEnumCaseModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseModeFilter<$PrismaModel> | $Enums.CaseMode
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type AssuranceCaseListRelationFilter = {
    every?: AssuranceCaseWhereInput
    some?: AssuranceCaseWhereInput
    none?: AssuranceCaseWhereInput
  }

  export type CasePermissionListRelationFilter = {
    every?: CasePermissionWhereInput
    some?: CasePermissionWhereInput
    none?: CasePermissionWhereInput
  }

  export type AssuranceElementListRelationFilter = {
    every?: AssuranceElementWhereInput
    some?: AssuranceElementWhereInput
    none?: AssuranceElementWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ReleaseCommentListRelationFilter = {
    every?: ReleaseCommentWhereInput
    some?: ReleaseCommentWhereInput
    none?: ReleaseCommentWhereInput
  }

  export type GitHubRepositoryListRelationFilter = {
    every?: GitHubRepositoryWhereInput
    some?: GitHubRepositoryWhereInput
    none?: GitHubRepositoryWhereInput
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type CaseStudyListRelationFilter = {
    every?: CaseStudyWhereInput
    some?: CaseStudyWhereInput
    none?: CaseStudyWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssuranceCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CasePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssuranceElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReleaseCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GitHubRepositoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaseStudyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    passwordAlgorithm?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    authProvider?: SortOrder
    githubId?: SortOrder
    githubUsername?: SortOrder
    emailVerified?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    defaultCaseMode?: SortOrder
    hasSeenMigrationNotice?: SortOrder
    isSystemUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    passwordAlgorithm?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    authProvider?: SortOrder
    githubId?: SortOrder
    githubUsername?: SortOrder
    emailVerified?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    defaultCaseMode?: SortOrder
    hasSeenMigrationNotice?: SortOrder
    isSystemUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    passwordHash?: SortOrder
    passwordAlgorithm?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    authProvider?: SortOrder
    githubId?: SortOrder
    githubUsername?: SortOrder
    emailVerified?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    defaultCaseMode?: SortOrder
    hasSeenMigrationNotice?: SortOrder
    isSystemUser?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLoginAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumCaseModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseMode | EnumCaseModeFieldRefInput<$PrismaModel>
    in?: $Enums.CaseMode[] | ListEnumCaseModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseMode[] | ListEnumCaseModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseModeWithAggregatesFilter<$PrismaModel> | $Enums.CaseMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaseModeFilter<$PrismaModel>
    _max?: NestedEnumCaseModeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
    userAgent?: SortOrder
    ipAddress?: SortOrder
  }

  export type PasswordResetAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    attemptedAt?: SortOrder
    successful?: SortOrder
  }

  export type PasswordResetAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    attemptedAt?: SortOrder
    successful?: SortOrder
  }

  export type PasswordResetAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    ipAddress?: SortOrder
    attemptedAt?: SortOrder
    successful?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SecurityAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SecurityAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    eventType?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CaseTeamPermissionListRelationFilter = {
    every?: CaseTeamPermissionWhereInput
    some?: CaseTeamPermissionWhereInput
    none?: CaseTeamPermissionWhereInput
  }

  export type PatternTeamPermissionListRelationFilter = {
    every?: PatternTeamPermissionWhereInput
    some?: PatternTeamPermissionWhereInput
    none?: PatternTeamPermissionWhereInput
  }

  export type CaseTeamPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatternTeamPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    organisationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    organisationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    organisationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type EnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type TeamScalarRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: string
    userId: string
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedById?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedById?: SortOrder
    joinedAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    invitedById?: SortOrder
    joinedAt?: SortOrder
  }

  export type EnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type EnumPublishStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ArgumentPatternNullableScalarRelationFilter = {
    is?: ArgumentPatternWhereInput | null
    isNot?: ArgumentPatternWhereInput | null
  }

  export type CaseInviteListRelationFilter = {
    every?: CaseInviteWhereInput
    some?: CaseInviteWhereInput
    none?: CaseInviteWhereInput
  }

  export type CaseImageNullableScalarRelationFilter = {
    is?: CaseImageWhereInput | null
    isNot?: CaseImageWhereInput | null
  }

  export type CaseTypeAssignmentListRelationFilter = {
    every?: CaseTypeAssignmentWhereInput
    some?: CaseTypeAssignmentWhereInput
    none?: CaseTypeAssignmentWhereInput
  }

  export type ReleaseListRelationFilter = {
    every?: ReleaseWhereInput
    some?: ReleaseWhereInput
    none?: ReleaseWhereInput
  }

  export type PublishedAssuranceCaseListRelationFilter = {
    every?: PublishedAssuranceCaseWhereInput
    some?: PublishedAssuranceCaseWhereInput
    none?: PublishedAssuranceCaseWhereInput
  }

  export type CaseInviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaseTypeAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReleaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublishedAssuranceCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssuranceCaseCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    mode?: SortOrder
    colorProfile?: SortOrder
    lockUuid?: SortOrder
    lockedById?: SortOrder
    lockedAt?: SortOrder
    sourcePatternId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    publishStatus?: SortOrder
    markedReadyAt?: SortOrder
    markedReadyById?: SortOrder
  }

  export type AssuranceCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    mode?: SortOrder
    colorProfile?: SortOrder
    lockUuid?: SortOrder
    lockedById?: SortOrder
    lockedAt?: SortOrder
    sourcePatternId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    publishStatus?: SortOrder
    markedReadyAt?: SortOrder
    markedReadyById?: SortOrder
  }

  export type AssuranceCaseMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    mode?: SortOrder
    colorProfile?: SortOrder
    lockUuid?: SortOrder
    lockedById?: SortOrder
    lockedAt?: SortOrder
    sourcePatternId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    publishStatus?: SortOrder
    markedReadyAt?: SortOrder
    markedReadyById?: SortOrder
  }

  export type EnumPublishStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>
  }

  export type EnumPermissionLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionLevel | EnumPermissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionLevelFilter<$PrismaModel> | $Enums.PermissionLevel
  }

  export type AssuranceCaseScalarRelationFilter = {
    is?: AssuranceCaseWhereInput
    isNot?: AssuranceCaseWhereInput
  }

  export type CasePermissionCaseIdUserIdCompoundUniqueInput = {
    caseId: string
    userId: string
  }

  export type CasePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type CasePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type CasePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type EnumPermissionLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionLevel | EnumPermissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionLevelWithAggregatesFilter<$PrismaModel> | $Enums.PermissionLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionLevelFilter<$PrismaModel>
    _max?: NestedEnumPermissionLevelFilter<$PrismaModel>
  }

  export type CaseTeamPermissionCaseIdTeamIdCompoundUniqueInput = {
    caseId: string
    teamId: string
  }

  export type CaseTeamPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type CaseTeamPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type CaseTeamPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type CaseInviteCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    email?: SortOrder
    permission?: SortOrder
    inviteToken?: SortOrder
    inviteExpiresAt?: SortOrder
    acceptedAt?: SortOrder
    acceptedById?: SortOrder
    invitedById?: SortOrder
    createdAt?: SortOrder
  }

  export type CaseInviteMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    email?: SortOrder
    permission?: SortOrder
    inviteToken?: SortOrder
    inviteExpiresAt?: SortOrder
    acceptedAt?: SortOrder
    acceptedById?: SortOrder
    invitedById?: SortOrder
    createdAt?: SortOrder
  }

  export type CaseInviteMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    email?: SortOrder
    permission?: SortOrder
    inviteToken?: SortOrder
    inviteExpiresAt?: SortOrder
    acceptedAt?: SortOrder
    acceptedById?: SortOrder
    invitedById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumElementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeFilter<$PrismaModel> | $Enums.ElementType
  }

  export type EnumElementRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementRole | EnumElementRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.ElementRole[] | ListEnumElementRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ElementRole[] | ListEnumElementRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumElementRoleNullableFilter<$PrismaModel> | $Enums.ElementRole | null
  }

  export type EnumModuleEmbedTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ModuleEmbedType | EnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ModuleEmbedType[] | ListEnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ModuleEmbedType[] | ListEnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumModuleEmbedTypeNullableFilter<$PrismaModel> | $Enums.ModuleEmbedType | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AssuranceElementNullableScalarRelationFilter = {
    is?: AssuranceElementWhereInput | null
    isNot?: AssuranceElementWhereInput | null
  }

  export type AssuranceCaseNullableScalarRelationFilter = {
    is?: AssuranceCaseWhereInput | null
    isNot?: AssuranceCaseWhereInput | null
  }

  export type EvidenceLinkListRelationFilter = {
    every?: EvidenceLinkWhereInput
    some?: EvidenceLinkWhereInput
    none?: EvidenceLinkWhereInput
  }

  export type EvidenceLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AssuranceElementCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    elementType?: SortOrder
    role?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assumption?: SortOrder
    justification?: SortOrder
    url?: SortOrder
    moduleReferenceId?: SortOrder
    moduleEmbedType?: SortOrder
    modulePublicSummary?: SortOrder
    fromPattern?: SortOrder
    modifiedFromPattern?: SortOrder
    inSandbox?: SortOrder
    isDefeater?: SortOrder
    defeatsElementId?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type AssuranceElementAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type AssuranceElementMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    elementType?: SortOrder
    role?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assumption?: SortOrder
    justification?: SortOrder
    url?: SortOrder
    moduleReferenceId?: SortOrder
    moduleEmbedType?: SortOrder
    modulePublicSummary?: SortOrder
    fromPattern?: SortOrder
    modifiedFromPattern?: SortOrder
    inSandbox?: SortOrder
    isDefeater?: SortOrder
    defeatsElementId?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type AssuranceElementMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    elementType?: SortOrder
    role?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assumption?: SortOrder
    justification?: SortOrder
    url?: SortOrder
    moduleReferenceId?: SortOrder
    moduleEmbedType?: SortOrder
    modulePublicSummary?: SortOrder
    fromPattern?: SortOrder
    modifiedFromPattern?: SortOrder
    inSandbox?: SortOrder
    isDefeater?: SortOrder
    defeatsElementId?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdById?: SortOrder
  }

  export type AssuranceElementSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type EnumElementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ElementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumElementTypeFilter<$PrismaModel>
    _max?: NestedEnumElementTypeFilter<$PrismaModel>
  }

  export type EnumElementRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementRole | EnumElementRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.ElementRole[] | ListEnumElementRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ElementRole[] | ListEnumElementRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumElementRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.ElementRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumElementRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumElementRoleNullableFilter<$PrismaModel>
  }

  export type EnumModuleEmbedTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModuleEmbedType | EnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ModuleEmbedType[] | ListEnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ModuleEmbedType[] | ListEnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumModuleEmbedTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ModuleEmbedType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumModuleEmbedTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumModuleEmbedTypeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AssuranceElementScalarRelationFilter = {
    is?: AssuranceElementWhereInput
    isNot?: AssuranceElementWhereInput
  }

  export type EvidenceLinkEvidenceIdClaimIdCompoundUniqueInput = {
    evidenceId: string
    claimId: string
  }

  export type EvidenceLinkCountOrderByAggregateInput = {
    id?: SortOrder
    evidenceId?: SortOrder
    claimId?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    evidenceId?: SortOrder
    claimId?: SortOrder
    createdAt?: SortOrder
  }

  export type EvidenceLinkMinOrderByAggregateInput = {
    id?: SortOrder
    evidenceId?: SortOrder
    claimId?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type PatternElementListRelationFilter = {
    every?: PatternElementWhereInput
    some?: PatternElementWhereInput
    none?: PatternElementWhereInput
  }

  export type PatternPermissionListRelationFilter = {
    every?: PatternPermissionWhereInput
    some?: PatternPermissionWhereInput
    none?: PatternPermissionWhereInput
  }

  export type PatternElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatternPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ArgumentPatternCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArgumentPatternMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    category?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ArgumentPatternMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    version?: SortOrder
    category?: SortOrder
    published?: SortOrder
    publishedAt?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ArgumentPatternScalarRelationFilter = {
    is?: ArgumentPatternWhereInput
    isNot?: ArgumentPatternWhereInput
  }

  export type PatternElementNullableScalarRelationFilter = {
    is?: PatternElementWhereInput | null
    isNot?: PatternElementWhereInput | null
  }

  export type PatternElementCountOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    elementType?: SortOrder
    role?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assumption?: SortOrder
    justification?: SortOrder
    url?: SortOrder
    isPlaceholder?: SortOrder
    placeholderHint?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatternElementAvgOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type PatternElementMaxOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    elementType?: SortOrder
    role?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assumption?: SortOrder
    justification?: SortOrder
    url?: SortOrder
    isPlaceholder?: SortOrder
    placeholderHint?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatternElementMinOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    elementType?: SortOrder
    role?: SortOrder
    parentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    assumption?: SortOrder
    justification?: SortOrder
    url?: SortOrder
    isPlaceholder?: SortOrder
    placeholderHint?: SortOrder
    displayOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatternElementSumOrderByAggregateInput = {
    displayOrder?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PatternPermissionPatternIdUserIdCompoundUniqueInput = {
    patternId: string
    userId: string
  }

  export type PatternPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type PatternPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type PatternPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    userId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type PatternTeamPermissionPatternIdTeamIdCompoundUniqueInput = {
    patternId: string
    teamId: string
  }

  export type PatternTeamPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type PatternTeamPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type PatternTeamPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    patternId?: SortOrder
    teamId?: SortOrder
    permission?: SortOrder
    grantedById?: SortOrder
    grantedAt?: SortOrder
  }

  export type EnumReleaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReleaseStatus | EnumReleaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReleaseStatus[] | ListEnumReleaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReleaseStatus[] | ListEnumReleaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReleaseStatusFilter<$PrismaModel> | $Enums.ReleaseStatus
  }

  export type ReleaseSnapshotListRelationFilter = {
    every?: ReleaseSnapshotWhereInput
    some?: ReleaseSnapshotWhereInput
    none?: ReleaseSnapshotWhereInput
  }

  export type ReleaseImageNullableScalarRelationFilter = {
    is?: ReleaseImageWhereInput | null
    isNot?: ReleaseImageWhereInput | null
  }

  export type ReleaseSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReleaseCountOrderByAggregateInput = {
    id?: SortOrder
    sourceCaseId?: SortOrder
    publishedCaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currentVersion?: SortOrder
    authors?: SortOrder
    contactEmail?: SortOrder
    category?: SortOrder
    sector?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    firstPublishedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    allowComments?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseAvgOrderByAggregateInput = {
    currentVersion?: SortOrder
  }

  export type ReleaseMaxOrderByAggregateInput = {
    id?: SortOrder
    sourceCaseId?: SortOrder
    publishedCaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currentVersion?: SortOrder
    authors?: SortOrder
    contactEmail?: SortOrder
    category?: SortOrder
    sector?: SortOrder
    status?: SortOrder
    firstPublishedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    allowComments?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseMinOrderByAggregateInput = {
    id?: SortOrder
    sourceCaseId?: SortOrder
    publishedCaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currentVersion?: SortOrder
    authors?: SortOrder
    contactEmail?: SortOrder
    category?: SortOrder
    sector?: SortOrder
    status?: SortOrder
    firstPublishedAt?: SortOrder
    lastUpdatedAt?: SortOrder
    allowComments?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseSumOrderByAggregateInput = {
    currentVersion?: SortOrder
  }

  export type EnumReleaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReleaseStatus | EnumReleaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReleaseStatus[] | ListEnumReleaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReleaseStatus[] | ListEnumReleaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReleaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReleaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReleaseStatusFilter<$PrismaModel>
    _max?: NestedEnumReleaseStatusFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumSnapshotReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotReason | EnumSnapshotReasonFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotReason[] | ListEnumSnapshotReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotReason[] | ListEnumSnapshotReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotReasonFilter<$PrismaModel> | $Enums.SnapshotReason
  }

  export type ReleaseScalarRelationFilter = {
    is?: ReleaseWhereInput
    isNot?: ReleaseWhereInput
  }

  export type ReleaseSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    versionNumber?: SortOrder
    versionLabel?: SortOrder
    content?: SortOrder
    snapshotTakenAt?: SortOrder
    snapshotTakenById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReleaseSnapshotAvgOrderByAggregateInput = {
    versionNumber?: SortOrder
  }

  export type ReleaseSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    versionNumber?: SortOrder
    versionLabel?: SortOrder
    snapshotTakenAt?: SortOrder
    snapshotTakenById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReleaseSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    versionNumber?: SortOrder
    versionLabel?: SortOrder
    snapshotTakenAt?: SortOrder
    snapshotTakenById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReleaseSnapshotSumOrderByAggregateInput = {
    versionNumber?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumSnapshotReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotReason | EnumSnapshotReasonFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotReason[] | ListEnumSnapshotReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotReason[] | ListEnumSnapshotReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotReasonWithAggregatesFilter<$PrismaModel> | $Enums.SnapshotReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnapshotReasonFilter<$PrismaModel>
    _max?: NestedEnumSnapshotReasonFilter<$PrismaModel>
  }

  export type EnumCommentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusFilter<$PrismaModel> | $Enums.CommentStatus
  }

  export type ReleaseCommentNullableScalarRelationFilter = {
    is?: ReleaseCommentWhereInput | null
    isNot?: ReleaseCommentWhereInput | null
  }

  export type ReleaseCommentCountOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    elementId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    status?: SortOrder
    hiddenById?: SortOrder
    hiddenAt?: SortOrder
    hiddenReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    elementId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    status?: SortOrder
    hiddenById?: SortOrder
    hiddenAt?: SortOrder
    hiddenReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReleaseCommentMinOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    elementId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    status?: SortOrder
    hiddenById?: SortOrder
    hiddenAt?: SortOrder
    hiddenReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCommentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommentStatusFilter<$PrismaModel>
    _max?: NestedEnumCommentStatusFilter<$PrismaModel>
  }

  export type ReleaseImageCountOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type ReleaseImageMaxOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type ReleaseImageMinOrderByAggregateInput = {
    id?: SortOrder
    releaseId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    elementId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    resolved?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    elementId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    resolved?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    elementId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    authorId?: SortOrder
    resolved?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseImageCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    imageUrl?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type CaseImageMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    imageUrl?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type CaseImageMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    imageUrl?: SortOrder
    uploadedAt?: SortOrder
    uploadedById?: SortOrder
  }

  export type EnumCaseTypeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseTypeCategory | EnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CaseTypeCategory[] | ListEnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseTypeCategory[] | ListEnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseTypeCategoryFilter<$PrismaModel> | $Enums.CaseTypeCategory
  }

  export type CaseTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    externalUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CaseTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    externalUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CaseTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    externalUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCaseTypeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseTypeCategory | EnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CaseTypeCategory[] | ListEnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseTypeCategory[] | ListEnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseTypeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.CaseTypeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaseTypeCategoryFilter<$PrismaModel>
    _max?: NestedEnumCaseTypeCategoryFilter<$PrismaModel>
  }

  export type CaseTypeScalarRelationFilter = {
    is?: CaseTypeWhereInput
    isNot?: CaseTypeWhereInput
  }

  export type CaseTypeAssignmentCaseIdCaseTypeIdCompoundUniqueInput = {
    caseId: string
    caseTypeId: string
  }

  export type CaseTypeAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    caseTypeId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
  }

  export type CaseTypeAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    caseTypeId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
  }

  export type CaseTypeAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    caseId?: SortOrder
    caseTypeId?: SortOrder
    assignedById?: SortOrder
    assignedAt?: SortOrder
  }

  export type GitHubRepositoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrder
    githubId?: SortOrder
    defaultBranch?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GitHubRepositoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrder
    githubId?: SortOrder
    defaultBranch?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GitHubRepositoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    url?: SortOrder
    description?: SortOrder
    githubId?: SortOrder
    defaultBranch?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CaseStudyPublishedCaseListRelationFilter = {
    every?: CaseStudyPublishedCaseWhereInput
    some?: CaseStudyPublishedCaseWhereInput
    none?: CaseStudyPublishedCaseWhereInput
  }

  export type CaseStudyImageNullableScalarRelationFilter = {
    is?: CaseStudyImageWhereInput | null
    isNot?: CaseStudyImageWhereInput | null
  }

  export type CaseStudyPublishedCaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CaseStudyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    authors?: SortOrder
    category?: SortOrder
    publishedDate?: SortOrder
    lastModifiedOn?: SortOrder
    createdOn?: SortOrder
    sector?: SortOrder
    contact?: SortOrder
    image?: SortOrder
    published?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
  }

  export type CaseStudyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CaseStudyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    authors?: SortOrder
    category?: SortOrder
    publishedDate?: SortOrder
    lastModifiedOn?: SortOrder
    createdOn?: SortOrder
    sector?: SortOrder
    contact?: SortOrder
    image?: SortOrder
    published?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
  }

  export type CaseStudyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    authors?: SortOrder
    category?: SortOrder
    publishedDate?: SortOrder
    lastModifiedOn?: SortOrder
    createdOn?: SortOrder
    sector?: SortOrder
    contact?: SortOrder
    image?: SortOrder
    published?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
  }

  export type CaseStudySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type CaseStudyScalarRelationFilter = {
    is?: CaseStudyWhereInput
    isNot?: CaseStudyWhereInput
  }

  export type PublishedAssuranceCaseScalarRelationFilter = {
    is?: PublishedAssuranceCaseWhereInput
    isNot?: PublishedAssuranceCaseWhereInput
  }

  export type CaseStudyPublishedCaseCaseStudyIdPublishedAssuranceCaseIdCompoundUniqueInput = {
    caseStudyId: number
    publishedAssuranceCaseId: string
  }

  export type CaseStudyPublishedCaseCountOrderByAggregateInput = {
    id?: SortOrder
    caseStudyId?: SortOrder
    publishedAssuranceCaseId?: SortOrder
  }

  export type CaseStudyPublishedCaseAvgOrderByAggregateInput = {
    id?: SortOrder
    caseStudyId?: SortOrder
  }

  export type CaseStudyPublishedCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    caseStudyId?: SortOrder
    publishedAssuranceCaseId?: SortOrder
  }

  export type CaseStudyPublishedCaseMinOrderByAggregateInput = {
    id?: SortOrder
    caseStudyId?: SortOrder
    publishedAssuranceCaseId?: SortOrder
  }

  export type CaseStudyPublishedCaseSumOrderByAggregateInput = {
    id?: SortOrder
    caseStudyId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type CaseStudyImageCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    uploadedAt?: SortOrder
    caseStudyId?: SortOrder
  }

  export type CaseStudyImageAvgOrderByAggregateInput = {
    id?: SortOrder
    caseStudyId?: SortOrder
  }

  export type CaseStudyImageMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    uploadedAt?: SortOrder
    caseStudyId?: SortOrder
  }

  export type CaseStudyImageMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    uploadedAt?: SortOrder
    caseStudyId?: SortOrder
  }

  export type CaseStudyImageSumOrderByAggregateInput = {
    id?: SortOrder
    caseStudyId?: SortOrder
  }

  export type PublishedAssuranceCaseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    assuranceCaseId?: SortOrder
    description?: SortOrder
  }

  export type PublishedAssuranceCaseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    assuranceCaseId?: SortOrder
    description?: SortOrder
  }

  export type PublishedAssuranceCaseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    assuranceCaseId?: SortOrder
    description?: SortOrder
  }

  export type LegacyMappingEntityTypeLegacyIdCompoundUniqueInput = {
    entityType: string
    legacyId: bigint | number
  }

  export type LegacyMappingCountOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    legacyId?: SortOrder
    newId?: SortOrder
    createdAt?: SortOrder
  }

  export type LegacyMappingAvgOrderByAggregateInput = {
    legacyId?: SortOrder
  }

  export type LegacyMappingMaxOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    legacyId?: SortOrder
    newId?: SortOrder
    createdAt?: SortOrder
  }

  export type LegacyMappingMinOrderByAggregateInput = {
    id?: SortOrder
    entityType?: SortOrder
    legacyId?: SortOrder
    newId?: SortOrder
    createdAt?: SortOrder
  }

  export type LegacyMappingSumOrderByAggregateInput = {
    legacyId?: SortOrder
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type AssuranceCaseCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AssuranceCaseCreateWithoutCreatedByInput, AssuranceCaseUncheckedCreateWithoutCreatedByInput> | AssuranceCaseCreateWithoutCreatedByInput[] | AssuranceCaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCreatedByInput | AssuranceCaseCreateOrConnectWithoutCreatedByInput[]
    createMany?: AssuranceCaseCreateManyCreatedByInputEnvelope
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
  }

  export type CasePermissionCreateNestedManyWithoutUserInput = {
    create?: XOR<CasePermissionCreateWithoutUserInput, CasePermissionUncheckedCreateWithoutUserInput> | CasePermissionCreateWithoutUserInput[] | CasePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutUserInput | CasePermissionCreateOrConnectWithoutUserInput[]
    createMany?: CasePermissionCreateManyUserInputEnvelope
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
  }

  export type CasePermissionCreateNestedManyWithoutGrantedByInput = {
    create?: XOR<CasePermissionCreateWithoutGrantedByInput, CasePermissionUncheckedCreateWithoutGrantedByInput> | CasePermissionCreateWithoutGrantedByInput[] | CasePermissionUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutGrantedByInput | CasePermissionCreateOrConnectWithoutGrantedByInput[]
    createMany?: CasePermissionCreateManyGrantedByInputEnvelope
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
  }

  export type AssuranceElementCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AssuranceElementCreateWithoutCreatedByInput, AssuranceElementUncheckedCreateWithoutCreatedByInput> | AssuranceElementCreateWithoutCreatedByInput[] | AssuranceElementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCreatedByInput | AssuranceElementCreateOrConnectWithoutCreatedByInput[]
    createMany?: AssuranceElementCreateManyCreatedByInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<CommentCreateWithoutResolvedByInput, CommentUncheckedCreateWithoutResolvedByInput> | CommentCreateWithoutResolvedByInput[] | CommentUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutResolvedByInput | CommentCreateOrConnectWithoutResolvedByInput[]
    createMany?: CommentCreateManyResolvedByInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReleaseCommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReleaseCommentCreateWithoutAuthorInput, ReleaseCommentUncheckedCreateWithoutAuthorInput> | ReleaseCommentCreateWithoutAuthorInput[] | ReleaseCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutAuthorInput | ReleaseCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: ReleaseCommentCreateManyAuthorInputEnvelope
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
  }

  export type GitHubRepositoryCreateNestedManyWithoutUserInput = {
    create?: XOR<GitHubRepositoryCreateWithoutUserInput, GitHubRepositoryUncheckedCreateWithoutUserInput> | GitHubRepositoryCreateWithoutUserInput[] | GitHubRepositoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GitHubRepositoryCreateOrConnectWithoutUserInput | GitHubRepositoryCreateOrConnectWithoutUserInput[]
    createMany?: GitHubRepositoryCreateManyUserInputEnvelope
    connect?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type CaseStudyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CaseStudyCreateWithoutOwnerInput, CaseStudyUncheckedCreateWithoutOwnerInput> | CaseStudyCreateWithoutOwnerInput[] | CaseStudyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutOwnerInput | CaseStudyCreateOrConnectWithoutOwnerInput[]
    createMany?: CaseStudyCreateManyOwnerInputEnvelope
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
  }

  export type AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput = {
    create?: XOR<AssuranceCaseCreateWithoutMarkedReadyByInput, AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput> | AssuranceCaseCreateWithoutMarkedReadyByInput[] | AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutMarkedReadyByInput | AssuranceCaseCreateOrConnectWithoutMarkedReadyByInput[]
    createMany?: AssuranceCaseCreateManyMarkedReadyByInputEnvelope
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AssuranceCaseCreateWithoutCreatedByInput, AssuranceCaseUncheckedCreateWithoutCreatedByInput> | AssuranceCaseCreateWithoutCreatedByInput[] | AssuranceCaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCreatedByInput | AssuranceCaseCreateOrConnectWithoutCreatedByInput[]
    createMany?: AssuranceCaseCreateManyCreatedByInputEnvelope
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
  }

  export type CasePermissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CasePermissionCreateWithoutUserInput, CasePermissionUncheckedCreateWithoutUserInput> | CasePermissionCreateWithoutUserInput[] | CasePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutUserInput | CasePermissionCreateOrConnectWithoutUserInput[]
    createMany?: CasePermissionCreateManyUserInputEnvelope
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
  }

  export type CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput = {
    create?: XOR<CasePermissionCreateWithoutGrantedByInput, CasePermissionUncheckedCreateWithoutGrantedByInput> | CasePermissionCreateWithoutGrantedByInput[] | CasePermissionUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutGrantedByInput | CasePermissionCreateOrConnectWithoutGrantedByInput[]
    createMany?: CasePermissionCreateManyGrantedByInputEnvelope
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
  }

  export type AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AssuranceElementCreateWithoutCreatedByInput, AssuranceElementUncheckedCreateWithoutCreatedByInput> | AssuranceElementCreateWithoutCreatedByInput[] | AssuranceElementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCreatedByInput | AssuranceElementCreateOrConnectWithoutCreatedByInput[]
    createMany?: AssuranceElementCreateManyCreatedByInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<CommentCreateWithoutResolvedByInput, CommentUncheckedCreateWithoutResolvedByInput> | CommentCreateWithoutResolvedByInput[] | CommentUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutResolvedByInput | CommentCreateOrConnectWithoutResolvedByInput[]
    createMany?: CommentCreateManyResolvedByInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReleaseCommentCreateWithoutAuthorInput, ReleaseCommentUncheckedCreateWithoutAuthorInput> | ReleaseCommentCreateWithoutAuthorInput[] | ReleaseCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutAuthorInput | ReleaseCommentCreateOrConnectWithoutAuthorInput[]
    createMany?: ReleaseCommentCreateManyAuthorInputEnvelope
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
  }

  export type GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<GitHubRepositoryCreateWithoutUserInput, GitHubRepositoryUncheckedCreateWithoutUserInput> | GitHubRepositoryCreateWithoutUserInput[] | GitHubRepositoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GitHubRepositoryCreateOrConnectWithoutUserInput | GitHubRepositoryCreateOrConnectWithoutUserInput[]
    createMany?: GitHubRepositoryCreateManyUserInputEnvelope
    connect?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type CaseStudyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CaseStudyCreateWithoutOwnerInput, CaseStudyUncheckedCreateWithoutOwnerInput> | CaseStudyCreateWithoutOwnerInput[] | CaseStudyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutOwnerInput | CaseStudyCreateOrConnectWithoutOwnerInput[]
    createMany?: CaseStudyCreateManyOwnerInputEnvelope
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
  }

  export type AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput = {
    create?: XOR<AssuranceCaseCreateWithoutMarkedReadyByInput, AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput> | AssuranceCaseCreateWithoutMarkedReadyByInput[] | AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutMarkedReadyByInput | AssuranceCaseCreateOrConnectWithoutMarkedReadyByInput[]
    createMany?: AssuranceCaseCreateManyMarkedReadyByInputEnvelope
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumCaseModeFieldUpdateOperationsInput = {
    set?: $Enums.CaseMode
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatedByInput | TeamUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatedByInput | TeamUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatedByInput | TeamUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type AssuranceCaseUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutCreatedByInput, AssuranceCaseUncheckedCreateWithoutCreatedByInput> | AssuranceCaseCreateWithoutCreatedByInput[] | AssuranceCaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCreatedByInput | AssuranceCaseCreateOrConnectWithoutCreatedByInput[]
    upsert?: AssuranceCaseUpsertWithWhereUniqueWithoutCreatedByInput | AssuranceCaseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AssuranceCaseCreateManyCreatedByInputEnvelope
    set?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    disconnect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    delete?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    update?: AssuranceCaseUpdateWithWhereUniqueWithoutCreatedByInput | AssuranceCaseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AssuranceCaseUpdateManyWithWhereWithoutCreatedByInput | AssuranceCaseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AssuranceCaseScalarWhereInput | AssuranceCaseScalarWhereInput[]
  }

  export type CasePermissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CasePermissionCreateWithoutUserInput, CasePermissionUncheckedCreateWithoutUserInput> | CasePermissionCreateWithoutUserInput[] | CasePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutUserInput | CasePermissionCreateOrConnectWithoutUserInput[]
    upsert?: CasePermissionUpsertWithWhereUniqueWithoutUserInput | CasePermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CasePermissionCreateManyUserInputEnvelope
    set?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    disconnect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    delete?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    update?: CasePermissionUpdateWithWhereUniqueWithoutUserInput | CasePermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CasePermissionUpdateManyWithWhereWithoutUserInput | CasePermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CasePermissionScalarWhereInput | CasePermissionScalarWhereInput[]
  }

  export type CasePermissionUpdateManyWithoutGrantedByNestedInput = {
    create?: XOR<CasePermissionCreateWithoutGrantedByInput, CasePermissionUncheckedCreateWithoutGrantedByInput> | CasePermissionCreateWithoutGrantedByInput[] | CasePermissionUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutGrantedByInput | CasePermissionCreateOrConnectWithoutGrantedByInput[]
    upsert?: CasePermissionUpsertWithWhereUniqueWithoutGrantedByInput | CasePermissionUpsertWithWhereUniqueWithoutGrantedByInput[]
    createMany?: CasePermissionCreateManyGrantedByInputEnvelope
    set?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    disconnect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    delete?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    update?: CasePermissionUpdateWithWhereUniqueWithoutGrantedByInput | CasePermissionUpdateWithWhereUniqueWithoutGrantedByInput[]
    updateMany?: CasePermissionUpdateManyWithWhereWithoutGrantedByInput | CasePermissionUpdateManyWithWhereWithoutGrantedByInput[]
    deleteMany?: CasePermissionScalarWhereInput | CasePermissionScalarWhereInput[]
  }

  export type AssuranceElementUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutCreatedByInput, AssuranceElementUncheckedCreateWithoutCreatedByInput> | AssuranceElementCreateWithoutCreatedByInput[] | AssuranceElementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCreatedByInput | AssuranceElementCreateOrConnectWithoutCreatedByInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutCreatedByInput | AssuranceElementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AssuranceElementCreateManyCreatedByInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutCreatedByInput | AssuranceElementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutCreatedByInput | AssuranceElementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<CommentCreateWithoutResolvedByInput, CommentUncheckedCreateWithoutResolvedByInput> | CommentCreateWithoutResolvedByInput[] | CommentUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutResolvedByInput | CommentCreateOrConnectWithoutResolvedByInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutResolvedByInput | CommentUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: CommentCreateManyResolvedByInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutResolvedByInput | CommentUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutResolvedByInput | CommentUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReleaseCommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReleaseCommentCreateWithoutAuthorInput, ReleaseCommentUncheckedCreateWithoutAuthorInput> | ReleaseCommentCreateWithoutAuthorInput[] | ReleaseCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutAuthorInput | ReleaseCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: ReleaseCommentUpsertWithWhereUniqueWithoutAuthorInput | ReleaseCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReleaseCommentCreateManyAuthorInputEnvelope
    set?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    disconnect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    delete?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    update?: ReleaseCommentUpdateWithWhereUniqueWithoutAuthorInput | ReleaseCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReleaseCommentUpdateManyWithWhereWithoutAuthorInput | ReleaseCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
  }

  export type GitHubRepositoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<GitHubRepositoryCreateWithoutUserInput, GitHubRepositoryUncheckedCreateWithoutUserInput> | GitHubRepositoryCreateWithoutUserInput[] | GitHubRepositoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GitHubRepositoryCreateOrConnectWithoutUserInput | GitHubRepositoryCreateOrConnectWithoutUserInput[]
    upsert?: GitHubRepositoryUpsertWithWhereUniqueWithoutUserInput | GitHubRepositoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GitHubRepositoryCreateManyUserInputEnvelope
    set?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
    disconnect?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
    delete?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
    connect?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
    update?: GitHubRepositoryUpdateWithWhereUniqueWithoutUserInput | GitHubRepositoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GitHubRepositoryUpdateManyWithWhereWithoutUserInput | GitHubRepositoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GitHubRepositoryScalarWhereInput | GitHubRepositoryScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type CaseStudyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CaseStudyCreateWithoutOwnerInput, CaseStudyUncheckedCreateWithoutOwnerInput> | CaseStudyCreateWithoutOwnerInput[] | CaseStudyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutOwnerInput | CaseStudyCreateOrConnectWithoutOwnerInput[]
    upsert?: CaseStudyUpsertWithWhereUniqueWithoutOwnerInput | CaseStudyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CaseStudyCreateManyOwnerInputEnvelope
    set?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    disconnect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    delete?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    update?: CaseStudyUpdateWithWhereUniqueWithoutOwnerInput | CaseStudyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CaseStudyUpdateManyWithWhereWithoutOwnerInput | CaseStudyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
  }

  export type AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutMarkedReadyByInput, AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput> | AssuranceCaseCreateWithoutMarkedReadyByInput[] | AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutMarkedReadyByInput | AssuranceCaseCreateOrConnectWithoutMarkedReadyByInput[]
    upsert?: AssuranceCaseUpsertWithWhereUniqueWithoutMarkedReadyByInput | AssuranceCaseUpsertWithWhereUniqueWithoutMarkedReadyByInput[]
    createMany?: AssuranceCaseCreateManyMarkedReadyByInputEnvelope
    set?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    disconnect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    delete?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    update?: AssuranceCaseUpdateWithWhereUniqueWithoutMarkedReadyByInput | AssuranceCaseUpdateWithWhereUniqueWithoutMarkedReadyByInput[]
    updateMany?: AssuranceCaseUpdateManyWithWhereWithoutMarkedReadyByInput | AssuranceCaseUpdateManyWithWhereWithoutMarkedReadyByInput[]
    deleteMany?: AssuranceCaseScalarWhereInput | AssuranceCaseScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput> | TeamCreateWithoutCreatedByInput[] | TeamUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutCreatedByInput | TeamCreateOrConnectWithoutCreatedByInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutCreatedByInput | TeamUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: TeamCreateManyCreatedByInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutCreatedByInput | TeamUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutCreatedByInput | TeamUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutCreatedByInput, AssuranceCaseUncheckedCreateWithoutCreatedByInput> | AssuranceCaseCreateWithoutCreatedByInput[] | AssuranceCaseUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCreatedByInput | AssuranceCaseCreateOrConnectWithoutCreatedByInput[]
    upsert?: AssuranceCaseUpsertWithWhereUniqueWithoutCreatedByInput | AssuranceCaseUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AssuranceCaseCreateManyCreatedByInputEnvelope
    set?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    disconnect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    delete?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    update?: AssuranceCaseUpdateWithWhereUniqueWithoutCreatedByInput | AssuranceCaseUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AssuranceCaseUpdateManyWithWhereWithoutCreatedByInput | AssuranceCaseUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AssuranceCaseScalarWhereInput | AssuranceCaseScalarWhereInput[]
  }

  export type CasePermissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CasePermissionCreateWithoutUserInput, CasePermissionUncheckedCreateWithoutUserInput> | CasePermissionCreateWithoutUserInput[] | CasePermissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutUserInput | CasePermissionCreateOrConnectWithoutUserInput[]
    upsert?: CasePermissionUpsertWithWhereUniqueWithoutUserInput | CasePermissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CasePermissionCreateManyUserInputEnvelope
    set?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    disconnect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    delete?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    update?: CasePermissionUpdateWithWhereUniqueWithoutUserInput | CasePermissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CasePermissionUpdateManyWithWhereWithoutUserInput | CasePermissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CasePermissionScalarWhereInput | CasePermissionScalarWhereInput[]
  }

  export type CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput = {
    create?: XOR<CasePermissionCreateWithoutGrantedByInput, CasePermissionUncheckedCreateWithoutGrantedByInput> | CasePermissionCreateWithoutGrantedByInput[] | CasePermissionUncheckedCreateWithoutGrantedByInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutGrantedByInput | CasePermissionCreateOrConnectWithoutGrantedByInput[]
    upsert?: CasePermissionUpsertWithWhereUniqueWithoutGrantedByInput | CasePermissionUpsertWithWhereUniqueWithoutGrantedByInput[]
    createMany?: CasePermissionCreateManyGrantedByInputEnvelope
    set?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    disconnect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    delete?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    update?: CasePermissionUpdateWithWhereUniqueWithoutGrantedByInput | CasePermissionUpdateWithWhereUniqueWithoutGrantedByInput[]
    updateMany?: CasePermissionUpdateManyWithWhereWithoutGrantedByInput | CasePermissionUpdateManyWithWhereWithoutGrantedByInput[]
    deleteMany?: CasePermissionScalarWhereInput | CasePermissionScalarWhereInput[]
  }

  export type AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutCreatedByInput, AssuranceElementUncheckedCreateWithoutCreatedByInput> | AssuranceElementCreateWithoutCreatedByInput[] | AssuranceElementUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCreatedByInput | AssuranceElementCreateOrConnectWithoutCreatedByInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutCreatedByInput | AssuranceElementUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AssuranceElementCreateManyCreatedByInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutCreatedByInput | AssuranceElementUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutCreatedByInput | AssuranceElementUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<CommentCreateWithoutResolvedByInput, CommentUncheckedCreateWithoutResolvedByInput> | CommentCreateWithoutResolvedByInput[] | CommentUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutResolvedByInput | CommentCreateOrConnectWithoutResolvedByInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutResolvedByInput | CommentUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: CommentCreateManyResolvedByInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutResolvedByInput | CommentUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutResolvedByInput | CommentUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReleaseCommentCreateWithoutAuthorInput, ReleaseCommentUncheckedCreateWithoutAuthorInput> | ReleaseCommentCreateWithoutAuthorInput[] | ReleaseCommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutAuthorInput | ReleaseCommentCreateOrConnectWithoutAuthorInput[]
    upsert?: ReleaseCommentUpsertWithWhereUniqueWithoutAuthorInput | ReleaseCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReleaseCommentCreateManyAuthorInputEnvelope
    set?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    disconnect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    delete?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    update?: ReleaseCommentUpdateWithWhereUniqueWithoutAuthorInput | ReleaseCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReleaseCommentUpdateManyWithWhereWithoutAuthorInput | ReleaseCommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
  }

  export type GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<GitHubRepositoryCreateWithoutUserInput, GitHubRepositoryUncheckedCreateWithoutUserInput> | GitHubRepositoryCreateWithoutUserInput[] | GitHubRepositoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: GitHubRepositoryCreateOrConnectWithoutUserInput | GitHubRepositoryCreateOrConnectWithoutUserInput[]
    upsert?: GitHubRepositoryUpsertWithWhereUniqueWithoutUserInput | GitHubRepositoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: GitHubRepositoryCreateManyUserInputEnvelope
    set?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
    disconnect?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
    delete?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
    connect?: GitHubRepositoryWhereUniqueInput | GitHubRepositoryWhereUniqueInput[]
    update?: GitHubRepositoryUpdateWithWhereUniqueWithoutUserInput | GitHubRepositoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: GitHubRepositoryUpdateManyWithWhereWithoutUserInput | GitHubRepositoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: GitHubRepositoryScalarWhereInput | GitHubRepositoryScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CaseStudyCreateWithoutOwnerInput, CaseStudyUncheckedCreateWithoutOwnerInput> | CaseStudyCreateWithoutOwnerInput[] | CaseStudyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CaseStudyCreateOrConnectWithoutOwnerInput | CaseStudyCreateOrConnectWithoutOwnerInput[]
    upsert?: CaseStudyUpsertWithWhereUniqueWithoutOwnerInput | CaseStudyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CaseStudyCreateManyOwnerInputEnvelope
    set?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    disconnect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    delete?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    connect?: CaseStudyWhereUniqueInput | CaseStudyWhereUniqueInput[]
    update?: CaseStudyUpdateWithWhereUniqueWithoutOwnerInput | CaseStudyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CaseStudyUpdateManyWithWhereWithoutOwnerInput | CaseStudyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
  }

  export type AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutMarkedReadyByInput, AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput> | AssuranceCaseCreateWithoutMarkedReadyByInput[] | AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutMarkedReadyByInput | AssuranceCaseCreateOrConnectWithoutMarkedReadyByInput[]
    upsert?: AssuranceCaseUpsertWithWhereUniqueWithoutMarkedReadyByInput | AssuranceCaseUpsertWithWhereUniqueWithoutMarkedReadyByInput[]
    createMany?: AssuranceCaseCreateManyMarkedReadyByInputEnvelope
    set?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    disconnect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    delete?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    update?: AssuranceCaseUpdateWithWhereUniqueWithoutMarkedReadyByInput | AssuranceCaseUpdateWithWhereUniqueWithoutMarkedReadyByInput[]
    updateMany?: AssuranceCaseUpdateManyWithWhereWithoutMarkedReadyByInput | AssuranceCaseUpdateManyWithWhereWithoutMarkedReadyByInput[]
    deleteMany?: AssuranceCaseScalarWhereInput | AssuranceCaseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserCreateNestedOneWithoutCreatedTeamsInput = {
    create?: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type CaseTeamPermissionCreateNestedManyWithoutTeamInput = {
    create?: XOR<CaseTeamPermissionCreateWithoutTeamInput, CaseTeamPermissionUncheckedCreateWithoutTeamInput> | CaseTeamPermissionCreateWithoutTeamInput[] | CaseTeamPermissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CaseTeamPermissionCreateOrConnectWithoutTeamInput | CaseTeamPermissionCreateOrConnectWithoutTeamInput[]
    createMany?: CaseTeamPermissionCreateManyTeamInputEnvelope
    connect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
  }

  export type PatternTeamPermissionCreateNestedManyWithoutTeamInput = {
    create?: XOR<PatternTeamPermissionCreateWithoutTeamInput, PatternTeamPermissionUncheckedCreateWithoutTeamInput> | PatternTeamPermissionCreateWithoutTeamInput[] | PatternTeamPermissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PatternTeamPermissionCreateOrConnectWithoutTeamInput | PatternTeamPermissionCreateOrConnectWithoutTeamInput[]
    createMany?: PatternTeamPermissionCreateManyTeamInputEnvelope
    connect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type CaseTeamPermissionUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<CaseTeamPermissionCreateWithoutTeamInput, CaseTeamPermissionUncheckedCreateWithoutTeamInput> | CaseTeamPermissionCreateWithoutTeamInput[] | CaseTeamPermissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CaseTeamPermissionCreateOrConnectWithoutTeamInput | CaseTeamPermissionCreateOrConnectWithoutTeamInput[]
    createMany?: CaseTeamPermissionCreateManyTeamInputEnvelope
    connect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
  }

  export type PatternTeamPermissionUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<PatternTeamPermissionCreateWithoutTeamInput, PatternTeamPermissionUncheckedCreateWithoutTeamInput> | PatternTeamPermissionCreateWithoutTeamInput[] | PatternTeamPermissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PatternTeamPermissionCreateOrConnectWithoutTeamInput | PatternTeamPermissionCreateOrConnectWithoutTeamInput[]
    createMany?: PatternTeamPermissionCreateManyTeamInputEnvelope
    connect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedTeamsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedTeamsInput
    upsert?: UserUpsertWithoutCreatedTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedTeamsInput, UserUpdateWithoutCreatedTeamsInput>, UserUncheckedUpdateWithoutCreatedTeamsInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type CaseTeamPermissionUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CaseTeamPermissionCreateWithoutTeamInput, CaseTeamPermissionUncheckedCreateWithoutTeamInput> | CaseTeamPermissionCreateWithoutTeamInput[] | CaseTeamPermissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CaseTeamPermissionCreateOrConnectWithoutTeamInput | CaseTeamPermissionCreateOrConnectWithoutTeamInput[]
    upsert?: CaseTeamPermissionUpsertWithWhereUniqueWithoutTeamInput | CaseTeamPermissionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CaseTeamPermissionCreateManyTeamInputEnvelope
    set?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    disconnect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    delete?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    connect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    update?: CaseTeamPermissionUpdateWithWhereUniqueWithoutTeamInput | CaseTeamPermissionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CaseTeamPermissionUpdateManyWithWhereWithoutTeamInput | CaseTeamPermissionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CaseTeamPermissionScalarWhereInput | CaseTeamPermissionScalarWhereInput[]
  }

  export type PatternTeamPermissionUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PatternTeamPermissionCreateWithoutTeamInput, PatternTeamPermissionUncheckedCreateWithoutTeamInput> | PatternTeamPermissionCreateWithoutTeamInput[] | PatternTeamPermissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PatternTeamPermissionCreateOrConnectWithoutTeamInput | PatternTeamPermissionCreateOrConnectWithoutTeamInput[]
    upsert?: PatternTeamPermissionUpsertWithWhereUniqueWithoutTeamInput | PatternTeamPermissionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PatternTeamPermissionCreateManyTeamInputEnvelope
    set?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    disconnect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    delete?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    connect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    update?: PatternTeamPermissionUpdateWithWhereUniqueWithoutTeamInput | PatternTeamPermissionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PatternTeamPermissionUpdateManyWithWhereWithoutTeamInput | PatternTeamPermissionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PatternTeamPermissionScalarWhereInput | PatternTeamPermissionScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type CaseTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CaseTeamPermissionCreateWithoutTeamInput, CaseTeamPermissionUncheckedCreateWithoutTeamInput> | CaseTeamPermissionCreateWithoutTeamInput[] | CaseTeamPermissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CaseTeamPermissionCreateOrConnectWithoutTeamInput | CaseTeamPermissionCreateOrConnectWithoutTeamInput[]
    upsert?: CaseTeamPermissionUpsertWithWhereUniqueWithoutTeamInput | CaseTeamPermissionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CaseTeamPermissionCreateManyTeamInputEnvelope
    set?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    disconnect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    delete?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    connect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    update?: CaseTeamPermissionUpdateWithWhereUniqueWithoutTeamInput | CaseTeamPermissionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CaseTeamPermissionUpdateManyWithWhereWithoutTeamInput | CaseTeamPermissionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CaseTeamPermissionScalarWhereInput | CaseTeamPermissionScalarWhereInput[]
  }

  export type PatternTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<PatternTeamPermissionCreateWithoutTeamInput, PatternTeamPermissionUncheckedCreateWithoutTeamInput> | PatternTeamPermissionCreateWithoutTeamInput[] | PatternTeamPermissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: PatternTeamPermissionCreateOrConnectWithoutTeamInput | PatternTeamPermissionCreateOrConnectWithoutTeamInput[]
    upsert?: PatternTeamPermissionUpsertWithWhereUniqueWithoutTeamInput | PatternTeamPermissionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: PatternTeamPermissionCreateManyTeamInputEnvelope
    set?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    disconnect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    delete?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    connect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    update?: PatternTeamPermissionUpdateWithWhereUniqueWithoutTeamInput | PatternTeamPermissionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: PatternTeamPermissionUpdateManyWithWhereWithoutTeamInput | PatternTeamPermissionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: PatternTeamPermissionScalarWhereInput | PatternTeamPermissionScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTeamRoleFieldUpdateOperationsInput = {
    set?: $Enums.TeamRole
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserCreateNestedOneWithoutCreatedCasesInput = {
    create?: XOR<UserCreateWithoutCreatedCasesInput, UserUncheckedCreateWithoutCreatedCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCasesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMarkedReadyCasesInput = {
    create?: XOR<UserCreateWithoutMarkedReadyCasesInput, UserUncheckedCreateWithoutMarkedReadyCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarkedReadyCasesInput
    connect?: UserWhereUniqueInput
  }

  export type ArgumentPatternCreateNestedOneWithoutDerivedCasesInput = {
    create?: XOR<ArgumentPatternCreateWithoutDerivedCasesInput, ArgumentPatternUncheckedCreateWithoutDerivedCasesInput>
    connectOrCreate?: ArgumentPatternCreateOrConnectWithoutDerivedCasesInput
    connect?: ArgumentPatternWhereUniqueInput
  }

  export type AssuranceElementCreateNestedManyWithoutCaseInput = {
    create?: XOR<AssuranceElementCreateWithoutCaseInput, AssuranceElementUncheckedCreateWithoutCaseInput> | AssuranceElementCreateWithoutCaseInput[] | AssuranceElementUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCaseInput | AssuranceElementCreateOrConnectWithoutCaseInput[]
    createMany?: AssuranceElementCreateManyCaseInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type CasePermissionCreateNestedManyWithoutCaseInput = {
    create?: XOR<CasePermissionCreateWithoutCaseInput, CasePermissionUncheckedCreateWithoutCaseInput> | CasePermissionCreateWithoutCaseInput[] | CasePermissionUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutCaseInput | CasePermissionCreateOrConnectWithoutCaseInput[]
    createMany?: CasePermissionCreateManyCaseInputEnvelope
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
  }

  export type CaseTeamPermissionCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseTeamPermissionCreateWithoutCaseInput, CaseTeamPermissionUncheckedCreateWithoutCaseInput> | CaseTeamPermissionCreateWithoutCaseInput[] | CaseTeamPermissionUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseTeamPermissionCreateOrConnectWithoutCaseInput | CaseTeamPermissionCreateOrConnectWithoutCaseInput[]
    createMany?: CaseTeamPermissionCreateManyCaseInputEnvelope
    connect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
  }

  export type CaseInviteCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseInviteCreateWithoutCaseInput, CaseInviteUncheckedCreateWithoutCaseInput> | CaseInviteCreateWithoutCaseInput[] | CaseInviteUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseInviteCreateOrConnectWithoutCaseInput | CaseInviteCreateOrConnectWithoutCaseInput[]
    createMany?: CaseInviteCreateManyCaseInputEnvelope
    connect?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutCaseInput = {
    create?: XOR<CommentCreateWithoutCaseInput, CommentUncheckedCreateWithoutCaseInput> | CommentCreateWithoutCaseInput[] | CommentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCaseInput | CommentCreateOrConnectWithoutCaseInput[]
    createMany?: CommentCreateManyCaseInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CaseImageCreateNestedOneWithoutCaseInput = {
    create?: XOR<CaseImageCreateWithoutCaseInput, CaseImageUncheckedCreateWithoutCaseInput>
    connectOrCreate?: CaseImageCreateOrConnectWithoutCaseInput
    connect?: CaseImageWhereUniqueInput
  }

  export type CaseTypeAssignmentCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseTypeAssignmentCreateWithoutCaseInput, CaseTypeAssignmentUncheckedCreateWithoutCaseInput> | CaseTypeAssignmentCreateWithoutCaseInput[] | CaseTypeAssignmentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseTypeAssignmentCreateOrConnectWithoutCaseInput | CaseTypeAssignmentCreateOrConnectWithoutCaseInput[]
    createMany?: CaseTypeAssignmentCreateManyCaseInputEnvelope
    connect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
  }

  export type ReleaseCreateNestedManyWithoutSourceCaseInput = {
    create?: XOR<ReleaseCreateWithoutSourceCaseInput, ReleaseUncheckedCreateWithoutSourceCaseInput> | ReleaseCreateWithoutSourceCaseInput[] | ReleaseUncheckedCreateWithoutSourceCaseInput[]
    connectOrCreate?: ReleaseCreateOrConnectWithoutSourceCaseInput | ReleaseCreateOrConnectWithoutSourceCaseInput[]
    createMany?: ReleaseCreateManySourceCaseInputEnvelope
    connect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
  }

  export type ReleaseCreateNestedManyWithoutPublishedCaseInput = {
    create?: XOR<ReleaseCreateWithoutPublishedCaseInput, ReleaseUncheckedCreateWithoutPublishedCaseInput> | ReleaseCreateWithoutPublishedCaseInput[] | ReleaseUncheckedCreateWithoutPublishedCaseInput[]
    connectOrCreate?: ReleaseCreateOrConnectWithoutPublishedCaseInput | ReleaseCreateOrConnectWithoutPublishedCaseInput[]
    createMany?: ReleaseCreateManyPublishedCaseInputEnvelope
    connect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
  }

  export type PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput = {
    create?: XOR<PublishedAssuranceCaseCreateWithoutAssuranceCaseInput, PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput> | PublishedAssuranceCaseCreateWithoutAssuranceCaseInput[] | PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput[]
    connectOrCreate?: PublishedAssuranceCaseCreateOrConnectWithoutAssuranceCaseInput | PublishedAssuranceCaseCreateOrConnectWithoutAssuranceCaseInput[]
    createMany?: PublishedAssuranceCaseCreateManyAssuranceCaseInputEnvelope
    connect?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
  }

  export type AssuranceElementCreateNestedManyWithoutModuleReferenceInput = {
    create?: XOR<AssuranceElementCreateWithoutModuleReferenceInput, AssuranceElementUncheckedCreateWithoutModuleReferenceInput> | AssuranceElementCreateWithoutModuleReferenceInput[] | AssuranceElementUncheckedCreateWithoutModuleReferenceInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutModuleReferenceInput | AssuranceElementCreateOrConnectWithoutModuleReferenceInput[]
    createMany?: AssuranceElementCreateManyModuleReferenceInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type AssuranceElementUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<AssuranceElementCreateWithoutCaseInput, AssuranceElementUncheckedCreateWithoutCaseInput> | AssuranceElementCreateWithoutCaseInput[] | AssuranceElementUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCaseInput | AssuranceElementCreateOrConnectWithoutCaseInput[]
    createMany?: AssuranceElementCreateManyCaseInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type CasePermissionUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<CasePermissionCreateWithoutCaseInput, CasePermissionUncheckedCreateWithoutCaseInput> | CasePermissionCreateWithoutCaseInput[] | CasePermissionUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutCaseInput | CasePermissionCreateOrConnectWithoutCaseInput[]
    createMany?: CasePermissionCreateManyCaseInputEnvelope
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
  }

  export type CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseTeamPermissionCreateWithoutCaseInput, CaseTeamPermissionUncheckedCreateWithoutCaseInput> | CaseTeamPermissionCreateWithoutCaseInput[] | CaseTeamPermissionUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseTeamPermissionCreateOrConnectWithoutCaseInput | CaseTeamPermissionCreateOrConnectWithoutCaseInput[]
    createMany?: CaseTeamPermissionCreateManyCaseInputEnvelope
    connect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
  }

  export type CaseInviteUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseInviteCreateWithoutCaseInput, CaseInviteUncheckedCreateWithoutCaseInput> | CaseInviteCreateWithoutCaseInput[] | CaseInviteUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseInviteCreateOrConnectWithoutCaseInput | CaseInviteCreateOrConnectWithoutCaseInput[]
    createMany?: CaseInviteCreateManyCaseInputEnvelope
    connect?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<CommentCreateWithoutCaseInput, CommentUncheckedCreateWithoutCaseInput> | CommentCreateWithoutCaseInput[] | CommentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCaseInput | CommentCreateOrConnectWithoutCaseInput[]
    createMany?: CommentCreateManyCaseInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CaseImageUncheckedCreateNestedOneWithoutCaseInput = {
    create?: XOR<CaseImageCreateWithoutCaseInput, CaseImageUncheckedCreateWithoutCaseInput>
    connectOrCreate?: CaseImageCreateOrConnectWithoutCaseInput
    connect?: CaseImageWhereUniqueInput
  }

  export type CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput = {
    create?: XOR<CaseTypeAssignmentCreateWithoutCaseInput, CaseTypeAssignmentUncheckedCreateWithoutCaseInput> | CaseTypeAssignmentCreateWithoutCaseInput[] | CaseTypeAssignmentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseTypeAssignmentCreateOrConnectWithoutCaseInput | CaseTypeAssignmentCreateOrConnectWithoutCaseInput[]
    createMany?: CaseTypeAssignmentCreateManyCaseInputEnvelope
    connect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
  }

  export type ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput = {
    create?: XOR<ReleaseCreateWithoutSourceCaseInput, ReleaseUncheckedCreateWithoutSourceCaseInput> | ReleaseCreateWithoutSourceCaseInput[] | ReleaseUncheckedCreateWithoutSourceCaseInput[]
    connectOrCreate?: ReleaseCreateOrConnectWithoutSourceCaseInput | ReleaseCreateOrConnectWithoutSourceCaseInput[]
    createMany?: ReleaseCreateManySourceCaseInputEnvelope
    connect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
  }

  export type ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput = {
    create?: XOR<ReleaseCreateWithoutPublishedCaseInput, ReleaseUncheckedCreateWithoutPublishedCaseInput> | ReleaseCreateWithoutPublishedCaseInput[] | ReleaseUncheckedCreateWithoutPublishedCaseInput[]
    connectOrCreate?: ReleaseCreateOrConnectWithoutPublishedCaseInput | ReleaseCreateOrConnectWithoutPublishedCaseInput[]
    createMany?: ReleaseCreateManyPublishedCaseInputEnvelope
    connect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
  }

  export type PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput = {
    create?: XOR<PublishedAssuranceCaseCreateWithoutAssuranceCaseInput, PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput> | PublishedAssuranceCaseCreateWithoutAssuranceCaseInput[] | PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput[]
    connectOrCreate?: PublishedAssuranceCaseCreateOrConnectWithoutAssuranceCaseInput | PublishedAssuranceCaseCreateOrConnectWithoutAssuranceCaseInput[]
    createMany?: PublishedAssuranceCaseCreateManyAssuranceCaseInputEnvelope
    connect?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
  }

  export type AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput = {
    create?: XOR<AssuranceElementCreateWithoutModuleReferenceInput, AssuranceElementUncheckedCreateWithoutModuleReferenceInput> | AssuranceElementCreateWithoutModuleReferenceInput[] | AssuranceElementUncheckedCreateWithoutModuleReferenceInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutModuleReferenceInput | AssuranceElementCreateOrConnectWithoutModuleReferenceInput[]
    createMany?: AssuranceElementCreateManyModuleReferenceInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type EnumPublishStatusFieldUpdateOperationsInput = {
    set?: $Enums.PublishStatus
  }

  export type UserUpdateOneRequiredWithoutCreatedCasesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCasesInput, UserUncheckedCreateWithoutCreatedCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCasesInput
    upsert?: UserUpsertWithoutCreatedCasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCasesInput, UserUpdateWithoutCreatedCasesInput>, UserUncheckedUpdateWithoutCreatedCasesInput>
  }

  export type UserUpdateOneWithoutMarkedReadyCasesNestedInput = {
    create?: XOR<UserCreateWithoutMarkedReadyCasesInput, UserUncheckedCreateWithoutMarkedReadyCasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMarkedReadyCasesInput
    upsert?: UserUpsertWithoutMarkedReadyCasesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMarkedReadyCasesInput, UserUpdateWithoutMarkedReadyCasesInput>, UserUncheckedUpdateWithoutMarkedReadyCasesInput>
  }

  export type ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput = {
    create?: XOR<ArgumentPatternCreateWithoutDerivedCasesInput, ArgumentPatternUncheckedCreateWithoutDerivedCasesInput>
    connectOrCreate?: ArgumentPatternCreateOrConnectWithoutDerivedCasesInput
    upsert?: ArgumentPatternUpsertWithoutDerivedCasesInput
    disconnect?: ArgumentPatternWhereInput | boolean
    delete?: ArgumentPatternWhereInput | boolean
    connect?: ArgumentPatternWhereUniqueInput
    update?: XOR<XOR<ArgumentPatternUpdateToOneWithWhereWithoutDerivedCasesInput, ArgumentPatternUpdateWithoutDerivedCasesInput>, ArgumentPatternUncheckedUpdateWithoutDerivedCasesInput>
  }

  export type AssuranceElementUpdateManyWithoutCaseNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutCaseInput, AssuranceElementUncheckedCreateWithoutCaseInput> | AssuranceElementCreateWithoutCaseInput[] | AssuranceElementUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCaseInput | AssuranceElementCreateOrConnectWithoutCaseInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutCaseInput | AssuranceElementUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: AssuranceElementCreateManyCaseInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutCaseInput | AssuranceElementUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutCaseInput | AssuranceElementUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type CasePermissionUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CasePermissionCreateWithoutCaseInput, CasePermissionUncheckedCreateWithoutCaseInput> | CasePermissionCreateWithoutCaseInput[] | CasePermissionUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutCaseInput | CasePermissionCreateOrConnectWithoutCaseInput[]
    upsert?: CasePermissionUpsertWithWhereUniqueWithoutCaseInput | CasePermissionUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CasePermissionCreateManyCaseInputEnvelope
    set?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    disconnect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    delete?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    update?: CasePermissionUpdateWithWhereUniqueWithoutCaseInput | CasePermissionUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CasePermissionUpdateManyWithWhereWithoutCaseInput | CasePermissionUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CasePermissionScalarWhereInput | CasePermissionScalarWhereInput[]
  }

  export type CaseTeamPermissionUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseTeamPermissionCreateWithoutCaseInput, CaseTeamPermissionUncheckedCreateWithoutCaseInput> | CaseTeamPermissionCreateWithoutCaseInput[] | CaseTeamPermissionUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseTeamPermissionCreateOrConnectWithoutCaseInput | CaseTeamPermissionCreateOrConnectWithoutCaseInput[]
    upsert?: CaseTeamPermissionUpsertWithWhereUniqueWithoutCaseInput | CaseTeamPermissionUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseTeamPermissionCreateManyCaseInputEnvelope
    set?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    disconnect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    delete?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    connect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    update?: CaseTeamPermissionUpdateWithWhereUniqueWithoutCaseInput | CaseTeamPermissionUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseTeamPermissionUpdateManyWithWhereWithoutCaseInput | CaseTeamPermissionUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseTeamPermissionScalarWhereInput | CaseTeamPermissionScalarWhereInput[]
  }

  export type CaseInviteUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseInviteCreateWithoutCaseInput, CaseInviteUncheckedCreateWithoutCaseInput> | CaseInviteCreateWithoutCaseInput[] | CaseInviteUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseInviteCreateOrConnectWithoutCaseInput | CaseInviteCreateOrConnectWithoutCaseInput[]
    upsert?: CaseInviteUpsertWithWhereUniqueWithoutCaseInput | CaseInviteUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseInviteCreateManyCaseInputEnvelope
    set?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
    disconnect?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
    delete?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
    connect?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
    update?: CaseInviteUpdateWithWhereUniqueWithoutCaseInput | CaseInviteUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseInviteUpdateManyWithWhereWithoutCaseInput | CaseInviteUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseInviteScalarWhereInput | CaseInviteScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CommentCreateWithoutCaseInput, CommentUncheckedCreateWithoutCaseInput> | CommentCreateWithoutCaseInput[] | CommentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCaseInput | CommentCreateOrConnectWithoutCaseInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCaseInput | CommentUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CommentCreateManyCaseInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCaseInput | CommentUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCaseInput | CommentUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CaseImageUpdateOneWithoutCaseNestedInput = {
    create?: XOR<CaseImageCreateWithoutCaseInput, CaseImageUncheckedCreateWithoutCaseInput>
    connectOrCreate?: CaseImageCreateOrConnectWithoutCaseInput
    upsert?: CaseImageUpsertWithoutCaseInput
    disconnect?: CaseImageWhereInput | boolean
    delete?: CaseImageWhereInput | boolean
    connect?: CaseImageWhereUniqueInput
    update?: XOR<XOR<CaseImageUpdateToOneWithWhereWithoutCaseInput, CaseImageUpdateWithoutCaseInput>, CaseImageUncheckedUpdateWithoutCaseInput>
  }

  export type CaseTypeAssignmentUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseTypeAssignmentCreateWithoutCaseInput, CaseTypeAssignmentUncheckedCreateWithoutCaseInput> | CaseTypeAssignmentCreateWithoutCaseInput[] | CaseTypeAssignmentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseTypeAssignmentCreateOrConnectWithoutCaseInput | CaseTypeAssignmentCreateOrConnectWithoutCaseInput[]
    upsert?: CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseInput | CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseTypeAssignmentCreateManyCaseInputEnvelope
    set?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    disconnect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    delete?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    connect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    update?: CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseInput | CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseTypeAssignmentUpdateManyWithWhereWithoutCaseInput | CaseTypeAssignmentUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseTypeAssignmentScalarWhereInput | CaseTypeAssignmentScalarWhereInput[]
  }

  export type ReleaseUpdateManyWithoutSourceCaseNestedInput = {
    create?: XOR<ReleaseCreateWithoutSourceCaseInput, ReleaseUncheckedCreateWithoutSourceCaseInput> | ReleaseCreateWithoutSourceCaseInput[] | ReleaseUncheckedCreateWithoutSourceCaseInput[]
    connectOrCreate?: ReleaseCreateOrConnectWithoutSourceCaseInput | ReleaseCreateOrConnectWithoutSourceCaseInput[]
    upsert?: ReleaseUpsertWithWhereUniqueWithoutSourceCaseInput | ReleaseUpsertWithWhereUniqueWithoutSourceCaseInput[]
    createMany?: ReleaseCreateManySourceCaseInputEnvelope
    set?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    disconnect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    delete?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    connect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    update?: ReleaseUpdateWithWhereUniqueWithoutSourceCaseInput | ReleaseUpdateWithWhereUniqueWithoutSourceCaseInput[]
    updateMany?: ReleaseUpdateManyWithWhereWithoutSourceCaseInput | ReleaseUpdateManyWithWhereWithoutSourceCaseInput[]
    deleteMany?: ReleaseScalarWhereInput | ReleaseScalarWhereInput[]
  }

  export type ReleaseUpdateManyWithoutPublishedCaseNestedInput = {
    create?: XOR<ReleaseCreateWithoutPublishedCaseInput, ReleaseUncheckedCreateWithoutPublishedCaseInput> | ReleaseCreateWithoutPublishedCaseInput[] | ReleaseUncheckedCreateWithoutPublishedCaseInput[]
    connectOrCreate?: ReleaseCreateOrConnectWithoutPublishedCaseInput | ReleaseCreateOrConnectWithoutPublishedCaseInput[]
    upsert?: ReleaseUpsertWithWhereUniqueWithoutPublishedCaseInput | ReleaseUpsertWithWhereUniqueWithoutPublishedCaseInput[]
    createMany?: ReleaseCreateManyPublishedCaseInputEnvelope
    set?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    disconnect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    delete?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    connect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    update?: ReleaseUpdateWithWhereUniqueWithoutPublishedCaseInput | ReleaseUpdateWithWhereUniqueWithoutPublishedCaseInput[]
    updateMany?: ReleaseUpdateManyWithWhereWithoutPublishedCaseInput | ReleaseUpdateManyWithWhereWithoutPublishedCaseInput[]
    deleteMany?: ReleaseScalarWhereInput | ReleaseScalarWhereInput[]
  }

  export type PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput = {
    create?: XOR<PublishedAssuranceCaseCreateWithoutAssuranceCaseInput, PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput> | PublishedAssuranceCaseCreateWithoutAssuranceCaseInput[] | PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput[]
    connectOrCreate?: PublishedAssuranceCaseCreateOrConnectWithoutAssuranceCaseInput | PublishedAssuranceCaseCreateOrConnectWithoutAssuranceCaseInput[]
    upsert?: PublishedAssuranceCaseUpsertWithWhereUniqueWithoutAssuranceCaseInput | PublishedAssuranceCaseUpsertWithWhereUniqueWithoutAssuranceCaseInput[]
    createMany?: PublishedAssuranceCaseCreateManyAssuranceCaseInputEnvelope
    set?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
    disconnect?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
    delete?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
    connect?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
    update?: PublishedAssuranceCaseUpdateWithWhereUniqueWithoutAssuranceCaseInput | PublishedAssuranceCaseUpdateWithWhereUniqueWithoutAssuranceCaseInput[]
    updateMany?: PublishedAssuranceCaseUpdateManyWithWhereWithoutAssuranceCaseInput | PublishedAssuranceCaseUpdateManyWithWhereWithoutAssuranceCaseInput[]
    deleteMany?: PublishedAssuranceCaseScalarWhereInput | PublishedAssuranceCaseScalarWhereInput[]
  }

  export type AssuranceElementUpdateManyWithoutModuleReferenceNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutModuleReferenceInput, AssuranceElementUncheckedCreateWithoutModuleReferenceInput> | AssuranceElementCreateWithoutModuleReferenceInput[] | AssuranceElementUncheckedCreateWithoutModuleReferenceInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutModuleReferenceInput | AssuranceElementCreateOrConnectWithoutModuleReferenceInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutModuleReferenceInput | AssuranceElementUpsertWithWhereUniqueWithoutModuleReferenceInput[]
    createMany?: AssuranceElementCreateManyModuleReferenceInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutModuleReferenceInput | AssuranceElementUpdateWithWhereUniqueWithoutModuleReferenceInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutModuleReferenceInput | AssuranceElementUpdateManyWithWhereWithoutModuleReferenceInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutCaseInput, AssuranceElementUncheckedCreateWithoutCaseInput> | AssuranceElementCreateWithoutCaseInput[] | AssuranceElementUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCaseInput | AssuranceElementCreateOrConnectWithoutCaseInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutCaseInput | AssuranceElementUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: AssuranceElementCreateManyCaseInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutCaseInput | AssuranceElementUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutCaseInput | AssuranceElementUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type CasePermissionUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CasePermissionCreateWithoutCaseInput, CasePermissionUncheckedCreateWithoutCaseInput> | CasePermissionCreateWithoutCaseInput[] | CasePermissionUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CasePermissionCreateOrConnectWithoutCaseInput | CasePermissionCreateOrConnectWithoutCaseInput[]
    upsert?: CasePermissionUpsertWithWhereUniqueWithoutCaseInput | CasePermissionUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CasePermissionCreateManyCaseInputEnvelope
    set?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    disconnect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    delete?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    connect?: CasePermissionWhereUniqueInput | CasePermissionWhereUniqueInput[]
    update?: CasePermissionUpdateWithWhereUniqueWithoutCaseInput | CasePermissionUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CasePermissionUpdateManyWithWhereWithoutCaseInput | CasePermissionUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CasePermissionScalarWhereInput | CasePermissionScalarWhereInput[]
  }

  export type CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseTeamPermissionCreateWithoutCaseInput, CaseTeamPermissionUncheckedCreateWithoutCaseInput> | CaseTeamPermissionCreateWithoutCaseInput[] | CaseTeamPermissionUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseTeamPermissionCreateOrConnectWithoutCaseInput | CaseTeamPermissionCreateOrConnectWithoutCaseInput[]
    upsert?: CaseTeamPermissionUpsertWithWhereUniqueWithoutCaseInput | CaseTeamPermissionUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseTeamPermissionCreateManyCaseInputEnvelope
    set?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    disconnect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    delete?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    connect?: CaseTeamPermissionWhereUniqueInput | CaseTeamPermissionWhereUniqueInput[]
    update?: CaseTeamPermissionUpdateWithWhereUniqueWithoutCaseInput | CaseTeamPermissionUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseTeamPermissionUpdateManyWithWhereWithoutCaseInput | CaseTeamPermissionUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseTeamPermissionScalarWhereInput | CaseTeamPermissionScalarWhereInput[]
  }

  export type CaseInviteUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseInviteCreateWithoutCaseInput, CaseInviteUncheckedCreateWithoutCaseInput> | CaseInviteCreateWithoutCaseInput[] | CaseInviteUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseInviteCreateOrConnectWithoutCaseInput | CaseInviteCreateOrConnectWithoutCaseInput[]
    upsert?: CaseInviteUpsertWithWhereUniqueWithoutCaseInput | CaseInviteUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseInviteCreateManyCaseInputEnvelope
    set?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
    disconnect?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
    delete?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
    connect?: CaseInviteWhereUniqueInput | CaseInviteWhereUniqueInput[]
    update?: CaseInviteUpdateWithWhereUniqueWithoutCaseInput | CaseInviteUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseInviteUpdateManyWithWhereWithoutCaseInput | CaseInviteUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseInviteScalarWhereInput | CaseInviteScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CommentCreateWithoutCaseInput, CommentUncheckedCreateWithoutCaseInput> | CommentCreateWithoutCaseInput[] | CommentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCaseInput | CommentCreateOrConnectWithoutCaseInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCaseInput | CommentUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CommentCreateManyCaseInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCaseInput | CommentUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCaseInput | CommentUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CaseImageUncheckedUpdateOneWithoutCaseNestedInput = {
    create?: XOR<CaseImageCreateWithoutCaseInput, CaseImageUncheckedCreateWithoutCaseInput>
    connectOrCreate?: CaseImageCreateOrConnectWithoutCaseInput
    upsert?: CaseImageUpsertWithoutCaseInput
    disconnect?: CaseImageWhereInput | boolean
    delete?: CaseImageWhereInput | boolean
    connect?: CaseImageWhereUniqueInput
    update?: XOR<XOR<CaseImageUpdateToOneWithWhereWithoutCaseInput, CaseImageUpdateWithoutCaseInput>, CaseImageUncheckedUpdateWithoutCaseInput>
  }

  export type CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput = {
    create?: XOR<CaseTypeAssignmentCreateWithoutCaseInput, CaseTypeAssignmentUncheckedCreateWithoutCaseInput> | CaseTypeAssignmentCreateWithoutCaseInput[] | CaseTypeAssignmentUncheckedCreateWithoutCaseInput[]
    connectOrCreate?: CaseTypeAssignmentCreateOrConnectWithoutCaseInput | CaseTypeAssignmentCreateOrConnectWithoutCaseInput[]
    upsert?: CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseInput | CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseInput[]
    createMany?: CaseTypeAssignmentCreateManyCaseInputEnvelope
    set?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    disconnect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    delete?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    connect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    update?: CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseInput | CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseInput[]
    updateMany?: CaseTypeAssignmentUpdateManyWithWhereWithoutCaseInput | CaseTypeAssignmentUpdateManyWithWhereWithoutCaseInput[]
    deleteMany?: CaseTypeAssignmentScalarWhereInput | CaseTypeAssignmentScalarWhereInput[]
  }

  export type ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput = {
    create?: XOR<ReleaseCreateWithoutSourceCaseInput, ReleaseUncheckedCreateWithoutSourceCaseInput> | ReleaseCreateWithoutSourceCaseInput[] | ReleaseUncheckedCreateWithoutSourceCaseInput[]
    connectOrCreate?: ReleaseCreateOrConnectWithoutSourceCaseInput | ReleaseCreateOrConnectWithoutSourceCaseInput[]
    upsert?: ReleaseUpsertWithWhereUniqueWithoutSourceCaseInput | ReleaseUpsertWithWhereUniqueWithoutSourceCaseInput[]
    createMany?: ReleaseCreateManySourceCaseInputEnvelope
    set?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    disconnect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    delete?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    connect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    update?: ReleaseUpdateWithWhereUniqueWithoutSourceCaseInput | ReleaseUpdateWithWhereUniqueWithoutSourceCaseInput[]
    updateMany?: ReleaseUpdateManyWithWhereWithoutSourceCaseInput | ReleaseUpdateManyWithWhereWithoutSourceCaseInput[]
    deleteMany?: ReleaseScalarWhereInput | ReleaseScalarWhereInput[]
  }

  export type ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput = {
    create?: XOR<ReleaseCreateWithoutPublishedCaseInput, ReleaseUncheckedCreateWithoutPublishedCaseInput> | ReleaseCreateWithoutPublishedCaseInput[] | ReleaseUncheckedCreateWithoutPublishedCaseInput[]
    connectOrCreate?: ReleaseCreateOrConnectWithoutPublishedCaseInput | ReleaseCreateOrConnectWithoutPublishedCaseInput[]
    upsert?: ReleaseUpsertWithWhereUniqueWithoutPublishedCaseInput | ReleaseUpsertWithWhereUniqueWithoutPublishedCaseInput[]
    createMany?: ReleaseCreateManyPublishedCaseInputEnvelope
    set?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    disconnect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    delete?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    connect?: ReleaseWhereUniqueInput | ReleaseWhereUniqueInput[]
    update?: ReleaseUpdateWithWhereUniqueWithoutPublishedCaseInput | ReleaseUpdateWithWhereUniqueWithoutPublishedCaseInput[]
    updateMany?: ReleaseUpdateManyWithWhereWithoutPublishedCaseInput | ReleaseUpdateManyWithWhereWithoutPublishedCaseInput[]
    deleteMany?: ReleaseScalarWhereInput | ReleaseScalarWhereInput[]
  }

  export type PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput = {
    create?: XOR<PublishedAssuranceCaseCreateWithoutAssuranceCaseInput, PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput> | PublishedAssuranceCaseCreateWithoutAssuranceCaseInput[] | PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput[]
    connectOrCreate?: PublishedAssuranceCaseCreateOrConnectWithoutAssuranceCaseInput | PublishedAssuranceCaseCreateOrConnectWithoutAssuranceCaseInput[]
    upsert?: PublishedAssuranceCaseUpsertWithWhereUniqueWithoutAssuranceCaseInput | PublishedAssuranceCaseUpsertWithWhereUniqueWithoutAssuranceCaseInput[]
    createMany?: PublishedAssuranceCaseCreateManyAssuranceCaseInputEnvelope
    set?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
    disconnect?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
    delete?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
    connect?: PublishedAssuranceCaseWhereUniqueInput | PublishedAssuranceCaseWhereUniqueInput[]
    update?: PublishedAssuranceCaseUpdateWithWhereUniqueWithoutAssuranceCaseInput | PublishedAssuranceCaseUpdateWithWhereUniqueWithoutAssuranceCaseInput[]
    updateMany?: PublishedAssuranceCaseUpdateManyWithWhereWithoutAssuranceCaseInput | PublishedAssuranceCaseUpdateManyWithWhereWithoutAssuranceCaseInput[]
    deleteMany?: PublishedAssuranceCaseScalarWhereInput | PublishedAssuranceCaseScalarWhereInput[]
  }

  export type AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutModuleReferenceInput, AssuranceElementUncheckedCreateWithoutModuleReferenceInput> | AssuranceElementCreateWithoutModuleReferenceInput[] | AssuranceElementUncheckedCreateWithoutModuleReferenceInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutModuleReferenceInput | AssuranceElementCreateOrConnectWithoutModuleReferenceInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutModuleReferenceInput | AssuranceElementUpsertWithWhereUniqueWithoutModuleReferenceInput[]
    createMany?: AssuranceElementCreateManyModuleReferenceInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutModuleReferenceInput | AssuranceElementUpdateWithWhereUniqueWithoutModuleReferenceInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutModuleReferenceInput | AssuranceElementUpdateManyWithWhereWithoutModuleReferenceInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type AssuranceCaseCreateNestedOneWithoutUserPermissionsInput = {
    create?: XOR<AssuranceCaseCreateWithoutUserPermissionsInput, AssuranceCaseUncheckedCreateWithoutUserPermissionsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutUserPermissionsInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCasePermissionsInput = {
    create?: XOR<UserCreateWithoutCasePermissionsInput, UserUncheckedCreateWithoutCasePermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCasePermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGrantedPermissionsInput = {
    create?: XOR<UserCreateWithoutGrantedPermissionsInput, UserUncheckedCreateWithoutGrantedPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGrantedPermissionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPermissionLevelFieldUpdateOperationsInput = {
    set?: $Enums.PermissionLevel
  }

  export type AssuranceCaseUpdateOneRequiredWithoutUserPermissionsNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutUserPermissionsInput, AssuranceCaseUncheckedCreateWithoutUserPermissionsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutUserPermissionsInput
    upsert?: AssuranceCaseUpsertWithoutUserPermissionsInput
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutUserPermissionsInput, AssuranceCaseUpdateWithoutUserPermissionsInput>, AssuranceCaseUncheckedUpdateWithoutUserPermissionsInput>
  }

  export type UserUpdateOneRequiredWithoutCasePermissionsNestedInput = {
    create?: XOR<UserCreateWithoutCasePermissionsInput, UserUncheckedCreateWithoutCasePermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCasePermissionsInput
    upsert?: UserUpsertWithoutCasePermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCasePermissionsInput, UserUpdateWithoutCasePermissionsInput>, UserUncheckedUpdateWithoutCasePermissionsInput>
  }

  export type UserUpdateOneRequiredWithoutGrantedPermissionsNestedInput = {
    create?: XOR<UserCreateWithoutGrantedPermissionsInput, UserUncheckedCreateWithoutGrantedPermissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGrantedPermissionsInput
    upsert?: UserUpsertWithoutGrantedPermissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGrantedPermissionsInput, UserUpdateWithoutGrantedPermissionsInput>, UserUncheckedUpdateWithoutGrantedPermissionsInput>
  }

  export type AssuranceCaseCreateNestedOneWithoutTeamPermissionsInput = {
    create?: XOR<AssuranceCaseCreateWithoutTeamPermissionsInput, AssuranceCaseUncheckedCreateWithoutTeamPermissionsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutTeamPermissionsInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutCasePermissionsInput = {
    create?: XOR<TeamCreateWithoutCasePermissionsInput, TeamUncheckedCreateWithoutCasePermissionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCasePermissionsInput
    connect?: TeamWhereUniqueInput
  }

  export type AssuranceCaseUpdateOneRequiredWithoutTeamPermissionsNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutTeamPermissionsInput, AssuranceCaseUncheckedCreateWithoutTeamPermissionsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutTeamPermissionsInput
    upsert?: AssuranceCaseUpsertWithoutTeamPermissionsInput
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutTeamPermissionsInput, AssuranceCaseUpdateWithoutTeamPermissionsInput>, AssuranceCaseUncheckedUpdateWithoutTeamPermissionsInput>
  }

  export type TeamUpdateOneRequiredWithoutCasePermissionsNestedInput = {
    create?: XOR<TeamCreateWithoutCasePermissionsInput, TeamUncheckedCreateWithoutCasePermissionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCasePermissionsInput
    upsert?: TeamUpsertWithoutCasePermissionsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutCasePermissionsInput, TeamUpdateWithoutCasePermissionsInput>, TeamUncheckedUpdateWithoutCasePermissionsInput>
  }

  export type AssuranceCaseCreateNestedOneWithoutInvitesInput = {
    create?: XOR<AssuranceCaseCreateWithoutInvitesInput, AssuranceCaseUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutInvitesInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type AssuranceCaseUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutInvitesInput, AssuranceCaseUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutInvitesInput
    upsert?: AssuranceCaseUpsertWithoutInvitesInput
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutInvitesInput, AssuranceCaseUpdateWithoutInvitesInput>, AssuranceCaseUncheckedUpdateWithoutInvitesInput>
  }

  export type AssuranceCaseCreateNestedOneWithoutElementsInput = {
    create?: XOR<AssuranceCaseCreateWithoutElementsInput, AssuranceCaseUncheckedCreateWithoutElementsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutElementsInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedElementsInput = {
    create?: XOR<UserCreateWithoutCreatedElementsInput, UserUncheckedCreateWithoutCreatedElementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedElementsInput
    connect?: UserWhereUniqueInput
  }

  export type AssuranceElementCreateNestedOneWithoutChildrenInput = {
    create?: XOR<AssuranceElementCreateWithoutChildrenInput, AssuranceElementUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutChildrenInput
    connect?: AssuranceElementWhereUniqueInput
  }

  export type AssuranceElementCreateNestedManyWithoutParentInput = {
    create?: XOR<AssuranceElementCreateWithoutParentInput, AssuranceElementUncheckedCreateWithoutParentInput> | AssuranceElementCreateWithoutParentInput[] | AssuranceElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutParentInput | AssuranceElementCreateOrConnectWithoutParentInput[]
    createMany?: AssuranceElementCreateManyParentInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type AssuranceElementCreateNestedOneWithoutDefeatedByInput = {
    create?: XOR<AssuranceElementCreateWithoutDefeatedByInput, AssuranceElementUncheckedCreateWithoutDefeatedByInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutDefeatedByInput
    connect?: AssuranceElementWhereUniqueInput
  }

  export type AssuranceElementCreateNestedManyWithoutDefeatsElementInput = {
    create?: XOR<AssuranceElementCreateWithoutDefeatsElementInput, AssuranceElementUncheckedCreateWithoutDefeatsElementInput> | AssuranceElementCreateWithoutDefeatsElementInput[] | AssuranceElementUncheckedCreateWithoutDefeatsElementInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutDefeatsElementInput | AssuranceElementCreateOrConnectWithoutDefeatsElementInput[]
    createMany?: AssuranceElementCreateManyDefeatsElementInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type AssuranceCaseCreateNestedOneWithoutEmbeddedInInput = {
    create?: XOR<AssuranceCaseCreateWithoutEmbeddedInInput, AssuranceCaseUncheckedCreateWithoutEmbeddedInInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutEmbeddedInInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type EvidenceLinkCreateNestedManyWithoutEvidenceInput = {
    create?: XOR<EvidenceLinkCreateWithoutEvidenceInput, EvidenceLinkUncheckedCreateWithoutEvidenceInput> | EvidenceLinkCreateWithoutEvidenceInput[] | EvidenceLinkUncheckedCreateWithoutEvidenceInput[]
    connectOrCreate?: EvidenceLinkCreateOrConnectWithoutEvidenceInput | EvidenceLinkCreateOrConnectWithoutEvidenceInput[]
    createMany?: EvidenceLinkCreateManyEvidenceInputEnvelope
    connect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
  }

  export type EvidenceLinkCreateNestedManyWithoutClaimInput = {
    create?: XOR<EvidenceLinkCreateWithoutClaimInput, EvidenceLinkUncheckedCreateWithoutClaimInput> | EvidenceLinkCreateWithoutClaimInput[] | EvidenceLinkUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EvidenceLinkCreateOrConnectWithoutClaimInput | EvidenceLinkCreateOrConnectWithoutClaimInput[]
    createMany?: EvidenceLinkCreateManyClaimInputEnvelope
    connect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutElementInput = {
    create?: XOR<CommentCreateWithoutElementInput, CommentUncheckedCreateWithoutElementInput> | CommentCreateWithoutElementInput[] | CommentUncheckedCreateWithoutElementInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutElementInput | CommentCreateOrConnectWithoutElementInput[]
    createMany?: CommentCreateManyElementInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReleaseCommentCreateNestedManyWithoutElementInput = {
    create?: XOR<ReleaseCommentCreateWithoutElementInput, ReleaseCommentUncheckedCreateWithoutElementInput> | ReleaseCommentCreateWithoutElementInput[] | ReleaseCommentUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutElementInput | ReleaseCommentCreateOrConnectWithoutElementInput[]
    createMany?: ReleaseCommentCreateManyElementInputEnvelope
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
  }

  export type AssuranceElementUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<AssuranceElementCreateWithoutParentInput, AssuranceElementUncheckedCreateWithoutParentInput> | AssuranceElementCreateWithoutParentInput[] | AssuranceElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutParentInput | AssuranceElementCreateOrConnectWithoutParentInput[]
    createMany?: AssuranceElementCreateManyParentInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput = {
    create?: XOR<AssuranceElementCreateWithoutDefeatsElementInput, AssuranceElementUncheckedCreateWithoutDefeatsElementInput> | AssuranceElementCreateWithoutDefeatsElementInput[] | AssuranceElementUncheckedCreateWithoutDefeatsElementInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutDefeatsElementInput | AssuranceElementCreateOrConnectWithoutDefeatsElementInput[]
    createMany?: AssuranceElementCreateManyDefeatsElementInputEnvelope
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
  }

  export type EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput = {
    create?: XOR<EvidenceLinkCreateWithoutEvidenceInput, EvidenceLinkUncheckedCreateWithoutEvidenceInput> | EvidenceLinkCreateWithoutEvidenceInput[] | EvidenceLinkUncheckedCreateWithoutEvidenceInput[]
    connectOrCreate?: EvidenceLinkCreateOrConnectWithoutEvidenceInput | EvidenceLinkCreateOrConnectWithoutEvidenceInput[]
    createMany?: EvidenceLinkCreateManyEvidenceInputEnvelope
    connect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
  }

  export type EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput = {
    create?: XOR<EvidenceLinkCreateWithoutClaimInput, EvidenceLinkUncheckedCreateWithoutClaimInput> | EvidenceLinkCreateWithoutClaimInput[] | EvidenceLinkUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EvidenceLinkCreateOrConnectWithoutClaimInput | EvidenceLinkCreateOrConnectWithoutClaimInput[]
    createMany?: EvidenceLinkCreateManyClaimInputEnvelope
    connect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<CommentCreateWithoutElementInput, CommentUncheckedCreateWithoutElementInput> | CommentCreateWithoutElementInput[] | CommentUncheckedCreateWithoutElementInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutElementInput | CommentCreateOrConnectWithoutElementInput[]
    createMany?: CommentCreateManyElementInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReleaseCommentUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<ReleaseCommentCreateWithoutElementInput, ReleaseCommentUncheckedCreateWithoutElementInput> | ReleaseCommentCreateWithoutElementInput[] | ReleaseCommentUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutElementInput | ReleaseCommentCreateOrConnectWithoutElementInput[]
    createMany?: ReleaseCommentCreateManyElementInputEnvelope
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
  }

  export type EnumElementTypeFieldUpdateOperationsInput = {
    set?: $Enums.ElementType
  }

  export type NullableEnumElementRoleFieldUpdateOperationsInput = {
    set?: $Enums.ElementRole | null
  }

  export type NullableEnumModuleEmbedTypeFieldUpdateOperationsInput = {
    set?: $Enums.ModuleEmbedType | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutElementsInput, AssuranceCaseUncheckedCreateWithoutElementsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutElementsInput
    upsert?: AssuranceCaseUpsertWithoutElementsInput
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutElementsInput, AssuranceCaseUpdateWithoutElementsInput>, AssuranceCaseUncheckedUpdateWithoutElementsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedElementsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedElementsInput, UserUncheckedCreateWithoutCreatedElementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedElementsInput
    upsert?: UserUpsertWithoutCreatedElementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedElementsInput, UserUpdateWithoutCreatedElementsInput>, UserUncheckedUpdateWithoutCreatedElementsInput>
  }

  export type AssuranceElementUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutChildrenInput, AssuranceElementUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutChildrenInput
    upsert?: AssuranceElementUpsertWithoutChildrenInput
    disconnect?: AssuranceElementWhereInput | boolean
    delete?: AssuranceElementWhereInput | boolean
    connect?: AssuranceElementWhereUniqueInput
    update?: XOR<XOR<AssuranceElementUpdateToOneWithWhereWithoutChildrenInput, AssuranceElementUpdateWithoutChildrenInput>, AssuranceElementUncheckedUpdateWithoutChildrenInput>
  }

  export type AssuranceElementUpdateManyWithoutParentNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutParentInput, AssuranceElementUncheckedCreateWithoutParentInput> | AssuranceElementCreateWithoutParentInput[] | AssuranceElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutParentInput | AssuranceElementCreateOrConnectWithoutParentInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutParentInput | AssuranceElementUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AssuranceElementCreateManyParentInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutParentInput | AssuranceElementUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutParentInput | AssuranceElementUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type AssuranceElementUpdateOneWithoutDefeatedByNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutDefeatedByInput, AssuranceElementUncheckedCreateWithoutDefeatedByInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutDefeatedByInput
    upsert?: AssuranceElementUpsertWithoutDefeatedByInput
    disconnect?: AssuranceElementWhereInput | boolean
    delete?: AssuranceElementWhereInput | boolean
    connect?: AssuranceElementWhereUniqueInput
    update?: XOR<XOR<AssuranceElementUpdateToOneWithWhereWithoutDefeatedByInput, AssuranceElementUpdateWithoutDefeatedByInput>, AssuranceElementUncheckedUpdateWithoutDefeatedByInput>
  }

  export type AssuranceElementUpdateManyWithoutDefeatsElementNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutDefeatsElementInput, AssuranceElementUncheckedCreateWithoutDefeatsElementInput> | AssuranceElementCreateWithoutDefeatsElementInput[] | AssuranceElementUncheckedCreateWithoutDefeatsElementInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutDefeatsElementInput | AssuranceElementCreateOrConnectWithoutDefeatsElementInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutDefeatsElementInput | AssuranceElementUpsertWithWhereUniqueWithoutDefeatsElementInput[]
    createMany?: AssuranceElementCreateManyDefeatsElementInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutDefeatsElementInput | AssuranceElementUpdateWithWhereUniqueWithoutDefeatsElementInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutDefeatsElementInput | AssuranceElementUpdateManyWithWhereWithoutDefeatsElementInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutEmbeddedInInput, AssuranceCaseUncheckedCreateWithoutEmbeddedInInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutEmbeddedInInput
    upsert?: AssuranceCaseUpsertWithoutEmbeddedInInput
    disconnect?: AssuranceCaseWhereInput | boolean
    delete?: AssuranceCaseWhereInput | boolean
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutEmbeddedInInput, AssuranceCaseUpdateWithoutEmbeddedInInput>, AssuranceCaseUncheckedUpdateWithoutEmbeddedInInput>
  }

  export type EvidenceLinkUpdateManyWithoutEvidenceNestedInput = {
    create?: XOR<EvidenceLinkCreateWithoutEvidenceInput, EvidenceLinkUncheckedCreateWithoutEvidenceInput> | EvidenceLinkCreateWithoutEvidenceInput[] | EvidenceLinkUncheckedCreateWithoutEvidenceInput[]
    connectOrCreate?: EvidenceLinkCreateOrConnectWithoutEvidenceInput | EvidenceLinkCreateOrConnectWithoutEvidenceInput[]
    upsert?: EvidenceLinkUpsertWithWhereUniqueWithoutEvidenceInput | EvidenceLinkUpsertWithWhereUniqueWithoutEvidenceInput[]
    createMany?: EvidenceLinkCreateManyEvidenceInputEnvelope
    set?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    disconnect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    delete?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    connect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    update?: EvidenceLinkUpdateWithWhereUniqueWithoutEvidenceInput | EvidenceLinkUpdateWithWhereUniqueWithoutEvidenceInput[]
    updateMany?: EvidenceLinkUpdateManyWithWhereWithoutEvidenceInput | EvidenceLinkUpdateManyWithWhereWithoutEvidenceInput[]
    deleteMany?: EvidenceLinkScalarWhereInput | EvidenceLinkScalarWhereInput[]
  }

  export type EvidenceLinkUpdateManyWithoutClaimNestedInput = {
    create?: XOR<EvidenceLinkCreateWithoutClaimInput, EvidenceLinkUncheckedCreateWithoutClaimInput> | EvidenceLinkCreateWithoutClaimInput[] | EvidenceLinkUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EvidenceLinkCreateOrConnectWithoutClaimInput | EvidenceLinkCreateOrConnectWithoutClaimInput[]
    upsert?: EvidenceLinkUpsertWithWhereUniqueWithoutClaimInput | EvidenceLinkUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: EvidenceLinkCreateManyClaimInputEnvelope
    set?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    disconnect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    delete?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    connect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    update?: EvidenceLinkUpdateWithWhereUniqueWithoutClaimInput | EvidenceLinkUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: EvidenceLinkUpdateManyWithWhereWithoutClaimInput | EvidenceLinkUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: EvidenceLinkScalarWhereInput | EvidenceLinkScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutElementNestedInput = {
    create?: XOR<CommentCreateWithoutElementInput, CommentUncheckedCreateWithoutElementInput> | CommentCreateWithoutElementInput[] | CommentUncheckedCreateWithoutElementInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutElementInput | CommentCreateOrConnectWithoutElementInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutElementInput | CommentUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: CommentCreateManyElementInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutElementInput | CommentUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutElementInput | CommentUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReleaseCommentUpdateManyWithoutElementNestedInput = {
    create?: XOR<ReleaseCommentCreateWithoutElementInput, ReleaseCommentUncheckedCreateWithoutElementInput> | ReleaseCommentCreateWithoutElementInput[] | ReleaseCommentUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutElementInput | ReleaseCommentCreateOrConnectWithoutElementInput[]
    upsert?: ReleaseCommentUpsertWithWhereUniqueWithoutElementInput | ReleaseCommentUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: ReleaseCommentCreateManyElementInputEnvelope
    set?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    disconnect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    delete?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    update?: ReleaseCommentUpdateWithWhereUniqueWithoutElementInput | ReleaseCommentUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: ReleaseCommentUpdateManyWithWhereWithoutElementInput | ReleaseCommentUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
  }

  export type AssuranceElementUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutParentInput, AssuranceElementUncheckedCreateWithoutParentInput> | AssuranceElementCreateWithoutParentInput[] | AssuranceElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutParentInput | AssuranceElementCreateOrConnectWithoutParentInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutParentInput | AssuranceElementUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: AssuranceElementCreateManyParentInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutParentInput | AssuranceElementUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutParentInput | AssuranceElementUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutDefeatsElementInput, AssuranceElementUncheckedCreateWithoutDefeatsElementInput> | AssuranceElementCreateWithoutDefeatsElementInput[] | AssuranceElementUncheckedCreateWithoutDefeatsElementInput[]
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutDefeatsElementInput | AssuranceElementCreateOrConnectWithoutDefeatsElementInput[]
    upsert?: AssuranceElementUpsertWithWhereUniqueWithoutDefeatsElementInput | AssuranceElementUpsertWithWhereUniqueWithoutDefeatsElementInput[]
    createMany?: AssuranceElementCreateManyDefeatsElementInputEnvelope
    set?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    disconnect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    delete?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    connect?: AssuranceElementWhereUniqueInput | AssuranceElementWhereUniqueInput[]
    update?: AssuranceElementUpdateWithWhereUniqueWithoutDefeatsElementInput | AssuranceElementUpdateWithWhereUniqueWithoutDefeatsElementInput[]
    updateMany?: AssuranceElementUpdateManyWithWhereWithoutDefeatsElementInput | AssuranceElementUpdateManyWithWhereWithoutDefeatsElementInput[]
    deleteMany?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
  }

  export type EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput = {
    create?: XOR<EvidenceLinkCreateWithoutEvidenceInput, EvidenceLinkUncheckedCreateWithoutEvidenceInput> | EvidenceLinkCreateWithoutEvidenceInput[] | EvidenceLinkUncheckedCreateWithoutEvidenceInput[]
    connectOrCreate?: EvidenceLinkCreateOrConnectWithoutEvidenceInput | EvidenceLinkCreateOrConnectWithoutEvidenceInput[]
    upsert?: EvidenceLinkUpsertWithWhereUniqueWithoutEvidenceInput | EvidenceLinkUpsertWithWhereUniqueWithoutEvidenceInput[]
    createMany?: EvidenceLinkCreateManyEvidenceInputEnvelope
    set?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    disconnect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    delete?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    connect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    update?: EvidenceLinkUpdateWithWhereUniqueWithoutEvidenceInput | EvidenceLinkUpdateWithWhereUniqueWithoutEvidenceInput[]
    updateMany?: EvidenceLinkUpdateManyWithWhereWithoutEvidenceInput | EvidenceLinkUpdateManyWithWhereWithoutEvidenceInput[]
    deleteMany?: EvidenceLinkScalarWhereInput | EvidenceLinkScalarWhereInput[]
  }

  export type EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput = {
    create?: XOR<EvidenceLinkCreateWithoutClaimInput, EvidenceLinkUncheckedCreateWithoutClaimInput> | EvidenceLinkCreateWithoutClaimInput[] | EvidenceLinkUncheckedCreateWithoutClaimInput[]
    connectOrCreate?: EvidenceLinkCreateOrConnectWithoutClaimInput | EvidenceLinkCreateOrConnectWithoutClaimInput[]
    upsert?: EvidenceLinkUpsertWithWhereUniqueWithoutClaimInput | EvidenceLinkUpsertWithWhereUniqueWithoutClaimInput[]
    createMany?: EvidenceLinkCreateManyClaimInputEnvelope
    set?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    disconnect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    delete?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    connect?: EvidenceLinkWhereUniqueInput | EvidenceLinkWhereUniqueInput[]
    update?: EvidenceLinkUpdateWithWhereUniqueWithoutClaimInput | EvidenceLinkUpdateWithWhereUniqueWithoutClaimInput[]
    updateMany?: EvidenceLinkUpdateManyWithWhereWithoutClaimInput | EvidenceLinkUpdateManyWithWhereWithoutClaimInput[]
    deleteMany?: EvidenceLinkScalarWhereInput | EvidenceLinkScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<CommentCreateWithoutElementInput, CommentUncheckedCreateWithoutElementInput> | CommentCreateWithoutElementInput[] | CommentUncheckedCreateWithoutElementInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutElementInput | CommentCreateOrConnectWithoutElementInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutElementInput | CommentUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: CommentCreateManyElementInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutElementInput | CommentUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutElementInput | CommentUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<ReleaseCommentCreateWithoutElementInput, ReleaseCommentUncheckedCreateWithoutElementInput> | ReleaseCommentCreateWithoutElementInput[] | ReleaseCommentUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutElementInput | ReleaseCommentCreateOrConnectWithoutElementInput[]
    upsert?: ReleaseCommentUpsertWithWhereUniqueWithoutElementInput | ReleaseCommentUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: ReleaseCommentCreateManyElementInputEnvelope
    set?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    disconnect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    delete?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    update?: ReleaseCommentUpdateWithWhereUniqueWithoutElementInput | ReleaseCommentUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: ReleaseCommentUpdateManyWithWhereWithoutElementInput | ReleaseCommentUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
  }

  export type AssuranceElementCreateNestedOneWithoutEvidenceLinksFromInput = {
    create?: XOR<AssuranceElementCreateWithoutEvidenceLinksFromInput, AssuranceElementUncheckedCreateWithoutEvidenceLinksFromInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutEvidenceLinksFromInput
    connect?: AssuranceElementWhereUniqueInput
  }

  export type AssuranceElementCreateNestedOneWithoutEvidenceLinksToInput = {
    create?: XOR<AssuranceElementCreateWithoutEvidenceLinksToInput, AssuranceElementUncheckedCreateWithoutEvidenceLinksToInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutEvidenceLinksToInput
    connect?: AssuranceElementWhereUniqueInput
  }

  export type AssuranceElementUpdateOneRequiredWithoutEvidenceLinksFromNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutEvidenceLinksFromInput, AssuranceElementUncheckedCreateWithoutEvidenceLinksFromInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutEvidenceLinksFromInput
    upsert?: AssuranceElementUpsertWithoutEvidenceLinksFromInput
    connect?: AssuranceElementWhereUniqueInput
    update?: XOR<XOR<AssuranceElementUpdateToOneWithWhereWithoutEvidenceLinksFromInput, AssuranceElementUpdateWithoutEvidenceLinksFromInput>, AssuranceElementUncheckedUpdateWithoutEvidenceLinksFromInput>
  }

  export type AssuranceElementUpdateOneRequiredWithoutEvidenceLinksToNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutEvidenceLinksToInput, AssuranceElementUncheckedCreateWithoutEvidenceLinksToInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutEvidenceLinksToInput
    upsert?: AssuranceElementUpsertWithoutEvidenceLinksToInput
    connect?: AssuranceElementWhereUniqueInput
    update?: XOR<XOR<AssuranceElementUpdateToOneWithWhereWithoutEvidenceLinksToInput, AssuranceElementUpdateWithoutEvidenceLinksToInput>, AssuranceElementUncheckedUpdateWithoutEvidenceLinksToInput>
  }

  export type ArgumentPatternCreatetagsInput = {
    set: string[]
  }

  export type PatternElementCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternElementCreateWithoutPatternInput, PatternElementUncheckedCreateWithoutPatternInput> | PatternElementCreateWithoutPatternInput[] | PatternElementUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternElementCreateOrConnectWithoutPatternInput | PatternElementCreateOrConnectWithoutPatternInput[]
    createMany?: PatternElementCreateManyPatternInputEnvelope
    connect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
  }

  export type PatternPermissionCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternPermissionCreateWithoutPatternInput, PatternPermissionUncheckedCreateWithoutPatternInput> | PatternPermissionCreateWithoutPatternInput[] | PatternPermissionUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternPermissionCreateOrConnectWithoutPatternInput | PatternPermissionCreateOrConnectWithoutPatternInput[]
    createMany?: PatternPermissionCreateManyPatternInputEnvelope
    connect?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
  }

  export type PatternTeamPermissionCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternTeamPermissionCreateWithoutPatternInput, PatternTeamPermissionUncheckedCreateWithoutPatternInput> | PatternTeamPermissionCreateWithoutPatternInput[] | PatternTeamPermissionUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternTeamPermissionCreateOrConnectWithoutPatternInput | PatternTeamPermissionCreateOrConnectWithoutPatternInput[]
    createMany?: PatternTeamPermissionCreateManyPatternInputEnvelope
    connect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
  }

  export type AssuranceCaseCreateNestedManyWithoutSourcePatternInput = {
    create?: XOR<AssuranceCaseCreateWithoutSourcePatternInput, AssuranceCaseUncheckedCreateWithoutSourcePatternInput> | AssuranceCaseCreateWithoutSourcePatternInput[] | AssuranceCaseUncheckedCreateWithoutSourcePatternInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutSourcePatternInput | AssuranceCaseCreateOrConnectWithoutSourcePatternInput[]
    createMany?: AssuranceCaseCreateManySourcePatternInputEnvelope
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
  }

  export type PatternElementUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternElementCreateWithoutPatternInput, PatternElementUncheckedCreateWithoutPatternInput> | PatternElementCreateWithoutPatternInput[] | PatternElementUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternElementCreateOrConnectWithoutPatternInput | PatternElementCreateOrConnectWithoutPatternInput[]
    createMany?: PatternElementCreateManyPatternInputEnvelope
    connect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
  }

  export type PatternPermissionUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternPermissionCreateWithoutPatternInput, PatternPermissionUncheckedCreateWithoutPatternInput> | PatternPermissionCreateWithoutPatternInput[] | PatternPermissionUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternPermissionCreateOrConnectWithoutPatternInput | PatternPermissionCreateOrConnectWithoutPatternInput[]
    createMany?: PatternPermissionCreateManyPatternInputEnvelope
    connect?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
  }

  export type PatternTeamPermissionUncheckedCreateNestedManyWithoutPatternInput = {
    create?: XOR<PatternTeamPermissionCreateWithoutPatternInput, PatternTeamPermissionUncheckedCreateWithoutPatternInput> | PatternTeamPermissionCreateWithoutPatternInput[] | PatternTeamPermissionUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternTeamPermissionCreateOrConnectWithoutPatternInput | PatternTeamPermissionCreateOrConnectWithoutPatternInput[]
    createMany?: PatternTeamPermissionCreateManyPatternInputEnvelope
    connect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
  }

  export type AssuranceCaseUncheckedCreateNestedManyWithoutSourcePatternInput = {
    create?: XOR<AssuranceCaseCreateWithoutSourcePatternInput, AssuranceCaseUncheckedCreateWithoutSourcePatternInput> | AssuranceCaseCreateWithoutSourcePatternInput[] | AssuranceCaseUncheckedCreateWithoutSourcePatternInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutSourcePatternInput | AssuranceCaseCreateOrConnectWithoutSourcePatternInput[]
    createMany?: AssuranceCaseCreateManySourcePatternInputEnvelope
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
  }

  export type ArgumentPatternUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PatternElementUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternElementCreateWithoutPatternInput, PatternElementUncheckedCreateWithoutPatternInput> | PatternElementCreateWithoutPatternInput[] | PatternElementUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternElementCreateOrConnectWithoutPatternInput | PatternElementCreateOrConnectWithoutPatternInput[]
    upsert?: PatternElementUpsertWithWhereUniqueWithoutPatternInput | PatternElementUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternElementCreateManyPatternInputEnvelope
    set?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    disconnect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    delete?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    connect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    update?: PatternElementUpdateWithWhereUniqueWithoutPatternInput | PatternElementUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternElementUpdateManyWithWhereWithoutPatternInput | PatternElementUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternElementScalarWhereInput | PatternElementScalarWhereInput[]
  }

  export type PatternPermissionUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternPermissionCreateWithoutPatternInput, PatternPermissionUncheckedCreateWithoutPatternInput> | PatternPermissionCreateWithoutPatternInput[] | PatternPermissionUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternPermissionCreateOrConnectWithoutPatternInput | PatternPermissionCreateOrConnectWithoutPatternInput[]
    upsert?: PatternPermissionUpsertWithWhereUniqueWithoutPatternInput | PatternPermissionUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternPermissionCreateManyPatternInputEnvelope
    set?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
    disconnect?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
    delete?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
    connect?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
    update?: PatternPermissionUpdateWithWhereUniqueWithoutPatternInput | PatternPermissionUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternPermissionUpdateManyWithWhereWithoutPatternInput | PatternPermissionUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternPermissionScalarWhereInput | PatternPermissionScalarWhereInput[]
  }

  export type PatternTeamPermissionUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternTeamPermissionCreateWithoutPatternInput, PatternTeamPermissionUncheckedCreateWithoutPatternInput> | PatternTeamPermissionCreateWithoutPatternInput[] | PatternTeamPermissionUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternTeamPermissionCreateOrConnectWithoutPatternInput | PatternTeamPermissionCreateOrConnectWithoutPatternInput[]
    upsert?: PatternTeamPermissionUpsertWithWhereUniqueWithoutPatternInput | PatternTeamPermissionUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternTeamPermissionCreateManyPatternInputEnvelope
    set?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    disconnect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    delete?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    connect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    update?: PatternTeamPermissionUpdateWithWhereUniqueWithoutPatternInput | PatternTeamPermissionUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternTeamPermissionUpdateManyWithWhereWithoutPatternInput | PatternTeamPermissionUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternTeamPermissionScalarWhereInput | PatternTeamPermissionScalarWhereInput[]
  }

  export type AssuranceCaseUpdateManyWithoutSourcePatternNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutSourcePatternInput, AssuranceCaseUncheckedCreateWithoutSourcePatternInput> | AssuranceCaseCreateWithoutSourcePatternInput[] | AssuranceCaseUncheckedCreateWithoutSourcePatternInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutSourcePatternInput | AssuranceCaseCreateOrConnectWithoutSourcePatternInput[]
    upsert?: AssuranceCaseUpsertWithWhereUniqueWithoutSourcePatternInput | AssuranceCaseUpsertWithWhereUniqueWithoutSourcePatternInput[]
    createMany?: AssuranceCaseCreateManySourcePatternInputEnvelope
    set?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    disconnect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    delete?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    update?: AssuranceCaseUpdateWithWhereUniqueWithoutSourcePatternInput | AssuranceCaseUpdateWithWhereUniqueWithoutSourcePatternInput[]
    updateMany?: AssuranceCaseUpdateManyWithWhereWithoutSourcePatternInput | AssuranceCaseUpdateManyWithWhereWithoutSourcePatternInput[]
    deleteMany?: AssuranceCaseScalarWhereInput | AssuranceCaseScalarWhereInput[]
  }

  export type PatternElementUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternElementCreateWithoutPatternInput, PatternElementUncheckedCreateWithoutPatternInput> | PatternElementCreateWithoutPatternInput[] | PatternElementUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternElementCreateOrConnectWithoutPatternInput | PatternElementCreateOrConnectWithoutPatternInput[]
    upsert?: PatternElementUpsertWithWhereUniqueWithoutPatternInput | PatternElementUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternElementCreateManyPatternInputEnvelope
    set?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    disconnect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    delete?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    connect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    update?: PatternElementUpdateWithWhereUniqueWithoutPatternInput | PatternElementUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternElementUpdateManyWithWhereWithoutPatternInput | PatternElementUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternElementScalarWhereInput | PatternElementScalarWhereInput[]
  }

  export type PatternPermissionUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternPermissionCreateWithoutPatternInput, PatternPermissionUncheckedCreateWithoutPatternInput> | PatternPermissionCreateWithoutPatternInput[] | PatternPermissionUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternPermissionCreateOrConnectWithoutPatternInput | PatternPermissionCreateOrConnectWithoutPatternInput[]
    upsert?: PatternPermissionUpsertWithWhereUniqueWithoutPatternInput | PatternPermissionUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternPermissionCreateManyPatternInputEnvelope
    set?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
    disconnect?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
    delete?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
    connect?: PatternPermissionWhereUniqueInput | PatternPermissionWhereUniqueInput[]
    update?: PatternPermissionUpdateWithWhereUniqueWithoutPatternInput | PatternPermissionUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternPermissionUpdateManyWithWhereWithoutPatternInput | PatternPermissionUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternPermissionScalarWhereInput | PatternPermissionScalarWhereInput[]
  }

  export type PatternTeamPermissionUncheckedUpdateManyWithoutPatternNestedInput = {
    create?: XOR<PatternTeamPermissionCreateWithoutPatternInput, PatternTeamPermissionUncheckedCreateWithoutPatternInput> | PatternTeamPermissionCreateWithoutPatternInput[] | PatternTeamPermissionUncheckedCreateWithoutPatternInput[]
    connectOrCreate?: PatternTeamPermissionCreateOrConnectWithoutPatternInput | PatternTeamPermissionCreateOrConnectWithoutPatternInput[]
    upsert?: PatternTeamPermissionUpsertWithWhereUniqueWithoutPatternInput | PatternTeamPermissionUpsertWithWhereUniqueWithoutPatternInput[]
    createMany?: PatternTeamPermissionCreateManyPatternInputEnvelope
    set?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    disconnect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    delete?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    connect?: PatternTeamPermissionWhereUniqueInput | PatternTeamPermissionWhereUniqueInput[]
    update?: PatternTeamPermissionUpdateWithWhereUniqueWithoutPatternInput | PatternTeamPermissionUpdateWithWhereUniqueWithoutPatternInput[]
    updateMany?: PatternTeamPermissionUpdateManyWithWhereWithoutPatternInput | PatternTeamPermissionUpdateManyWithWhereWithoutPatternInput[]
    deleteMany?: PatternTeamPermissionScalarWhereInput | PatternTeamPermissionScalarWhereInput[]
  }

  export type AssuranceCaseUncheckedUpdateManyWithoutSourcePatternNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutSourcePatternInput, AssuranceCaseUncheckedCreateWithoutSourcePatternInput> | AssuranceCaseCreateWithoutSourcePatternInput[] | AssuranceCaseUncheckedCreateWithoutSourcePatternInput[]
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutSourcePatternInput | AssuranceCaseCreateOrConnectWithoutSourcePatternInput[]
    upsert?: AssuranceCaseUpsertWithWhereUniqueWithoutSourcePatternInput | AssuranceCaseUpsertWithWhereUniqueWithoutSourcePatternInput[]
    createMany?: AssuranceCaseCreateManySourcePatternInputEnvelope
    set?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    disconnect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    delete?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    connect?: AssuranceCaseWhereUniqueInput | AssuranceCaseWhereUniqueInput[]
    update?: AssuranceCaseUpdateWithWhereUniqueWithoutSourcePatternInput | AssuranceCaseUpdateWithWhereUniqueWithoutSourcePatternInput[]
    updateMany?: AssuranceCaseUpdateManyWithWhereWithoutSourcePatternInput | AssuranceCaseUpdateManyWithWhereWithoutSourcePatternInput[]
    deleteMany?: AssuranceCaseScalarWhereInput | AssuranceCaseScalarWhereInput[]
  }

  export type ArgumentPatternCreateNestedOneWithoutElementsInput = {
    create?: XOR<ArgumentPatternCreateWithoutElementsInput, ArgumentPatternUncheckedCreateWithoutElementsInput>
    connectOrCreate?: ArgumentPatternCreateOrConnectWithoutElementsInput
    connect?: ArgumentPatternWhereUniqueInput
  }

  export type PatternElementCreateNestedOneWithoutChildrenInput = {
    create?: XOR<PatternElementCreateWithoutChildrenInput, PatternElementUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PatternElementCreateOrConnectWithoutChildrenInput
    connect?: PatternElementWhereUniqueInput
  }

  export type PatternElementCreateNestedManyWithoutParentInput = {
    create?: XOR<PatternElementCreateWithoutParentInput, PatternElementUncheckedCreateWithoutParentInput> | PatternElementCreateWithoutParentInput[] | PatternElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PatternElementCreateOrConnectWithoutParentInput | PatternElementCreateOrConnectWithoutParentInput[]
    createMany?: PatternElementCreateManyParentInputEnvelope
    connect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
  }

  export type PatternElementUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<PatternElementCreateWithoutParentInput, PatternElementUncheckedCreateWithoutParentInput> | PatternElementCreateWithoutParentInput[] | PatternElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PatternElementCreateOrConnectWithoutParentInput | PatternElementCreateOrConnectWithoutParentInput[]
    createMany?: PatternElementCreateManyParentInputEnvelope
    connect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ArgumentPatternUpdateOneRequiredWithoutElementsNestedInput = {
    create?: XOR<ArgumentPatternCreateWithoutElementsInput, ArgumentPatternUncheckedCreateWithoutElementsInput>
    connectOrCreate?: ArgumentPatternCreateOrConnectWithoutElementsInput
    upsert?: ArgumentPatternUpsertWithoutElementsInput
    connect?: ArgumentPatternWhereUniqueInput
    update?: XOR<XOR<ArgumentPatternUpdateToOneWithWhereWithoutElementsInput, ArgumentPatternUpdateWithoutElementsInput>, ArgumentPatternUncheckedUpdateWithoutElementsInput>
  }

  export type PatternElementUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<PatternElementCreateWithoutChildrenInput, PatternElementUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: PatternElementCreateOrConnectWithoutChildrenInput
    upsert?: PatternElementUpsertWithoutChildrenInput
    disconnect?: PatternElementWhereInput | boolean
    delete?: PatternElementWhereInput | boolean
    connect?: PatternElementWhereUniqueInput
    update?: XOR<XOR<PatternElementUpdateToOneWithWhereWithoutChildrenInput, PatternElementUpdateWithoutChildrenInput>, PatternElementUncheckedUpdateWithoutChildrenInput>
  }

  export type PatternElementUpdateManyWithoutParentNestedInput = {
    create?: XOR<PatternElementCreateWithoutParentInput, PatternElementUncheckedCreateWithoutParentInput> | PatternElementCreateWithoutParentInput[] | PatternElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PatternElementCreateOrConnectWithoutParentInput | PatternElementCreateOrConnectWithoutParentInput[]
    upsert?: PatternElementUpsertWithWhereUniqueWithoutParentInput | PatternElementUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PatternElementCreateManyParentInputEnvelope
    set?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    disconnect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    delete?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    connect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    update?: PatternElementUpdateWithWhereUniqueWithoutParentInput | PatternElementUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PatternElementUpdateManyWithWhereWithoutParentInput | PatternElementUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PatternElementScalarWhereInput | PatternElementScalarWhereInput[]
  }

  export type PatternElementUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<PatternElementCreateWithoutParentInput, PatternElementUncheckedCreateWithoutParentInput> | PatternElementCreateWithoutParentInput[] | PatternElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: PatternElementCreateOrConnectWithoutParentInput | PatternElementCreateOrConnectWithoutParentInput[]
    upsert?: PatternElementUpsertWithWhereUniqueWithoutParentInput | PatternElementUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: PatternElementCreateManyParentInputEnvelope
    set?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    disconnect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    delete?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    connect?: PatternElementWhereUniqueInput | PatternElementWhereUniqueInput[]
    update?: PatternElementUpdateWithWhereUniqueWithoutParentInput | PatternElementUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: PatternElementUpdateManyWithWhereWithoutParentInput | PatternElementUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: PatternElementScalarWhereInput | PatternElementScalarWhereInput[]
  }

  export type ArgumentPatternCreateNestedOneWithoutUserPermissionsInput = {
    create?: XOR<ArgumentPatternCreateWithoutUserPermissionsInput, ArgumentPatternUncheckedCreateWithoutUserPermissionsInput>
    connectOrCreate?: ArgumentPatternCreateOrConnectWithoutUserPermissionsInput
    connect?: ArgumentPatternWhereUniqueInput
  }

  export type ArgumentPatternUpdateOneRequiredWithoutUserPermissionsNestedInput = {
    create?: XOR<ArgumentPatternCreateWithoutUserPermissionsInput, ArgumentPatternUncheckedCreateWithoutUserPermissionsInput>
    connectOrCreate?: ArgumentPatternCreateOrConnectWithoutUserPermissionsInput
    upsert?: ArgumentPatternUpsertWithoutUserPermissionsInput
    connect?: ArgumentPatternWhereUniqueInput
    update?: XOR<XOR<ArgumentPatternUpdateToOneWithWhereWithoutUserPermissionsInput, ArgumentPatternUpdateWithoutUserPermissionsInput>, ArgumentPatternUncheckedUpdateWithoutUserPermissionsInput>
  }

  export type ArgumentPatternCreateNestedOneWithoutTeamPermissionsInput = {
    create?: XOR<ArgumentPatternCreateWithoutTeamPermissionsInput, ArgumentPatternUncheckedCreateWithoutTeamPermissionsInput>
    connectOrCreate?: ArgumentPatternCreateOrConnectWithoutTeamPermissionsInput
    connect?: ArgumentPatternWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutPatternPermissionsInput = {
    create?: XOR<TeamCreateWithoutPatternPermissionsInput, TeamUncheckedCreateWithoutPatternPermissionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPatternPermissionsInput
    connect?: TeamWhereUniqueInput
  }

  export type ArgumentPatternUpdateOneRequiredWithoutTeamPermissionsNestedInput = {
    create?: XOR<ArgumentPatternCreateWithoutTeamPermissionsInput, ArgumentPatternUncheckedCreateWithoutTeamPermissionsInput>
    connectOrCreate?: ArgumentPatternCreateOrConnectWithoutTeamPermissionsInput
    upsert?: ArgumentPatternUpsertWithoutTeamPermissionsInput
    connect?: ArgumentPatternWhereUniqueInput
    update?: XOR<XOR<ArgumentPatternUpdateToOneWithWhereWithoutTeamPermissionsInput, ArgumentPatternUpdateWithoutTeamPermissionsInput>, ArgumentPatternUncheckedUpdateWithoutTeamPermissionsInput>
  }

  export type TeamUpdateOneRequiredWithoutPatternPermissionsNestedInput = {
    create?: XOR<TeamCreateWithoutPatternPermissionsInput, TeamUncheckedCreateWithoutPatternPermissionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutPatternPermissionsInput
    upsert?: TeamUpsertWithoutPatternPermissionsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutPatternPermissionsInput, TeamUpdateWithoutPatternPermissionsInput>, TeamUncheckedUpdateWithoutPatternPermissionsInput>
  }

  export type ReleaseCreatetagsInput = {
    set: string[]
  }

  export type AssuranceCaseCreateNestedOneWithoutSourceReleasesInput = {
    create?: XOR<AssuranceCaseCreateWithoutSourceReleasesInput, AssuranceCaseUncheckedCreateWithoutSourceReleasesInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutSourceReleasesInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type AssuranceCaseCreateNestedOneWithoutPublishedReleasesInput = {
    create?: XOR<AssuranceCaseCreateWithoutPublishedReleasesInput, AssuranceCaseUncheckedCreateWithoutPublishedReleasesInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutPublishedReleasesInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type ReleaseSnapshotCreateNestedManyWithoutReleaseInput = {
    create?: XOR<ReleaseSnapshotCreateWithoutReleaseInput, ReleaseSnapshotUncheckedCreateWithoutReleaseInput> | ReleaseSnapshotCreateWithoutReleaseInput[] | ReleaseSnapshotUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseSnapshotCreateOrConnectWithoutReleaseInput | ReleaseSnapshotCreateOrConnectWithoutReleaseInput[]
    createMany?: ReleaseSnapshotCreateManyReleaseInputEnvelope
    connect?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
  }

  export type ReleaseCommentCreateNestedManyWithoutReleaseInput = {
    create?: XOR<ReleaseCommentCreateWithoutReleaseInput, ReleaseCommentUncheckedCreateWithoutReleaseInput> | ReleaseCommentCreateWithoutReleaseInput[] | ReleaseCommentUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutReleaseInput | ReleaseCommentCreateOrConnectWithoutReleaseInput[]
    createMany?: ReleaseCommentCreateManyReleaseInputEnvelope
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
  }

  export type ReleaseImageCreateNestedOneWithoutReleaseInput = {
    create?: XOR<ReleaseImageCreateWithoutReleaseInput, ReleaseImageUncheckedCreateWithoutReleaseInput>
    connectOrCreate?: ReleaseImageCreateOrConnectWithoutReleaseInput
    connect?: ReleaseImageWhereUniqueInput
  }

  export type ReleaseSnapshotUncheckedCreateNestedManyWithoutReleaseInput = {
    create?: XOR<ReleaseSnapshotCreateWithoutReleaseInput, ReleaseSnapshotUncheckedCreateWithoutReleaseInput> | ReleaseSnapshotCreateWithoutReleaseInput[] | ReleaseSnapshotUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseSnapshotCreateOrConnectWithoutReleaseInput | ReleaseSnapshotCreateOrConnectWithoutReleaseInput[]
    createMany?: ReleaseSnapshotCreateManyReleaseInputEnvelope
    connect?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
  }

  export type ReleaseCommentUncheckedCreateNestedManyWithoutReleaseInput = {
    create?: XOR<ReleaseCommentCreateWithoutReleaseInput, ReleaseCommentUncheckedCreateWithoutReleaseInput> | ReleaseCommentCreateWithoutReleaseInput[] | ReleaseCommentUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutReleaseInput | ReleaseCommentCreateOrConnectWithoutReleaseInput[]
    createMany?: ReleaseCommentCreateManyReleaseInputEnvelope
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
  }

  export type ReleaseImageUncheckedCreateNestedOneWithoutReleaseInput = {
    create?: XOR<ReleaseImageCreateWithoutReleaseInput, ReleaseImageUncheckedCreateWithoutReleaseInput>
    connectOrCreate?: ReleaseImageCreateOrConnectWithoutReleaseInput
    connect?: ReleaseImageWhereUniqueInput
  }

  export type ReleaseUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumReleaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReleaseStatus
  }

  export type AssuranceCaseUpdateOneRequiredWithoutSourceReleasesNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutSourceReleasesInput, AssuranceCaseUncheckedCreateWithoutSourceReleasesInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutSourceReleasesInput
    upsert?: AssuranceCaseUpsertWithoutSourceReleasesInput
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutSourceReleasesInput, AssuranceCaseUpdateWithoutSourceReleasesInput>, AssuranceCaseUncheckedUpdateWithoutSourceReleasesInput>
  }

  export type AssuranceCaseUpdateOneWithoutPublishedReleasesNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutPublishedReleasesInput, AssuranceCaseUncheckedCreateWithoutPublishedReleasesInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutPublishedReleasesInput
    upsert?: AssuranceCaseUpsertWithoutPublishedReleasesInput
    disconnect?: AssuranceCaseWhereInput | boolean
    delete?: AssuranceCaseWhereInput | boolean
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutPublishedReleasesInput, AssuranceCaseUpdateWithoutPublishedReleasesInput>, AssuranceCaseUncheckedUpdateWithoutPublishedReleasesInput>
  }

  export type ReleaseSnapshotUpdateManyWithoutReleaseNestedInput = {
    create?: XOR<ReleaseSnapshotCreateWithoutReleaseInput, ReleaseSnapshotUncheckedCreateWithoutReleaseInput> | ReleaseSnapshotCreateWithoutReleaseInput[] | ReleaseSnapshotUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseSnapshotCreateOrConnectWithoutReleaseInput | ReleaseSnapshotCreateOrConnectWithoutReleaseInput[]
    upsert?: ReleaseSnapshotUpsertWithWhereUniqueWithoutReleaseInput | ReleaseSnapshotUpsertWithWhereUniqueWithoutReleaseInput[]
    createMany?: ReleaseSnapshotCreateManyReleaseInputEnvelope
    set?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
    disconnect?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
    delete?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
    connect?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
    update?: ReleaseSnapshotUpdateWithWhereUniqueWithoutReleaseInput | ReleaseSnapshotUpdateWithWhereUniqueWithoutReleaseInput[]
    updateMany?: ReleaseSnapshotUpdateManyWithWhereWithoutReleaseInput | ReleaseSnapshotUpdateManyWithWhereWithoutReleaseInput[]
    deleteMany?: ReleaseSnapshotScalarWhereInput | ReleaseSnapshotScalarWhereInput[]
  }

  export type ReleaseCommentUpdateManyWithoutReleaseNestedInput = {
    create?: XOR<ReleaseCommentCreateWithoutReleaseInput, ReleaseCommentUncheckedCreateWithoutReleaseInput> | ReleaseCommentCreateWithoutReleaseInput[] | ReleaseCommentUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutReleaseInput | ReleaseCommentCreateOrConnectWithoutReleaseInput[]
    upsert?: ReleaseCommentUpsertWithWhereUniqueWithoutReleaseInput | ReleaseCommentUpsertWithWhereUniqueWithoutReleaseInput[]
    createMany?: ReleaseCommentCreateManyReleaseInputEnvelope
    set?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    disconnect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    delete?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    update?: ReleaseCommentUpdateWithWhereUniqueWithoutReleaseInput | ReleaseCommentUpdateWithWhereUniqueWithoutReleaseInput[]
    updateMany?: ReleaseCommentUpdateManyWithWhereWithoutReleaseInput | ReleaseCommentUpdateManyWithWhereWithoutReleaseInput[]
    deleteMany?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
  }

  export type ReleaseImageUpdateOneWithoutReleaseNestedInput = {
    create?: XOR<ReleaseImageCreateWithoutReleaseInput, ReleaseImageUncheckedCreateWithoutReleaseInput>
    connectOrCreate?: ReleaseImageCreateOrConnectWithoutReleaseInput
    upsert?: ReleaseImageUpsertWithoutReleaseInput
    disconnect?: ReleaseImageWhereInput | boolean
    delete?: ReleaseImageWhereInput | boolean
    connect?: ReleaseImageWhereUniqueInput
    update?: XOR<XOR<ReleaseImageUpdateToOneWithWhereWithoutReleaseInput, ReleaseImageUpdateWithoutReleaseInput>, ReleaseImageUncheckedUpdateWithoutReleaseInput>
  }

  export type ReleaseSnapshotUncheckedUpdateManyWithoutReleaseNestedInput = {
    create?: XOR<ReleaseSnapshotCreateWithoutReleaseInput, ReleaseSnapshotUncheckedCreateWithoutReleaseInput> | ReleaseSnapshotCreateWithoutReleaseInput[] | ReleaseSnapshotUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseSnapshotCreateOrConnectWithoutReleaseInput | ReleaseSnapshotCreateOrConnectWithoutReleaseInput[]
    upsert?: ReleaseSnapshotUpsertWithWhereUniqueWithoutReleaseInput | ReleaseSnapshotUpsertWithWhereUniqueWithoutReleaseInput[]
    createMany?: ReleaseSnapshotCreateManyReleaseInputEnvelope
    set?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
    disconnect?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
    delete?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
    connect?: ReleaseSnapshotWhereUniqueInput | ReleaseSnapshotWhereUniqueInput[]
    update?: ReleaseSnapshotUpdateWithWhereUniqueWithoutReleaseInput | ReleaseSnapshotUpdateWithWhereUniqueWithoutReleaseInput[]
    updateMany?: ReleaseSnapshotUpdateManyWithWhereWithoutReleaseInput | ReleaseSnapshotUpdateManyWithWhereWithoutReleaseInput[]
    deleteMany?: ReleaseSnapshotScalarWhereInput | ReleaseSnapshotScalarWhereInput[]
  }

  export type ReleaseCommentUncheckedUpdateManyWithoutReleaseNestedInput = {
    create?: XOR<ReleaseCommentCreateWithoutReleaseInput, ReleaseCommentUncheckedCreateWithoutReleaseInput> | ReleaseCommentCreateWithoutReleaseInput[] | ReleaseCommentUncheckedCreateWithoutReleaseInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutReleaseInput | ReleaseCommentCreateOrConnectWithoutReleaseInput[]
    upsert?: ReleaseCommentUpsertWithWhereUniqueWithoutReleaseInput | ReleaseCommentUpsertWithWhereUniqueWithoutReleaseInput[]
    createMany?: ReleaseCommentCreateManyReleaseInputEnvelope
    set?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    disconnect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    delete?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    update?: ReleaseCommentUpdateWithWhereUniqueWithoutReleaseInput | ReleaseCommentUpdateWithWhereUniqueWithoutReleaseInput[]
    updateMany?: ReleaseCommentUpdateManyWithWhereWithoutReleaseInput | ReleaseCommentUpdateManyWithWhereWithoutReleaseInput[]
    deleteMany?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
  }

  export type ReleaseImageUncheckedUpdateOneWithoutReleaseNestedInput = {
    create?: XOR<ReleaseImageCreateWithoutReleaseInput, ReleaseImageUncheckedCreateWithoutReleaseInput>
    connectOrCreate?: ReleaseImageCreateOrConnectWithoutReleaseInput
    upsert?: ReleaseImageUpsertWithoutReleaseInput
    disconnect?: ReleaseImageWhereInput | boolean
    delete?: ReleaseImageWhereInput | boolean
    connect?: ReleaseImageWhereUniqueInput
    update?: XOR<XOR<ReleaseImageUpdateToOneWithWhereWithoutReleaseInput, ReleaseImageUpdateWithoutReleaseInput>, ReleaseImageUncheckedUpdateWithoutReleaseInput>
  }

  export type ReleaseCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<ReleaseCreateWithoutSnapshotsInput, ReleaseUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: ReleaseCreateOrConnectWithoutSnapshotsInput
    connect?: ReleaseWhereUniqueInput
  }

  export type EnumSnapshotReasonFieldUpdateOperationsInput = {
    set?: $Enums.SnapshotReason
  }

  export type ReleaseUpdateOneRequiredWithoutSnapshotsNestedInput = {
    create?: XOR<ReleaseCreateWithoutSnapshotsInput, ReleaseUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: ReleaseCreateOrConnectWithoutSnapshotsInput
    upsert?: ReleaseUpsertWithoutSnapshotsInput
    connect?: ReleaseWhereUniqueInput
    update?: XOR<XOR<ReleaseUpdateToOneWithWhereWithoutSnapshotsInput, ReleaseUpdateWithoutSnapshotsInput>, ReleaseUncheckedUpdateWithoutSnapshotsInput>
  }

  export type ReleaseCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ReleaseCreateWithoutCommentsInput, ReleaseUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ReleaseCreateOrConnectWithoutCommentsInput
    connect?: ReleaseWhereUniqueInput
  }

  export type AssuranceElementCreateNestedOneWithoutReleaseCommentsInput = {
    create?: XOR<AssuranceElementCreateWithoutReleaseCommentsInput, AssuranceElementUncheckedCreateWithoutReleaseCommentsInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutReleaseCommentsInput
    connect?: AssuranceElementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReleaseCommentsInput = {
    create?: XOR<UserCreateWithoutReleaseCommentsInput, UserUncheckedCreateWithoutReleaseCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReleaseCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ReleaseCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<ReleaseCommentCreateWithoutRepliesInput, ReleaseCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutRepliesInput
    connect?: ReleaseCommentWhereUniqueInput
  }

  export type ReleaseCommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<ReleaseCommentCreateWithoutParentCommentInput, ReleaseCommentUncheckedCreateWithoutParentCommentInput> | ReleaseCommentCreateWithoutParentCommentInput[] | ReleaseCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutParentCommentInput | ReleaseCommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: ReleaseCommentCreateManyParentCommentInputEnvelope
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
  }

  export type ReleaseCommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<ReleaseCommentCreateWithoutParentCommentInput, ReleaseCommentUncheckedCreateWithoutParentCommentInput> | ReleaseCommentCreateWithoutParentCommentInput[] | ReleaseCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutParentCommentInput | ReleaseCommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: ReleaseCommentCreateManyParentCommentInputEnvelope
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
  }

  export type EnumCommentStatusFieldUpdateOperationsInput = {
    set?: $Enums.CommentStatus
  }

  export type ReleaseUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ReleaseCreateWithoutCommentsInput, ReleaseUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ReleaseCreateOrConnectWithoutCommentsInput
    upsert?: ReleaseUpsertWithoutCommentsInput
    connect?: ReleaseWhereUniqueInput
    update?: XOR<XOR<ReleaseUpdateToOneWithWhereWithoutCommentsInput, ReleaseUpdateWithoutCommentsInput>, ReleaseUncheckedUpdateWithoutCommentsInput>
  }

  export type AssuranceElementUpdateOneWithoutReleaseCommentsNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutReleaseCommentsInput, AssuranceElementUncheckedCreateWithoutReleaseCommentsInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutReleaseCommentsInput
    upsert?: AssuranceElementUpsertWithoutReleaseCommentsInput
    disconnect?: AssuranceElementWhereInput | boolean
    delete?: AssuranceElementWhereInput | boolean
    connect?: AssuranceElementWhereUniqueInput
    update?: XOR<XOR<AssuranceElementUpdateToOneWithWhereWithoutReleaseCommentsInput, AssuranceElementUpdateWithoutReleaseCommentsInput>, AssuranceElementUncheckedUpdateWithoutReleaseCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutReleaseCommentsNestedInput = {
    create?: XOR<UserCreateWithoutReleaseCommentsInput, UserUncheckedCreateWithoutReleaseCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReleaseCommentsInput
    upsert?: UserUpsertWithoutReleaseCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReleaseCommentsInput, UserUpdateWithoutReleaseCommentsInput>, UserUncheckedUpdateWithoutReleaseCommentsInput>
  }

  export type ReleaseCommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<ReleaseCommentCreateWithoutRepliesInput, ReleaseCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutRepliesInput
    upsert?: ReleaseCommentUpsertWithoutRepliesInput
    disconnect?: ReleaseCommentWhereInput | boolean
    delete?: ReleaseCommentWhereInput | boolean
    connect?: ReleaseCommentWhereUniqueInput
    update?: XOR<XOR<ReleaseCommentUpdateToOneWithWhereWithoutRepliesInput, ReleaseCommentUpdateWithoutRepliesInput>, ReleaseCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type ReleaseCommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<ReleaseCommentCreateWithoutParentCommentInput, ReleaseCommentUncheckedCreateWithoutParentCommentInput> | ReleaseCommentCreateWithoutParentCommentInput[] | ReleaseCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutParentCommentInput | ReleaseCommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: ReleaseCommentUpsertWithWhereUniqueWithoutParentCommentInput | ReleaseCommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: ReleaseCommentCreateManyParentCommentInputEnvelope
    set?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    disconnect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    delete?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    update?: ReleaseCommentUpdateWithWhereUniqueWithoutParentCommentInput | ReleaseCommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: ReleaseCommentUpdateManyWithWhereWithoutParentCommentInput | ReleaseCommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
  }

  export type ReleaseCommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<ReleaseCommentCreateWithoutParentCommentInput, ReleaseCommentUncheckedCreateWithoutParentCommentInput> | ReleaseCommentCreateWithoutParentCommentInput[] | ReleaseCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: ReleaseCommentCreateOrConnectWithoutParentCommentInput | ReleaseCommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: ReleaseCommentUpsertWithWhereUniqueWithoutParentCommentInput | ReleaseCommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: ReleaseCommentCreateManyParentCommentInputEnvelope
    set?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    disconnect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    delete?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    connect?: ReleaseCommentWhereUniqueInput | ReleaseCommentWhereUniqueInput[]
    update?: ReleaseCommentUpdateWithWhereUniqueWithoutParentCommentInput | ReleaseCommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: ReleaseCommentUpdateManyWithWhereWithoutParentCommentInput | ReleaseCommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
  }

  export type ReleaseCreateNestedOneWithoutImageInput = {
    create?: XOR<ReleaseCreateWithoutImageInput, ReleaseUncheckedCreateWithoutImageInput>
    connectOrCreate?: ReleaseCreateOrConnectWithoutImageInput
    connect?: ReleaseWhereUniqueInput
  }

  export type ReleaseUpdateOneRequiredWithoutImageNestedInput = {
    create?: XOR<ReleaseCreateWithoutImageInput, ReleaseUncheckedCreateWithoutImageInput>
    connectOrCreate?: ReleaseCreateOrConnectWithoutImageInput
    upsert?: ReleaseUpsertWithoutImageInput
    connect?: ReleaseWhereUniqueInput
    update?: XOR<XOR<ReleaseUpdateToOneWithWhereWithoutImageInput, ReleaseUpdateWithoutImageInput>, ReleaseUncheckedUpdateWithoutImageInput>
  }

  export type AssuranceCaseCreateNestedOneWithoutCommentsInput = {
    create?: XOR<AssuranceCaseCreateWithoutCommentsInput, AssuranceCaseUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCommentsInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type AssuranceElementCreateNestedOneWithoutCommentsInput = {
    create?: XOR<AssuranceElementCreateWithoutCommentsInput, AssuranceElementUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCommentsInput
    connect?: AssuranceElementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuthoredCommentsInput = {
    create?: XOR<UserCreateWithoutAuthoredCommentsInput, UserUncheckedCreateWithoutAuthoredCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthoredCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutResolvedCommentsInput = {
    create?: XOR<UserCreateWithoutResolvedCommentsInput, UserUncheckedCreateWithoutResolvedCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type AssuranceCaseUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutCommentsInput, AssuranceCaseUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCommentsInput
    upsert?: AssuranceCaseUpsertWithoutCommentsInput
    disconnect?: AssuranceCaseWhereInput | boolean
    delete?: AssuranceCaseWhereInput | boolean
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutCommentsInput, AssuranceCaseUpdateWithoutCommentsInput>, AssuranceCaseUncheckedUpdateWithoutCommentsInput>
  }

  export type AssuranceElementUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<AssuranceElementCreateWithoutCommentsInput, AssuranceElementUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: AssuranceElementCreateOrConnectWithoutCommentsInput
    upsert?: AssuranceElementUpsertWithoutCommentsInput
    disconnect?: AssuranceElementWhereInput | boolean
    delete?: AssuranceElementWhereInput | boolean
    connect?: AssuranceElementWhereUniqueInput
    update?: XOR<XOR<AssuranceElementUpdateToOneWithWhereWithoutCommentsInput, AssuranceElementUpdateWithoutCommentsInput>, AssuranceElementUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutAuthoredCommentsNestedInput = {
    create?: XOR<UserCreateWithoutAuthoredCommentsInput, UserUncheckedCreateWithoutAuthoredCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthoredCommentsInput
    upsert?: UserUpsertWithoutAuthoredCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthoredCommentsInput, UserUpdateWithoutAuthoredCommentsInput>, UserUncheckedUpdateWithoutAuthoredCommentsInput>
  }

  export type UserUpdateOneWithoutResolvedCommentsNestedInput = {
    create?: XOR<UserCreateWithoutResolvedCommentsInput, UserUncheckedCreateWithoutResolvedCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutResolvedCommentsInput
    upsert?: UserUpsertWithoutResolvedCommentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutResolvedCommentsInput, UserUpdateWithoutResolvedCommentsInput>, UserUncheckedUpdateWithoutResolvedCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentCommentInput | CommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentCommentInput | CommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentCommentInput | CommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentCommentInput | CommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentCommentInput | CommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentCommentInput | CommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type AssuranceCaseCreateNestedOneWithoutCaseImageInput = {
    create?: XOR<AssuranceCaseCreateWithoutCaseImageInput, AssuranceCaseUncheckedCreateWithoutCaseImageInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCaseImageInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type AssuranceCaseUpdateOneRequiredWithoutCaseImageNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutCaseImageInput, AssuranceCaseUncheckedCreateWithoutCaseImageInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCaseImageInput
    upsert?: AssuranceCaseUpsertWithoutCaseImageInput
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutCaseImageInput, AssuranceCaseUpdateWithoutCaseImageInput>, AssuranceCaseUncheckedUpdateWithoutCaseImageInput>
  }

  export type CaseTypeAssignmentCreateNestedManyWithoutCaseTypeInput = {
    create?: XOR<CaseTypeAssignmentCreateWithoutCaseTypeInput, CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput> | CaseTypeAssignmentCreateWithoutCaseTypeInput[] | CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput[]
    connectOrCreate?: CaseTypeAssignmentCreateOrConnectWithoutCaseTypeInput | CaseTypeAssignmentCreateOrConnectWithoutCaseTypeInput[]
    createMany?: CaseTypeAssignmentCreateManyCaseTypeInputEnvelope
    connect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
  }

  export type CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseTypeInput = {
    create?: XOR<CaseTypeAssignmentCreateWithoutCaseTypeInput, CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput> | CaseTypeAssignmentCreateWithoutCaseTypeInput[] | CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput[]
    connectOrCreate?: CaseTypeAssignmentCreateOrConnectWithoutCaseTypeInput | CaseTypeAssignmentCreateOrConnectWithoutCaseTypeInput[]
    createMany?: CaseTypeAssignmentCreateManyCaseTypeInputEnvelope
    connect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
  }

  export type EnumCaseTypeCategoryFieldUpdateOperationsInput = {
    set?: $Enums.CaseTypeCategory
  }

  export type CaseTypeAssignmentUpdateManyWithoutCaseTypeNestedInput = {
    create?: XOR<CaseTypeAssignmentCreateWithoutCaseTypeInput, CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput> | CaseTypeAssignmentCreateWithoutCaseTypeInput[] | CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput[]
    connectOrCreate?: CaseTypeAssignmentCreateOrConnectWithoutCaseTypeInput | CaseTypeAssignmentCreateOrConnectWithoutCaseTypeInput[]
    upsert?: CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseTypeInput | CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseTypeInput[]
    createMany?: CaseTypeAssignmentCreateManyCaseTypeInputEnvelope
    set?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    disconnect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    delete?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    connect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    update?: CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseTypeInput | CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseTypeInput[]
    updateMany?: CaseTypeAssignmentUpdateManyWithWhereWithoutCaseTypeInput | CaseTypeAssignmentUpdateManyWithWhereWithoutCaseTypeInput[]
    deleteMany?: CaseTypeAssignmentScalarWhereInput | CaseTypeAssignmentScalarWhereInput[]
  }

  export type CaseTypeAssignmentUncheckedUpdateManyWithoutCaseTypeNestedInput = {
    create?: XOR<CaseTypeAssignmentCreateWithoutCaseTypeInput, CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput> | CaseTypeAssignmentCreateWithoutCaseTypeInput[] | CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput[]
    connectOrCreate?: CaseTypeAssignmentCreateOrConnectWithoutCaseTypeInput | CaseTypeAssignmentCreateOrConnectWithoutCaseTypeInput[]
    upsert?: CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseTypeInput | CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseTypeInput[]
    createMany?: CaseTypeAssignmentCreateManyCaseTypeInputEnvelope
    set?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    disconnect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    delete?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    connect?: CaseTypeAssignmentWhereUniqueInput | CaseTypeAssignmentWhereUniqueInput[]
    update?: CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseTypeInput | CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseTypeInput[]
    updateMany?: CaseTypeAssignmentUpdateManyWithWhereWithoutCaseTypeInput | CaseTypeAssignmentUpdateManyWithWhereWithoutCaseTypeInput[]
    deleteMany?: CaseTypeAssignmentScalarWhereInput | CaseTypeAssignmentScalarWhereInput[]
  }

  export type AssuranceCaseCreateNestedOneWithoutCaseTypesInput = {
    create?: XOR<AssuranceCaseCreateWithoutCaseTypesInput, AssuranceCaseUncheckedCreateWithoutCaseTypesInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCaseTypesInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type CaseTypeCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<CaseTypeCreateWithoutAssignmentsInput, CaseTypeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: CaseTypeCreateOrConnectWithoutAssignmentsInput
    connect?: CaseTypeWhereUniqueInput
  }

  export type AssuranceCaseUpdateOneRequiredWithoutCaseTypesNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutCaseTypesInput, AssuranceCaseUncheckedCreateWithoutCaseTypesInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutCaseTypesInput
    upsert?: AssuranceCaseUpsertWithoutCaseTypesInput
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutCaseTypesInput, AssuranceCaseUpdateWithoutCaseTypesInput>, AssuranceCaseUncheckedUpdateWithoutCaseTypesInput>
  }

  export type CaseTypeUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<CaseTypeCreateWithoutAssignmentsInput, CaseTypeUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: CaseTypeCreateOrConnectWithoutAssignmentsInput
    upsert?: CaseTypeUpsertWithoutAssignmentsInput
    connect?: CaseTypeWhereUniqueInput
    update?: XOR<XOR<CaseTypeUpdateToOneWithWhereWithoutAssignmentsInput, CaseTypeUpdateWithoutAssignmentsInput>, CaseTypeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type UserCreateNestedOneWithoutGithubRepositoriesInput = {
    create?: XOR<UserCreateWithoutGithubRepositoriesInput, UserUncheckedCreateWithoutGithubRepositoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGithubRepositoriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutGithubRepositoriesNestedInput = {
    create?: XOR<UserCreateWithoutGithubRepositoriesInput, UserUncheckedCreateWithoutGithubRepositoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGithubRepositoriesInput
    upsert?: UserUpsertWithoutGithubRepositoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGithubRepositoriesInput, UserUpdateWithoutGithubRepositoriesInput>, UserUncheckedUpdateWithoutGithubRepositoriesInput>
  }

  export type UserCreateNestedOneWithoutCaseStudiesInput = {
    create?: XOR<UserCreateWithoutCaseStudiesInput, UserUncheckedCreateWithoutCaseStudiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCaseStudiesInput
    connect?: UserWhereUniqueInput
  }

  export type CaseStudyPublishedCaseCreateNestedManyWithoutCaseStudyInput = {
    create?: XOR<CaseStudyPublishedCaseCreateWithoutCaseStudyInput, CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput> | CaseStudyPublishedCaseCreateWithoutCaseStudyInput[] | CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput[]
    connectOrCreate?: CaseStudyPublishedCaseCreateOrConnectWithoutCaseStudyInput | CaseStudyPublishedCaseCreateOrConnectWithoutCaseStudyInput[]
    createMany?: CaseStudyPublishedCaseCreateManyCaseStudyInputEnvelope
    connect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
  }

  export type CaseStudyImageCreateNestedOneWithoutCaseStudyInput = {
    create?: XOR<CaseStudyImageCreateWithoutCaseStudyInput, CaseStudyImageUncheckedCreateWithoutCaseStudyInput>
    connectOrCreate?: CaseStudyImageCreateOrConnectWithoutCaseStudyInput
    connect?: CaseStudyImageWhereUniqueInput
  }

  export type CaseStudyPublishedCaseUncheckedCreateNestedManyWithoutCaseStudyInput = {
    create?: XOR<CaseStudyPublishedCaseCreateWithoutCaseStudyInput, CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput> | CaseStudyPublishedCaseCreateWithoutCaseStudyInput[] | CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput[]
    connectOrCreate?: CaseStudyPublishedCaseCreateOrConnectWithoutCaseStudyInput | CaseStudyPublishedCaseCreateOrConnectWithoutCaseStudyInput[]
    createMany?: CaseStudyPublishedCaseCreateManyCaseStudyInputEnvelope
    connect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
  }

  export type CaseStudyImageUncheckedCreateNestedOneWithoutCaseStudyInput = {
    create?: XOR<CaseStudyImageCreateWithoutCaseStudyInput, CaseStudyImageUncheckedCreateWithoutCaseStudyInput>
    connectOrCreate?: CaseStudyImageCreateOrConnectWithoutCaseStudyInput
    connect?: CaseStudyImageWhereUniqueInput
  }

  export type UserUpdateOneWithoutCaseStudiesNestedInput = {
    create?: XOR<UserCreateWithoutCaseStudiesInput, UserUncheckedCreateWithoutCaseStudiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCaseStudiesInput
    upsert?: UserUpsertWithoutCaseStudiesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCaseStudiesInput, UserUpdateWithoutCaseStudiesInput>, UserUncheckedUpdateWithoutCaseStudiesInput>
  }

  export type CaseStudyPublishedCaseUpdateManyWithoutCaseStudyNestedInput = {
    create?: XOR<CaseStudyPublishedCaseCreateWithoutCaseStudyInput, CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput> | CaseStudyPublishedCaseCreateWithoutCaseStudyInput[] | CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput[]
    connectOrCreate?: CaseStudyPublishedCaseCreateOrConnectWithoutCaseStudyInput | CaseStudyPublishedCaseCreateOrConnectWithoutCaseStudyInput[]
    upsert?: CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutCaseStudyInput | CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutCaseStudyInput[]
    createMany?: CaseStudyPublishedCaseCreateManyCaseStudyInputEnvelope
    set?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    disconnect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    delete?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    connect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    update?: CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutCaseStudyInput | CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutCaseStudyInput[]
    updateMany?: CaseStudyPublishedCaseUpdateManyWithWhereWithoutCaseStudyInput | CaseStudyPublishedCaseUpdateManyWithWhereWithoutCaseStudyInput[]
    deleteMany?: CaseStudyPublishedCaseScalarWhereInput | CaseStudyPublishedCaseScalarWhereInput[]
  }

  export type CaseStudyImageUpdateOneWithoutCaseStudyNestedInput = {
    create?: XOR<CaseStudyImageCreateWithoutCaseStudyInput, CaseStudyImageUncheckedCreateWithoutCaseStudyInput>
    connectOrCreate?: CaseStudyImageCreateOrConnectWithoutCaseStudyInput
    upsert?: CaseStudyImageUpsertWithoutCaseStudyInput
    disconnect?: CaseStudyImageWhereInput | boolean
    delete?: CaseStudyImageWhereInput | boolean
    connect?: CaseStudyImageWhereUniqueInput
    update?: XOR<XOR<CaseStudyImageUpdateToOneWithWhereWithoutCaseStudyInput, CaseStudyImageUpdateWithoutCaseStudyInput>, CaseStudyImageUncheckedUpdateWithoutCaseStudyInput>
  }

  export type CaseStudyPublishedCaseUncheckedUpdateManyWithoutCaseStudyNestedInput = {
    create?: XOR<CaseStudyPublishedCaseCreateWithoutCaseStudyInput, CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput> | CaseStudyPublishedCaseCreateWithoutCaseStudyInput[] | CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput[]
    connectOrCreate?: CaseStudyPublishedCaseCreateOrConnectWithoutCaseStudyInput | CaseStudyPublishedCaseCreateOrConnectWithoutCaseStudyInput[]
    upsert?: CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutCaseStudyInput | CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutCaseStudyInput[]
    createMany?: CaseStudyPublishedCaseCreateManyCaseStudyInputEnvelope
    set?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    disconnect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    delete?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    connect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    update?: CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutCaseStudyInput | CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutCaseStudyInput[]
    updateMany?: CaseStudyPublishedCaseUpdateManyWithWhereWithoutCaseStudyInput | CaseStudyPublishedCaseUpdateManyWithWhereWithoutCaseStudyInput[]
    deleteMany?: CaseStudyPublishedCaseScalarWhereInput | CaseStudyPublishedCaseScalarWhereInput[]
  }

  export type CaseStudyImageUncheckedUpdateOneWithoutCaseStudyNestedInput = {
    create?: XOR<CaseStudyImageCreateWithoutCaseStudyInput, CaseStudyImageUncheckedCreateWithoutCaseStudyInput>
    connectOrCreate?: CaseStudyImageCreateOrConnectWithoutCaseStudyInput
    upsert?: CaseStudyImageUpsertWithoutCaseStudyInput
    disconnect?: CaseStudyImageWhereInput | boolean
    delete?: CaseStudyImageWhereInput | boolean
    connect?: CaseStudyImageWhereUniqueInput
    update?: XOR<XOR<CaseStudyImageUpdateToOneWithWhereWithoutCaseStudyInput, CaseStudyImageUpdateWithoutCaseStudyInput>, CaseStudyImageUncheckedUpdateWithoutCaseStudyInput>
  }

  export type CaseStudyCreateNestedOneWithoutPublishedCasesInput = {
    create?: XOR<CaseStudyCreateWithoutPublishedCasesInput, CaseStudyUncheckedCreateWithoutPublishedCasesInput>
    connectOrCreate?: CaseStudyCreateOrConnectWithoutPublishedCasesInput
    connect?: CaseStudyWhereUniqueInput
  }

  export type PublishedAssuranceCaseCreateNestedOneWithoutCaseStudyLinksInput = {
    create?: XOR<PublishedAssuranceCaseCreateWithoutCaseStudyLinksInput, PublishedAssuranceCaseUncheckedCreateWithoutCaseStudyLinksInput>
    connectOrCreate?: PublishedAssuranceCaseCreateOrConnectWithoutCaseStudyLinksInput
    connect?: PublishedAssuranceCaseWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type CaseStudyUpdateOneRequiredWithoutPublishedCasesNestedInput = {
    create?: XOR<CaseStudyCreateWithoutPublishedCasesInput, CaseStudyUncheckedCreateWithoutPublishedCasesInput>
    connectOrCreate?: CaseStudyCreateOrConnectWithoutPublishedCasesInput
    upsert?: CaseStudyUpsertWithoutPublishedCasesInput
    connect?: CaseStudyWhereUniqueInput
    update?: XOR<XOR<CaseStudyUpdateToOneWithWhereWithoutPublishedCasesInput, CaseStudyUpdateWithoutPublishedCasesInput>, CaseStudyUncheckedUpdateWithoutPublishedCasesInput>
  }

  export type PublishedAssuranceCaseUpdateOneRequiredWithoutCaseStudyLinksNestedInput = {
    create?: XOR<PublishedAssuranceCaseCreateWithoutCaseStudyLinksInput, PublishedAssuranceCaseUncheckedCreateWithoutCaseStudyLinksInput>
    connectOrCreate?: PublishedAssuranceCaseCreateOrConnectWithoutCaseStudyLinksInput
    upsert?: PublishedAssuranceCaseUpsertWithoutCaseStudyLinksInput
    connect?: PublishedAssuranceCaseWhereUniqueInput
    update?: XOR<XOR<PublishedAssuranceCaseUpdateToOneWithWhereWithoutCaseStudyLinksInput, PublishedAssuranceCaseUpdateWithoutCaseStudyLinksInput>, PublishedAssuranceCaseUncheckedUpdateWithoutCaseStudyLinksInput>
  }

  export type CaseStudyCreateNestedOneWithoutFeatureImageInput = {
    create?: XOR<CaseStudyCreateWithoutFeatureImageInput, CaseStudyUncheckedCreateWithoutFeatureImageInput>
    connectOrCreate?: CaseStudyCreateOrConnectWithoutFeatureImageInput
    connect?: CaseStudyWhereUniqueInput
  }

  export type CaseStudyUpdateOneRequiredWithoutFeatureImageNestedInput = {
    create?: XOR<CaseStudyCreateWithoutFeatureImageInput, CaseStudyUncheckedCreateWithoutFeatureImageInput>
    connectOrCreate?: CaseStudyCreateOrConnectWithoutFeatureImageInput
    upsert?: CaseStudyUpsertWithoutFeatureImageInput
    connect?: CaseStudyWhereUniqueInput
    update?: XOR<XOR<CaseStudyUpdateToOneWithWhereWithoutFeatureImageInput, CaseStudyUpdateWithoutFeatureImageInput>, CaseStudyUncheckedUpdateWithoutFeatureImageInput>
  }

  export type AssuranceCaseCreateNestedOneWithoutPublishedVersionsInput = {
    create?: XOR<AssuranceCaseCreateWithoutPublishedVersionsInput, AssuranceCaseUncheckedCreateWithoutPublishedVersionsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutPublishedVersionsInput
    connect?: AssuranceCaseWhereUniqueInput
  }

  export type CaseStudyPublishedCaseCreateNestedManyWithoutPublishedAssuranceCaseInput = {
    create?: XOR<CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput, CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput> | CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput[] | CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput[]
    connectOrCreate?: CaseStudyPublishedCaseCreateOrConnectWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseCreateOrConnectWithoutPublishedAssuranceCaseInput[]
    createMany?: CaseStudyPublishedCaseCreateManyPublishedAssuranceCaseInputEnvelope
    connect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
  }

  export type CaseStudyPublishedCaseUncheckedCreateNestedManyWithoutPublishedAssuranceCaseInput = {
    create?: XOR<CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput, CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput> | CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput[] | CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput[]
    connectOrCreate?: CaseStudyPublishedCaseCreateOrConnectWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseCreateOrConnectWithoutPublishedAssuranceCaseInput[]
    createMany?: CaseStudyPublishedCaseCreateManyPublishedAssuranceCaseInputEnvelope
    connect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
  }

  export type AssuranceCaseUpdateOneRequiredWithoutPublishedVersionsNestedInput = {
    create?: XOR<AssuranceCaseCreateWithoutPublishedVersionsInput, AssuranceCaseUncheckedCreateWithoutPublishedVersionsInput>
    connectOrCreate?: AssuranceCaseCreateOrConnectWithoutPublishedVersionsInput
    upsert?: AssuranceCaseUpsertWithoutPublishedVersionsInput
    connect?: AssuranceCaseWhereUniqueInput
    update?: XOR<XOR<AssuranceCaseUpdateToOneWithWhereWithoutPublishedVersionsInput, AssuranceCaseUpdateWithoutPublishedVersionsInput>, AssuranceCaseUncheckedUpdateWithoutPublishedVersionsInput>
  }

  export type CaseStudyPublishedCaseUpdateManyWithoutPublishedAssuranceCaseNestedInput = {
    create?: XOR<CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput, CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput> | CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput[] | CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput[]
    connectOrCreate?: CaseStudyPublishedCaseCreateOrConnectWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseCreateOrConnectWithoutPublishedAssuranceCaseInput[]
    upsert?: CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutPublishedAssuranceCaseInput[]
    createMany?: CaseStudyPublishedCaseCreateManyPublishedAssuranceCaseInputEnvelope
    set?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    disconnect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    delete?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    connect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    update?: CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutPublishedAssuranceCaseInput[]
    updateMany?: CaseStudyPublishedCaseUpdateManyWithWhereWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseUpdateManyWithWhereWithoutPublishedAssuranceCaseInput[]
    deleteMany?: CaseStudyPublishedCaseScalarWhereInput | CaseStudyPublishedCaseScalarWhereInput[]
  }

  export type CaseStudyPublishedCaseUncheckedUpdateManyWithoutPublishedAssuranceCaseNestedInput = {
    create?: XOR<CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput, CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput> | CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput[] | CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput[]
    connectOrCreate?: CaseStudyPublishedCaseCreateOrConnectWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseCreateOrConnectWithoutPublishedAssuranceCaseInput[]
    upsert?: CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutPublishedAssuranceCaseInput[]
    createMany?: CaseStudyPublishedCaseCreateManyPublishedAssuranceCaseInputEnvelope
    set?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    disconnect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    delete?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    connect?: CaseStudyPublishedCaseWhereUniqueInput | CaseStudyPublishedCaseWhereUniqueInput[]
    update?: CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutPublishedAssuranceCaseInput[]
    updateMany?: CaseStudyPublishedCaseUpdateManyWithWhereWithoutPublishedAssuranceCaseInput | CaseStudyPublishedCaseUpdateManyWithWhereWithoutPublishedAssuranceCaseInput[]
    deleteMany?: CaseStudyPublishedCaseScalarWhereInput | CaseStudyPublishedCaseScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumCaseModeFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseMode | EnumCaseModeFieldRefInput<$PrismaModel>
    in?: $Enums.CaseMode[] | ListEnumCaseModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseMode[] | ListEnumCaseModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseModeFilter<$PrismaModel> | $Enums.CaseMode
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProvider[] | ListEnumAuthProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel> | $Enums.AuthProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCaseModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseMode | EnumCaseModeFieldRefInput<$PrismaModel>
    in?: $Enums.CaseMode[] | ListEnumCaseModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseMode[] | ListEnumCaseModeFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseModeWithAggregatesFilter<$PrismaModel> | $Enums.CaseMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaseModeFilter<$PrismaModel>
    _max?: NestedEnumCaseModeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTeamRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleFilter<$PrismaModel> | $Enums.TeamRole
  }

  export type NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamRole | EnumTeamRoleFieldRefInput<$PrismaModel>
    in?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.TeamRole[] | ListEnumTeamRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumTeamRoleWithAggregatesFilter<$PrismaModel> | $Enums.TeamRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamRoleFilter<$PrismaModel>
    _max?: NestedEnumTeamRoleFilter<$PrismaModel>
  }

  export type NestedEnumPublishStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusFilter<$PrismaModel> | $Enums.PublishStatus
  }

  export type NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PublishStatus | EnumPublishStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PublishStatus[] | ListEnumPublishStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPublishStatusWithAggregatesFilter<$PrismaModel> | $Enums.PublishStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPublishStatusFilter<$PrismaModel>
    _max?: NestedEnumPublishStatusFilter<$PrismaModel>
  }

  export type NestedEnumPermissionLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionLevel | EnumPermissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionLevelFilter<$PrismaModel> | $Enums.PermissionLevel
  }

  export type NestedEnumPermissionLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionLevel | EnumPermissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionLevelWithAggregatesFilter<$PrismaModel> | $Enums.PermissionLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionLevelFilter<$PrismaModel>
    _max?: NestedEnumPermissionLevelFilter<$PrismaModel>
  }

  export type NestedEnumElementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeFilter<$PrismaModel> | $Enums.ElementType
  }

  export type NestedEnumElementRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementRole | EnumElementRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.ElementRole[] | ListEnumElementRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ElementRole[] | ListEnumElementRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumElementRoleNullableFilter<$PrismaModel> | $Enums.ElementRole | null
  }

  export type NestedEnumModuleEmbedTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ModuleEmbedType | EnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ModuleEmbedType[] | ListEnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ModuleEmbedType[] | ListEnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumModuleEmbedTypeNullableFilter<$PrismaModel> | $Enums.ModuleEmbedType | null
  }

  export type NestedEnumElementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ElementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumElementTypeFilter<$PrismaModel>
    _max?: NestedEnumElementTypeFilter<$PrismaModel>
  }

  export type NestedEnumElementRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementRole | EnumElementRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.ElementRole[] | ListEnumElementRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ElementRole[] | ListEnumElementRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumElementRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.ElementRole | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumElementRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumElementRoleNullableFilter<$PrismaModel>
  }

  export type NestedEnumModuleEmbedTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModuleEmbedType | EnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ModuleEmbedType[] | ListEnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ModuleEmbedType[] | ListEnumModuleEmbedTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumModuleEmbedTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ModuleEmbedType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumModuleEmbedTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumModuleEmbedTypeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumReleaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReleaseStatus | EnumReleaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReleaseStatus[] | ListEnumReleaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReleaseStatus[] | ListEnumReleaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReleaseStatusFilter<$PrismaModel> | $Enums.ReleaseStatus
  }

  export type NestedEnumReleaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReleaseStatus | EnumReleaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReleaseStatus[] | ListEnumReleaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReleaseStatus[] | ListEnumReleaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReleaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReleaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReleaseStatusFilter<$PrismaModel>
    _max?: NestedEnumReleaseStatusFilter<$PrismaModel>
  }

  export type NestedEnumSnapshotReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotReason | EnumSnapshotReasonFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotReason[] | ListEnumSnapshotReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotReason[] | ListEnumSnapshotReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotReasonFilter<$PrismaModel> | $Enums.SnapshotReason
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSnapshotReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotReason | EnumSnapshotReasonFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotReason[] | ListEnumSnapshotReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotReason[] | ListEnumSnapshotReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotReasonWithAggregatesFilter<$PrismaModel> | $Enums.SnapshotReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnapshotReasonFilter<$PrismaModel>
    _max?: NestedEnumSnapshotReasonFilter<$PrismaModel>
  }

  export type NestedEnumCommentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusFilter<$PrismaModel> | $Enums.CommentStatus
  }

  export type NestedEnumCommentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommentStatus | EnumCommentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommentStatus[] | ListEnumCommentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCommentStatusWithAggregatesFilter<$PrismaModel> | $Enums.CommentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommentStatusFilter<$PrismaModel>
    _max?: NestedEnumCommentStatusFilter<$PrismaModel>
  }

  export type NestedEnumCaseTypeCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseTypeCategory | EnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CaseTypeCategory[] | ListEnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseTypeCategory[] | ListEnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseTypeCategoryFilter<$PrismaModel> | $Enums.CaseTypeCategory
  }

  export type NestedEnumCaseTypeCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CaseTypeCategory | EnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.CaseTypeCategory[] | ListEnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.CaseTypeCategory[] | ListEnumCaseTypeCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCaseTypeCategoryWithAggregatesFilter<$PrismaModel> | $Enums.CaseTypeCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCaseTypeCategoryFilter<$PrismaModel>
    _max?: NestedEnumCaseTypeCategoryFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type TeamMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.TeamRole
    invitedById?: string | null
    joinedAt?: Date | string
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    role?: $Enums.TeamRole
    invitedById?: string | null
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutCreatedByInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    casePermissions?: CaseTeamPermissionCreateNestedManyWithoutTeamInput
    patternPermissions?: PatternTeamPermissionCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    casePermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutTeamInput
    patternPermissions?: PatternTeamPermissionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCreatedByInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput>
  }

  export type TeamCreateManyCreatedByInputEnvelope = {
    data: TeamCreateManyCreatedByInput | TeamCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceCaseCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutCreatedByInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutCreatedByInput, AssuranceCaseUncheckedCreateWithoutCreatedByInput>
  }

  export type AssuranceCaseCreateManyCreatedByInputEnvelope = {
    data: AssuranceCaseCreateManyCreatedByInput | AssuranceCaseCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CasePermissionCreateWithoutUserInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutUserPermissionsInput
    grantedBy: UserCreateNestedOneWithoutGrantedPermissionsInput
  }

  export type CasePermissionUncheckedCreateWithoutUserInput = {
    id?: string
    caseId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CasePermissionCreateOrConnectWithoutUserInput = {
    where: CasePermissionWhereUniqueInput
    create: XOR<CasePermissionCreateWithoutUserInput, CasePermissionUncheckedCreateWithoutUserInput>
  }

  export type CasePermissionCreateManyUserInputEnvelope = {
    data: CasePermissionCreateManyUserInput | CasePermissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CasePermissionCreateWithoutGrantedByInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutUserPermissionsInput
    user: UserCreateNestedOneWithoutCasePermissionsInput
  }

  export type CasePermissionUncheckedCreateWithoutGrantedByInput = {
    id?: string
    caseId: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedAt?: Date | string
  }

  export type CasePermissionCreateOrConnectWithoutGrantedByInput = {
    where: CasePermissionWhereUniqueInput
    create: XOR<CasePermissionCreateWithoutGrantedByInput, CasePermissionUncheckedCreateWithoutGrantedByInput>
  }

  export type CasePermissionCreateManyGrantedByInputEnvelope = {
    data: CasePermissionCreateManyGrantedByInput | CasePermissionCreateManyGrantedByInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceElementCreateWithoutCreatedByInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutCreatedByInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutCreatedByInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutCreatedByInput, AssuranceElementUncheckedCreateWithoutCreatedByInput>
  }

  export type AssuranceElementCreateManyCreatedByInputEnvelope = {
    data: AssuranceElementCreateManyCreatedByInput | AssuranceElementCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case?: AssuranceCaseCreateNestedOneWithoutCommentsInput
    element?: AssuranceElementCreateNestedOneWithoutCommentsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    caseId?: string | null
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutResolvedByInput = {
    id?: string
    content: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case?: AssuranceCaseCreateNestedOneWithoutCommentsInput
    element?: AssuranceElementCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutAuthoredCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
  }

  export type CommentUncheckedCreateWithoutResolvedByInput = {
    id?: string
    caseId?: string | null
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type CommentCreateOrConnectWithoutResolvedByInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutResolvedByInput, CommentUncheckedCreateWithoutResolvedByInput>
  }

  export type CommentCreateManyResolvedByInputEnvelope = {
    data: CommentCreateManyResolvedByInput | CommentCreateManyResolvedByInput[]
    skipDuplicates?: boolean
  }

  export type ReleaseCommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    release: ReleaseCreateNestedOneWithoutCommentsInput
    element?: AssuranceElementCreateNestedOneWithoutReleaseCommentsInput
    parentComment?: ReleaseCommentCreateNestedOneWithoutRepliesInput
    replies?: ReleaseCommentCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    releaseId: string
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReleaseCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentCreateOrConnectWithoutAuthorInput = {
    where: ReleaseCommentWhereUniqueInput
    create: XOR<ReleaseCommentCreateWithoutAuthorInput, ReleaseCommentUncheckedCreateWithoutAuthorInput>
  }

  export type ReleaseCommentCreateManyAuthorInputEnvelope = {
    data: ReleaseCommentCreateManyAuthorInput | ReleaseCommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type GitHubRepositoryCreateWithoutUserInput = {
    id?: string
    name: string
    url: string
    description?: string | null
    githubId?: string | null
    defaultBranch?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GitHubRepositoryUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    url: string
    description?: string | null
    githubId?: string | null
    defaultBranch?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GitHubRepositoryCreateOrConnectWithoutUserInput = {
    where: GitHubRepositoryWhereUniqueInput
    create: XOR<GitHubRepositoryCreateWithoutUserInput, GitHubRepositoryUncheckedCreateWithoutUserInput>
  }

  export type GitHubRepositoryCreateManyUserInputEnvelope = {
    data: GitHubRepositoryCreateManyUserInput | GitHubRepositoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CaseStudyCreateWithoutOwnerInput = {
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    type?: string | null
    publishedCases?: CaseStudyPublishedCaseCreateNestedManyWithoutCaseStudyInput
    featureImage?: CaseStudyImageCreateNestedOneWithoutCaseStudyInput
  }

  export type CaseStudyUncheckedCreateWithoutOwnerInput = {
    id?: number
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    type?: string | null
    publishedCases?: CaseStudyPublishedCaseUncheckedCreateNestedManyWithoutCaseStudyInput
    featureImage?: CaseStudyImageUncheckedCreateNestedOneWithoutCaseStudyInput
  }

  export type CaseStudyCreateOrConnectWithoutOwnerInput = {
    where: CaseStudyWhereUniqueInput
    create: XOR<CaseStudyCreateWithoutOwnerInput, CaseStudyUncheckedCreateWithoutOwnerInput>
  }

  export type CaseStudyCreateManyOwnerInputEnvelope = {
    data: CaseStudyCreateManyOwnerInput | CaseStudyCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceCaseCreateWithoutMarkedReadyByInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutMarkedReadyByInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutMarkedReadyByInput, AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput>
  }

  export type AssuranceCaseCreateManyMarkedReadyByInputEnvelope = {
    data: AssuranceCaseCreateManyMarkedReadyByInput | AssuranceCaseCreateManyMarkedReadyByInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    role?: EnumTeamRoleFilter<"TeamMember"> | $Enums.TeamRole
    invitedById?: StringNullableFilter<"TeamMember"> | string | null
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
  }

  export type TeamUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutCreatedByInput, TeamUncheckedUpdateWithoutCreatedByInput>
    create: XOR<TeamCreateWithoutCreatedByInput, TeamUncheckedCreateWithoutCreatedByInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutCreatedByInput, TeamUncheckedUpdateWithoutCreatedByInput>
  }

  export type TeamUpdateManyWithWhereWithoutCreatedByInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    slug?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    organisationId?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    createdById?: StringFilter<"Team"> | string
  }

  export type AssuranceCaseUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AssuranceCaseWhereUniqueInput
    update: XOR<AssuranceCaseUpdateWithoutCreatedByInput, AssuranceCaseUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AssuranceCaseCreateWithoutCreatedByInput, AssuranceCaseUncheckedCreateWithoutCreatedByInput>
  }

  export type AssuranceCaseUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AssuranceCaseWhereUniqueInput
    data: XOR<AssuranceCaseUpdateWithoutCreatedByInput, AssuranceCaseUncheckedUpdateWithoutCreatedByInput>
  }

  export type AssuranceCaseUpdateManyWithWhereWithoutCreatedByInput = {
    where: AssuranceCaseScalarWhereInput
    data: XOR<AssuranceCaseUpdateManyMutationInput, AssuranceCaseUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AssuranceCaseScalarWhereInput = {
    AND?: AssuranceCaseScalarWhereInput | AssuranceCaseScalarWhereInput[]
    OR?: AssuranceCaseScalarWhereInput[]
    NOT?: AssuranceCaseScalarWhereInput | AssuranceCaseScalarWhereInput[]
    id?: StringFilter<"AssuranceCase"> | string
    name?: StringFilter<"AssuranceCase"> | string
    description?: StringFilter<"AssuranceCase"> | string
    createdById?: StringFilter<"AssuranceCase"> | string
    mode?: EnumCaseModeFilter<"AssuranceCase"> | $Enums.CaseMode
    colorProfile?: StringFilter<"AssuranceCase"> | string
    lockUuid?: StringNullableFilter<"AssuranceCase"> | string | null
    lockedById?: StringNullableFilter<"AssuranceCase"> | string | null
    lockedAt?: DateTimeNullableFilter<"AssuranceCase"> | Date | string | null
    sourcePatternId?: StringNullableFilter<"AssuranceCase"> | string | null
    createdAt?: DateTimeFilter<"AssuranceCase"> | Date | string
    updatedAt?: DateTimeFilter<"AssuranceCase"> | Date | string
    published?: BoolFilter<"AssuranceCase"> | boolean
    publishedAt?: DateTimeNullableFilter<"AssuranceCase"> | Date | string | null
    publishStatus?: EnumPublishStatusFilter<"AssuranceCase"> | $Enums.PublishStatus
    markedReadyAt?: DateTimeNullableFilter<"AssuranceCase"> | Date | string | null
    markedReadyById?: StringNullableFilter<"AssuranceCase"> | string | null
  }

  export type CasePermissionUpsertWithWhereUniqueWithoutUserInput = {
    where: CasePermissionWhereUniqueInput
    update: XOR<CasePermissionUpdateWithoutUserInput, CasePermissionUncheckedUpdateWithoutUserInput>
    create: XOR<CasePermissionCreateWithoutUserInput, CasePermissionUncheckedCreateWithoutUserInput>
  }

  export type CasePermissionUpdateWithWhereUniqueWithoutUserInput = {
    where: CasePermissionWhereUniqueInput
    data: XOR<CasePermissionUpdateWithoutUserInput, CasePermissionUncheckedUpdateWithoutUserInput>
  }

  export type CasePermissionUpdateManyWithWhereWithoutUserInput = {
    where: CasePermissionScalarWhereInput
    data: XOR<CasePermissionUpdateManyMutationInput, CasePermissionUncheckedUpdateManyWithoutUserInput>
  }

  export type CasePermissionScalarWhereInput = {
    AND?: CasePermissionScalarWhereInput | CasePermissionScalarWhereInput[]
    OR?: CasePermissionScalarWhereInput[]
    NOT?: CasePermissionScalarWhereInput | CasePermissionScalarWhereInput[]
    id?: StringFilter<"CasePermission"> | string
    caseId?: StringFilter<"CasePermission"> | string
    userId?: StringFilter<"CasePermission"> | string
    permission?: EnumPermissionLevelFilter<"CasePermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"CasePermission"> | string
    grantedAt?: DateTimeFilter<"CasePermission"> | Date | string
  }

  export type CasePermissionUpsertWithWhereUniqueWithoutGrantedByInput = {
    where: CasePermissionWhereUniqueInput
    update: XOR<CasePermissionUpdateWithoutGrantedByInput, CasePermissionUncheckedUpdateWithoutGrantedByInput>
    create: XOR<CasePermissionCreateWithoutGrantedByInput, CasePermissionUncheckedCreateWithoutGrantedByInput>
  }

  export type CasePermissionUpdateWithWhereUniqueWithoutGrantedByInput = {
    where: CasePermissionWhereUniqueInput
    data: XOR<CasePermissionUpdateWithoutGrantedByInput, CasePermissionUncheckedUpdateWithoutGrantedByInput>
  }

  export type CasePermissionUpdateManyWithWhereWithoutGrantedByInput = {
    where: CasePermissionScalarWhereInput
    data: XOR<CasePermissionUpdateManyMutationInput, CasePermissionUncheckedUpdateManyWithoutGrantedByInput>
  }

  export type AssuranceElementUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AssuranceElementWhereUniqueInput
    update: XOR<AssuranceElementUpdateWithoutCreatedByInput, AssuranceElementUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AssuranceElementCreateWithoutCreatedByInput, AssuranceElementUncheckedCreateWithoutCreatedByInput>
  }

  export type AssuranceElementUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AssuranceElementWhereUniqueInput
    data: XOR<AssuranceElementUpdateWithoutCreatedByInput, AssuranceElementUncheckedUpdateWithoutCreatedByInput>
  }

  export type AssuranceElementUpdateManyWithWhereWithoutCreatedByInput = {
    where: AssuranceElementScalarWhereInput
    data: XOR<AssuranceElementUpdateManyMutationInput, AssuranceElementUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AssuranceElementScalarWhereInput = {
    AND?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
    OR?: AssuranceElementScalarWhereInput[]
    NOT?: AssuranceElementScalarWhereInput | AssuranceElementScalarWhereInput[]
    id?: StringFilter<"AssuranceElement"> | string
    caseId?: StringFilter<"AssuranceElement"> | string
    elementType?: EnumElementTypeFilter<"AssuranceElement"> | $Enums.ElementType
    role?: EnumElementRoleNullableFilter<"AssuranceElement"> | $Enums.ElementRole | null
    parentId?: StringNullableFilter<"AssuranceElement"> | string | null
    name?: StringNullableFilter<"AssuranceElement"> | string | null
    description?: StringFilter<"AssuranceElement"> | string
    assumption?: StringNullableFilter<"AssuranceElement"> | string | null
    justification?: StringNullableFilter<"AssuranceElement"> | string | null
    url?: StringNullableFilter<"AssuranceElement"> | string | null
    moduleReferenceId?: StringNullableFilter<"AssuranceElement"> | string | null
    moduleEmbedType?: EnumModuleEmbedTypeNullableFilter<"AssuranceElement"> | $Enums.ModuleEmbedType | null
    modulePublicSummary?: StringNullableFilter<"AssuranceElement"> | string | null
    fromPattern?: BoolFilter<"AssuranceElement"> | boolean
    modifiedFromPattern?: BoolFilter<"AssuranceElement"> | boolean
    inSandbox?: BoolFilter<"AssuranceElement"> | boolean
    isDefeater?: BoolFilter<"AssuranceElement"> | boolean
    defeatsElementId?: StringNullableFilter<"AssuranceElement"> | string | null
    level?: IntNullableFilter<"AssuranceElement"> | number | null
    createdAt?: DateTimeFilter<"AssuranceElement"> | Date | string
    updatedAt?: DateTimeFilter<"AssuranceElement"> | Date | string
    createdById?: StringFilter<"AssuranceElement"> | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    caseId?: StringNullableFilter<"Comment"> | string | null
    elementId?: StringNullableFilter<"Comment"> | string | null
    parentCommentId?: StringNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    resolved?: BoolFilter<"Comment"> | boolean
    resolvedById?: StringNullableFilter<"Comment"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Comment"> | Date | string | null
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutResolvedByInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutResolvedByInput, CommentUncheckedUpdateWithoutResolvedByInput>
    create: XOR<CommentCreateWithoutResolvedByInput, CommentUncheckedCreateWithoutResolvedByInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutResolvedByInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutResolvedByInput, CommentUncheckedUpdateWithoutResolvedByInput>
  }

  export type CommentUpdateManyWithWhereWithoutResolvedByInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutResolvedByInput>
  }

  export type ReleaseCommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ReleaseCommentWhereUniqueInput
    update: XOR<ReleaseCommentUpdateWithoutAuthorInput, ReleaseCommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<ReleaseCommentCreateWithoutAuthorInput, ReleaseCommentUncheckedCreateWithoutAuthorInput>
  }

  export type ReleaseCommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ReleaseCommentWhereUniqueInput
    data: XOR<ReleaseCommentUpdateWithoutAuthorInput, ReleaseCommentUncheckedUpdateWithoutAuthorInput>
  }

  export type ReleaseCommentUpdateManyWithWhereWithoutAuthorInput = {
    where: ReleaseCommentScalarWhereInput
    data: XOR<ReleaseCommentUpdateManyMutationInput, ReleaseCommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ReleaseCommentScalarWhereInput = {
    AND?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
    OR?: ReleaseCommentScalarWhereInput[]
    NOT?: ReleaseCommentScalarWhereInput | ReleaseCommentScalarWhereInput[]
    id?: StringFilter<"ReleaseComment"> | string
    releaseId?: StringFilter<"ReleaseComment"> | string
    elementId?: StringNullableFilter<"ReleaseComment"> | string | null
    parentCommentId?: StringNullableFilter<"ReleaseComment"> | string | null
    content?: StringFilter<"ReleaseComment"> | string
    authorId?: StringFilter<"ReleaseComment"> | string
    status?: EnumCommentStatusFilter<"ReleaseComment"> | $Enums.CommentStatus
    hiddenById?: StringNullableFilter<"ReleaseComment"> | string | null
    hiddenAt?: DateTimeNullableFilter<"ReleaseComment"> | Date | string | null
    hiddenReason?: StringNullableFilter<"ReleaseComment"> | string | null
    createdAt?: DateTimeFilter<"ReleaseComment"> | Date | string
    updatedAt?: DateTimeFilter<"ReleaseComment"> | Date | string
  }

  export type GitHubRepositoryUpsertWithWhereUniqueWithoutUserInput = {
    where: GitHubRepositoryWhereUniqueInput
    update: XOR<GitHubRepositoryUpdateWithoutUserInput, GitHubRepositoryUncheckedUpdateWithoutUserInput>
    create: XOR<GitHubRepositoryCreateWithoutUserInput, GitHubRepositoryUncheckedCreateWithoutUserInput>
  }

  export type GitHubRepositoryUpdateWithWhereUniqueWithoutUserInput = {
    where: GitHubRepositoryWhereUniqueInput
    data: XOR<GitHubRepositoryUpdateWithoutUserInput, GitHubRepositoryUncheckedUpdateWithoutUserInput>
  }

  export type GitHubRepositoryUpdateManyWithWhereWithoutUserInput = {
    where: GitHubRepositoryScalarWhereInput
    data: XOR<GitHubRepositoryUpdateManyMutationInput, GitHubRepositoryUncheckedUpdateManyWithoutUserInput>
  }

  export type GitHubRepositoryScalarWhereInput = {
    AND?: GitHubRepositoryScalarWhereInput | GitHubRepositoryScalarWhereInput[]
    OR?: GitHubRepositoryScalarWhereInput[]
    NOT?: GitHubRepositoryScalarWhereInput | GitHubRepositoryScalarWhereInput[]
    id?: StringFilter<"GitHubRepository"> | string
    name?: StringFilter<"GitHubRepository"> | string
    url?: StringFilter<"GitHubRepository"> | string
    description?: StringNullableFilter<"GitHubRepository"> | string | null
    githubId?: StringNullableFilter<"GitHubRepository"> | string | null
    defaultBranch?: StringFilter<"GitHubRepository"> | string
    userId?: StringFilter<"GitHubRepository"> | string
    createdAt?: DateTimeFilter<"GitHubRepository"> | Date | string
    updatedAt?: DateTimeFilter<"GitHubRepository"> | Date | string
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    userAgent?: StringNullableFilter<"RefreshToken"> | string | null
    ipAddress?: StringNullableFilter<"RefreshToken"> | string | null
  }

  export type CaseStudyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CaseStudyWhereUniqueInput
    update: XOR<CaseStudyUpdateWithoutOwnerInput, CaseStudyUncheckedUpdateWithoutOwnerInput>
    create: XOR<CaseStudyCreateWithoutOwnerInput, CaseStudyUncheckedCreateWithoutOwnerInput>
  }

  export type CaseStudyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CaseStudyWhereUniqueInput
    data: XOR<CaseStudyUpdateWithoutOwnerInput, CaseStudyUncheckedUpdateWithoutOwnerInput>
  }

  export type CaseStudyUpdateManyWithWhereWithoutOwnerInput = {
    where: CaseStudyScalarWhereInput
    data: XOR<CaseStudyUpdateManyMutationInput, CaseStudyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type CaseStudyScalarWhereInput = {
    AND?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
    OR?: CaseStudyScalarWhereInput[]
    NOT?: CaseStudyScalarWhereInput | CaseStudyScalarWhereInput[]
    id?: IntFilter<"CaseStudy"> | number
    title?: StringFilter<"CaseStudy"> | string
    description?: StringNullableFilter<"CaseStudy"> | string | null
    authors?: StringNullableFilter<"CaseStudy"> | string | null
    category?: StringNullableFilter<"CaseStudy"> | string | null
    publishedDate?: DateTimeNullableFilter<"CaseStudy"> | Date | string | null
    lastModifiedOn?: DateTimeFilter<"CaseStudy"> | Date | string
    createdOn?: DateTimeFilter<"CaseStudy"> | Date | string
    sector?: StringNullableFilter<"CaseStudy"> | string | null
    contact?: StringNullableFilter<"CaseStudy"> | string | null
    image?: StringNullableFilter<"CaseStudy"> | string | null
    published?: BoolFilter<"CaseStudy"> | boolean
    ownerId?: StringNullableFilter<"CaseStudy"> | string | null
    type?: StringNullableFilter<"CaseStudy"> | string | null
  }

  export type AssuranceCaseUpsertWithWhereUniqueWithoutMarkedReadyByInput = {
    where: AssuranceCaseWhereUniqueInput
    update: XOR<AssuranceCaseUpdateWithoutMarkedReadyByInput, AssuranceCaseUncheckedUpdateWithoutMarkedReadyByInput>
    create: XOR<AssuranceCaseCreateWithoutMarkedReadyByInput, AssuranceCaseUncheckedCreateWithoutMarkedReadyByInput>
  }

  export type AssuranceCaseUpdateWithWhereUniqueWithoutMarkedReadyByInput = {
    where: AssuranceCaseWhereUniqueInput
    data: XOR<AssuranceCaseUpdateWithoutMarkedReadyByInput, AssuranceCaseUncheckedUpdateWithoutMarkedReadyByInput>
  }

  export type AssuranceCaseUpdateManyWithWhereWithoutMarkedReadyByInput = {
    where: AssuranceCaseScalarWhereInput
    data: XOR<AssuranceCaseUpdateManyMutationInput, AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByInput>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserCreateWithoutCreatedTeamsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutCreatedTeamsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutCreatedTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    role?: $Enums.TeamRole
    invitedById?: string | null
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    role?: $Enums.TeamRole
    invitedById?: string | null
    joinedAt?: Date | string
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type CaseTeamPermissionCreateWithoutTeamInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutTeamPermissionsInput
  }

  export type CaseTeamPermissionUncheckedCreateWithoutTeamInput = {
    id?: string
    caseId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CaseTeamPermissionCreateOrConnectWithoutTeamInput = {
    where: CaseTeamPermissionWhereUniqueInput
    create: XOR<CaseTeamPermissionCreateWithoutTeamInput, CaseTeamPermissionUncheckedCreateWithoutTeamInput>
  }

  export type CaseTeamPermissionCreateManyTeamInputEnvelope = {
    data: CaseTeamPermissionCreateManyTeamInput | CaseTeamPermissionCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type PatternTeamPermissionCreateWithoutTeamInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
    pattern: ArgumentPatternCreateNestedOneWithoutTeamPermissionsInput
  }

  export type PatternTeamPermissionUncheckedCreateWithoutTeamInput = {
    id?: string
    patternId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternTeamPermissionCreateOrConnectWithoutTeamInput = {
    where: PatternTeamPermissionWhereUniqueInput
    create: XOR<PatternTeamPermissionCreateWithoutTeamInput, PatternTeamPermissionUncheckedCreateWithoutTeamInput>
  }

  export type PatternTeamPermissionCreateManyTeamInputEnvelope = {
    data: PatternTeamPermissionCreateManyTeamInput | PatternTeamPermissionCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedTeamsInput = {
    update: XOR<UserUpdateWithoutCreatedTeamsInput, UserUncheckedUpdateWithoutCreatedTeamsInput>
    create: XOR<UserCreateWithoutCreatedTeamsInput, UserUncheckedCreateWithoutCreatedTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedTeamsInput, UserUncheckedUpdateWithoutCreatedTeamsInput>
  }

  export type UserUpdateWithoutCreatedTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type CaseTeamPermissionUpsertWithWhereUniqueWithoutTeamInput = {
    where: CaseTeamPermissionWhereUniqueInput
    update: XOR<CaseTeamPermissionUpdateWithoutTeamInput, CaseTeamPermissionUncheckedUpdateWithoutTeamInput>
    create: XOR<CaseTeamPermissionCreateWithoutTeamInput, CaseTeamPermissionUncheckedCreateWithoutTeamInput>
  }

  export type CaseTeamPermissionUpdateWithWhereUniqueWithoutTeamInput = {
    where: CaseTeamPermissionWhereUniqueInput
    data: XOR<CaseTeamPermissionUpdateWithoutTeamInput, CaseTeamPermissionUncheckedUpdateWithoutTeamInput>
  }

  export type CaseTeamPermissionUpdateManyWithWhereWithoutTeamInput = {
    where: CaseTeamPermissionScalarWhereInput
    data: XOR<CaseTeamPermissionUpdateManyMutationInput, CaseTeamPermissionUncheckedUpdateManyWithoutTeamInput>
  }

  export type CaseTeamPermissionScalarWhereInput = {
    AND?: CaseTeamPermissionScalarWhereInput | CaseTeamPermissionScalarWhereInput[]
    OR?: CaseTeamPermissionScalarWhereInput[]
    NOT?: CaseTeamPermissionScalarWhereInput | CaseTeamPermissionScalarWhereInput[]
    id?: StringFilter<"CaseTeamPermission"> | string
    caseId?: StringFilter<"CaseTeamPermission"> | string
    teamId?: StringFilter<"CaseTeamPermission"> | string
    permission?: EnumPermissionLevelFilter<"CaseTeamPermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"CaseTeamPermission"> | string
    grantedAt?: DateTimeFilter<"CaseTeamPermission"> | Date | string
  }

  export type PatternTeamPermissionUpsertWithWhereUniqueWithoutTeamInput = {
    where: PatternTeamPermissionWhereUniqueInput
    update: XOR<PatternTeamPermissionUpdateWithoutTeamInput, PatternTeamPermissionUncheckedUpdateWithoutTeamInput>
    create: XOR<PatternTeamPermissionCreateWithoutTeamInput, PatternTeamPermissionUncheckedCreateWithoutTeamInput>
  }

  export type PatternTeamPermissionUpdateWithWhereUniqueWithoutTeamInput = {
    where: PatternTeamPermissionWhereUniqueInput
    data: XOR<PatternTeamPermissionUpdateWithoutTeamInput, PatternTeamPermissionUncheckedUpdateWithoutTeamInput>
  }

  export type PatternTeamPermissionUpdateManyWithWhereWithoutTeamInput = {
    where: PatternTeamPermissionScalarWhereInput
    data: XOR<PatternTeamPermissionUpdateManyMutationInput, PatternTeamPermissionUncheckedUpdateManyWithoutTeamInput>
  }

  export type PatternTeamPermissionScalarWhereInput = {
    AND?: PatternTeamPermissionScalarWhereInput | PatternTeamPermissionScalarWhereInput[]
    OR?: PatternTeamPermissionScalarWhereInput[]
    NOT?: PatternTeamPermissionScalarWhereInput | PatternTeamPermissionScalarWhereInput[]
    id?: StringFilter<"PatternTeamPermission"> | string
    patternId?: StringFilter<"PatternTeamPermission"> | string
    teamId?: StringFilter<"PatternTeamPermission"> | string
    permission?: EnumPermissionLevelFilter<"PatternTeamPermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"PatternTeamPermission"> | string
    grantedAt?: DateTimeFilter<"PatternTeamPermission"> | Date | string
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    casePermissions?: CaseTeamPermissionCreateNestedManyWithoutTeamInput
    patternPermissions?: PatternTeamPermissionCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    casePermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutTeamInput
    patternPermissions?: PatternTeamPermissionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    casePermissions?: CaseTeamPermissionUpdateManyWithoutTeamNestedInput
    patternPermissions?: PatternTeamPermissionUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    casePermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput
    patternPermissions?: PatternTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserCreateWithoutCreatedCasesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutCreatedCasesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutCreatedCasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCasesInput, UserUncheckedCreateWithoutCreatedCasesInput>
  }

  export type UserCreateWithoutMarkedReadyCasesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutMarkedReadyCasesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutMarkedReadyCasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMarkedReadyCasesInput, UserUncheckedCreateWithoutMarkedReadyCasesInput>
  }

  export type ArgumentPatternCreateWithoutDerivedCasesInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PatternElementCreateNestedManyWithoutPatternInput
    userPermissions?: PatternPermissionCreateNestedManyWithoutPatternInput
    teamPermissions?: PatternTeamPermissionCreateNestedManyWithoutPatternInput
  }

  export type ArgumentPatternUncheckedCreateWithoutDerivedCasesInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PatternElementUncheckedCreateNestedManyWithoutPatternInput
    userPermissions?: PatternPermissionUncheckedCreateNestedManyWithoutPatternInput
    teamPermissions?: PatternTeamPermissionUncheckedCreateNestedManyWithoutPatternInput
  }

  export type ArgumentPatternCreateOrConnectWithoutDerivedCasesInput = {
    where: ArgumentPatternWhereUniqueInput
    create: XOR<ArgumentPatternCreateWithoutDerivedCasesInput, ArgumentPatternUncheckedCreateWithoutDerivedCasesInput>
  }

  export type AssuranceElementCreateWithoutCaseInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutCaseInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutCaseInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutCaseInput, AssuranceElementUncheckedCreateWithoutCaseInput>
  }

  export type AssuranceElementCreateManyCaseInputEnvelope = {
    data: AssuranceElementCreateManyCaseInput | AssuranceElementCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type CasePermissionCreateWithoutCaseInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedAt?: Date | string
    user: UserCreateNestedOneWithoutCasePermissionsInput
    grantedBy: UserCreateNestedOneWithoutGrantedPermissionsInput
  }

  export type CasePermissionUncheckedCreateWithoutCaseInput = {
    id?: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CasePermissionCreateOrConnectWithoutCaseInput = {
    where: CasePermissionWhereUniqueInput
    create: XOR<CasePermissionCreateWithoutCaseInput, CasePermissionUncheckedCreateWithoutCaseInput>
  }

  export type CasePermissionCreateManyCaseInputEnvelope = {
    data: CasePermissionCreateManyCaseInput | CasePermissionCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type CaseTeamPermissionCreateWithoutCaseInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
    team: TeamCreateNestedOneWithoutCasePermissionsInput
  }

  export type CaseTeamPermissionUncheckedCreateWithoutCaseInput = {
    id?: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CaseTeamPermissionCreateOrConnectWithoutCaseInput = {
    where: CaseTeamPermissionWhereUniqueInput
    create: XOR<CaseTeamPermissionCreateWithoutCaseInput, CaseTeamPermissionUncheckedCreateWithoutCaseInput>
  }

  export type CaseTeamPermissionCreateManyCaseInputEnvelope = {
    data: CaseTeamPermissionCreateManyCaseInput | CaseTeamPermissionCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type CaseInviteCreateWithoutCaseInput = {
    id?: string
    email: string
    permission: $Enums.PermissionLevel
    inviteToken: string
    inviteExpiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedById?: string | null
    invitedById: string
    createdAt?: Date | string
  }

  export type CaseInviteUncheckedCreateWithoutCaseInput = {
    id?: string
    email: string
    permission: $Enums.PermissionLevel
    inviteToken: string
    inviteExpiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedById?: string | null
    invitedById: string
    createdAt?: Date | string
  }

  export type CaseInviteCreateOrConnectWithoutCaseInput = {
    where: CaseInviteWhereUniqueInput
    create: XOR<CaseInviteCreateWithoutCaseInput, CaseInviteUncheckedCreateWithoutCaseInput>
  }

  export type CaseInviteCreateManyCaseInputEnvelope = {
    data: CaseInviteCreateManyCaseInput | CaseInviteCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutCaseInput = {
    id?: string
    content: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    element?: AssuranceElementCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutAuthoredCommentsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
  }

  export type CommentUncheckedCreateWithoutCaseInput = {
    id?: string
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type CommentCreateOrConnectWithoutCaseInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCaseInput, CommentUncheckedCreateWithoutCaseInput>
  }

  export type CommentCreateManyCaseInputEnvelope = {
    data: CommentCreateManyCaseInput | CommentCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type CaseImageCreateWithoutCaseInput = {
    id?: string
    imageUrl: string
    uploadedAt: Date | string
    uploadedById: string
  }

  export type CaseImageUncheckedCreateWithoutCaseInput = {
    id?: string
    imageUrl: string
    uploadedAt: Date | string
    uploadedById: string
  }

  export type CaseImageCreateOrConnectWithoutCaseInput = {
    where: CaseImageWhereUniqueInput
    create: XOR<CaseImageCreateWithoutCaseInput, CaseImageUncheckedCreateWithoutCaseInput>
  }

  export type CaseTypeAssignmentCreateWithoutCaseInput = {
    id?: string
    assignedById: string
    assignedAt?: Date | string
    caseType: CaseTypeCreateNestedOneWithoutAssignmentsInput
  }

  export type CaseTypeAssignmentUncheckedCreateWithoutCaseInput = {
    id?: string
    caseTypeId: string
    assignedById: string
    assignedAt?: Date | string
  }

  export type CaseTypeAssignmentCreateOrConnectWithoutCaseInput = {
    where: CaseTypeAssignmentWhereUniqueInput
    create: XOR<CaseTypeAssignmentCreateWithoutCaseInput, CaseTypeAssignmentUncheckedCreateWithoutCaseInput>
  }

  export type CaseTypeAssignmentCreateManyCaseInputEnvelope = {
    data: CaseTypeAssignmentCreateManyCaseInput | CaseTypeAssignmentCreateManyCaseInput[]
    skipDuplicates?: boolean
  }

  export type ReleaseCreateWithoutSourceCaseInput = {
    id?: string
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedCase?: AssuranceCaseCreateNestedOneWithoutPublishedReleasesInput
    snapshots?: ReleaseSnapshotCreateNestedManyWithoutReleaseInput
    comments?: ReleaseCommentCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseUncheckedCreateWithoutSourceCaseInput = {
    id?: string
    publishedCaseId?: string | null
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshots?: ReleaseSnapshotUncheckedCreateNestedManyWithoutReleaseInput
    comments?: ReleaseCommentUncheckedCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageUncheckedCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseCreateOrConnectWithoutSourceCaseInput = {
    where: ReleaseWhereUniqueInput
    create: XOR<ReleaseCreateWithoutSourceCaseInput, ReleaseUncheckedCreateWithoutSourceCaseInput>
  }

  export type ReleaseCreateManySourceCaseInputEnvelope = {
    data: ReleaseCreateManySourceCaseInput | ReleaseCreateManySourceCaseInput[]
    skipDuplicates?: boolean
  }

  export type ReleaseCreateWithoutPublishedCaseInput = {
    id?: string
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceCase: AssuranceCaseCreateNestedOneWithoutSourceReleasesInput
    snapshots?: ReleaseSnapshotCreateNestedManyWithoutReleaseInput
    comments?: ReleaseCommentCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseUncheckedCreateWithoutPublishedCaseInput = {
    id?: string
    sourceCaseId: string
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshots?: ReleaseSnapshotUncheckedCreateNestedManyWithoutReleaseInput
    comments?: ReleaseCommentUncheckedCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageUncheckedCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseCreateOrConnectWithoutPublishedCaseInput = {
    where: ReleaseWhereUniqueInput
    create: XOR<ReleaseCreateWithoutPublishedCaseInput, ReleaseUncheckedCreateWithoutPublishedCaseInput>
  }

  export type ReleaseCreateManyPublishedCaseInputEnvelope = {
    data: ReleaseCreateManyPublishedCaseInput | ReleaseCreateManyPublishedCaseInput[]
    skipDuplicates?: boolean
  }

  export type PublishedAssuranceCaseCreateWithoutAssuranceCaseInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    caseStudyLinks?: CaseStudyPublishedCaseCreateNestedManyWithoutPublishedAssuranceCaseInput
  }

  export type PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    caseStudyLinks?: CaseStudyPublishedCaseUncheckedCreateNestedManyWithoutPublishedAssuranceCaseInput
  }

  export type PublishedAssuranceCaseCreateOrConnectWithoutAssuranceCaseInput = {
    where: PublishedAssuranceCaseWhereUniqueInput
    create: XOR<PublishedAssuranceCaseCreateWithoutAssuranceCaseInput, PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput>
  }

  export type PublishedAssuranceCaseCreateManyAssuranceCaseInputEnvelope = {
    data: PublishedAssuranceCaseCreateManyAssuranceCaseInput | PublishedAssuranceCaseCreateManyAssuranceCaseInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceElementCreateWithoutModuleReferenceInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutModuleReferenceInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutModuleReferenceInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutModuleReferenceInput, AssuranceElementUncheckedCreateWithoutModuleReferenceInput>
  }

  export type AssuranceElementCreateManyModuleReferenceInputEnvelope = {
    data: AssuranceElementCreateManyModuleReferenceInput | AssuranceElementCreateManyModuleReferenceInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedCasesInput = {
    update: XOR<UserUpdateWithoutCreatedCasesInput, UserUncheckedUpdateWithoutCreatedCasesInput>
    create: XOR<UserCreateWithoutCreatedCasesInput, UserUncheckedCreateWithoutCreatedCasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCasesInput, UserUncheckedUpdateWithoutCreatedCasesInput>
  }

  export type UserUpdateWithoutCreatedCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUpsertWithoutMarkedReadyCasesInput = {
    update: XOR<UserUpdateWithoutMarkedReadyCasesInput, UserUncheckedUpdateWithoutMarkedReadyCasesInput>
    create: XOR<UserCreateWithoutMarkedReadyCasesInput, UserUncheckedCreateWithoutMarkedReadyCasesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMarkedReadyCasesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMarkedReadyCasesInput, UserUncheckedUpdateWithoutMarkedReadyCasesInput>
  }

  export type UserUpdateWithoutMarkedReadyCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutMarkedReadyCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type ArgumentPatternUpsertWithoutDerivedCasesInput = {
    update: XOR<ArgumentPatternUpdateWithoutDerivedCasesInput, ArgumentPatternUncheckedUpdateWithoutDerivedCasesInput>
    create: XOR<ArgumentPatternCreateWithoutDerivedCasesInput, ArgumentPatternUncheckedCreateWithoutDerivedCasesInput>
    where?: ArgumentPatternWhereInput
  }

  export type ArgumentPatternUpdateToOneWithWhereWithoutDerivedCasesInput = {
    where?: ArgumentPatternWhereInput
    data: XOR<ArgumentPatternUpdateWithoutDerivedCasesInput, ArgumentPatternUncheckedUpdateWithoutDerivedCasesInput>
  }

  export type ArgumentPatternUpdateWithoutDerivedCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PatternElementUpdateManyWithoutPatternNestedInput
    userPermissions?: PatternPermissionUpdateManyWithoutPatternNestedInput
    teamPermissions?: PatternTeamPermissionUpdateManyWithoutPatternNestedInput
  }

  export type ArgumentPatternUncheckedUpdateWithoutDerivedCasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PatternElementUncheckedUpdateManyWithoutPatternNestedInput
    userPermissions?: PatternPermissionUncheckedUpdateManyWithoutPatternNestedInput
    teamPermissions?: PatternTeamPermissionUncheckedUpdateManyWithoutPatternNestedInput
  }

  export type AssuranceElementUpsertWithWhereUniqueWithoutCaseInput = {
    where: AssuranceElementWhereUniqueInput
    update: XOR<AssuranceElementUpdateWithoutCaseInput, AssuranceElementUncheckedUpdateWithoutCaseInput>
    create: XOR<AssuranceElementCreateWithoutCaseInput, AssuranceElementUncheckedCreateWithoutCaseInput>
  }

  export type AssuranceElementUpdateWithWhereUniqueWithoutCaseInput = {
    where: AssuranceElementWhereUniqueInput
    data: XOR<AssuranceElementUpdateWithoutCaseInput, AssuranceElementUncheckedUpdateWithoutCaseInput>
  }

  export type AssuranceElementUpdateManyWithWhereWithoutCaseInput = {
    where: AssuranceElementScalarWhereInput
    data: XOR<AssuranceElementUpdateManyMutationInput, AssuranceElementUncheckedUpdateManyWithoutCaseInput>
  }

  export type CasePermissionUpsertWithWhereUniqueWithoutCaseInput = {
    where: CasePermissionWhereUniqueInput
    update: XOR<CasePermissionUpdateWithoutCaseInput, CasePermissionUncheckedUpdateWithoutCaseInput>
    create: XOR<CasePermissionCreateWithoutCaseInput, CasePermissionUncheckedCreateWithoutCaseInput>
  }

  export type CasePermissionUpdateWithWhereUniqueWithoutCaseInput = {
    where: CasePermissionWhereUniqueInput
    data: XOR<CasePermissionUpdateWithoutCaseInput, CasePermissionUncheckedUpdateWithoutCaseInput>
  }

  export type CasePermissionUpdateManyWithWhereWithoutCaseInput = {
    where: CasePermissionScalarWhereInput
    data: XOR<CasePermissionUpdateManyMutationInput, CasePermissionUncheckedUpdateManyWithoutCaseInput>
  }

  export type CaseTeamPermissionUpsertWithWhereUniqueWithoutCaseInput = {
    where: CaseTeamPermissionWhereUniqueInput
    update: XOR<CaseTeamPermissionUpdateWithoutCaseInput, CaseTeamPermissionUncheckedUpdateWithoutCaseInput>
    create: XOR<CaseTeamPermissionCreateWithoutCaseInput, CaseTeamPermissionUncheckedCreateWithoutCaseInput>
  }

  export type CaseTeamPermissionUpdateWithWhereUniqueWithoutCaseInput = {
    where: CaseTeamPermissionWhereUniqueInput
    data: XOR<CaseTeamPermissionUpdateWithoutCaseInput, CaseTeamPermissionUncheckedUpdateWithoutCaseInput>
  }

  export type CaseTeamPermissionUpdateManyWithWhereWithoutCaseInput = {
    where: CaseTeamPermissionScalarWhereInput
    data: XOR<CaseTeamPermissionUpdateManyMutationInput, CaseTeamPermissionUncheckedUpdateManyWithoutCaseInput>
  }

  export type CaseInviteUpsertWithWhereUniqueWithoutCaseInput = {
    where: CaseInviteWhereUniqueInput
    update: XOR<CaseInviteUpdateWithoutCaseInput, CaseInviteUncheckedUpdateWithoutCaseInput>
    create: XOR<CaseInviteCreateWithoutCaseInput, CaseInviteUncheckedCreateWithoutCaseInput>
  }

  export type CaseInviteUpdateWithWhereUniqueWithoutCaseInput = {
    where: CaseInviteWhereUniqueInput
    data: XOR<CaseInviteUpdateWithoutCaseInput, CaseInviteUncheckedUpdateWithoutCaseInput>
  }

  export type CaseInviteUpdateManyWithWhereWithoutCaseInput = {
    where: CaseInviteScalarWhereInput
    data: XOR<CaseInviteUpdateManyMutationInput, CaseInviteUncheckedUpdateManyWithoutCaseInput>
  }

  export type CaseInviteScalarWhereInput = {
    AND?: CaseInviteScalarWhereInput | CaseInviteScalarWhereInput[]
    OR?: CaseInviteScalarWhereInput[]
    NOT?: CaseInviteScalarWhereInput | CaseInviteScalarWhereInput[]
    id?: StringFilter<"CaseInvite"> | string
    caseId?: StringFilter<"CaseInvite"> | string
    email?: StringFilter<"CaseInvite"> | string
    permission?: EnumPermissionLevelFilter<"CaseInvite"> | $Enums.PermissionLevel
    inviteToken?: StringFilter<"CaseInvite"> | string
    inviteExpiresAt?: DateTimeFilter<"CaseInvite"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"CaseInvite"> | Date | string | null
    acceptedById?: StringNullableFilter<"CaseInvite"> | string | null
    invitedById?: StringFilter<"CaseInvite"> | string
    createdAt?: DateTimeFilter<"CaseInvite"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutCaseInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCaseInput, CommentUncheckedUpdateWithoutCaseInput>
    create: XOR<CommentCreateWithoutCaseInput, CommentUncheckedCreateWithoutCaseInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCaseInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCaseInput, CommentUncheckedUpdateWithoutCaseInput>
  }

  export type CommentUpdateManyWithWhereWithoutCaseInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCaseInput>
  }

  export type CaseImageUpsertWithoutCaseInput = {
    update: XOR<CaseImageUpdateWithoutCaseInput, CaseImageUncheckedUpdateWithoutCaseInput>
    create: XOR<CaseImageCreateWithoutCaseInput, CaseImageUncheckedCreateWithoutCaseInput>
    where?: CaseImageWhereInput
  }

  export type CaseImageUpdateToOneWithWhereWithoutCaseInput = {
    where?: CaseImageWhereInput
    data: XOR<CaseImageUpdateWithoutCaseInput, CaseImageUncheckedUpdateWithoutCaseInput>
  }

  export type CaseImageUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type CaseImageUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseInput = {
    where: CaseTypeAssignmentWhereUniqueInput
    update: XOR<CaseTypeAssignmentUpdateWithoutCaseInput, CaseTypeAssignmentUncheckedUpdateWithoutCaseInput>
    create: XOR<CaseTypeAssignmentCreateWithoutCaseInput, CaseTypeAssignmentUncheckedCreateWithoutCaseInput>
  }

  export type CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseInput = {
    where: CaseTypeAssignmentWhereUniqueInput
    data: XOR<CaseTypeAssignmentUpdateWithoutCaseInput, CaseTypeAssignmentUncheckedUpdateWithoutCaseInput>
  }

  export type CaseTypeAssignmentUpdateManyWithWhereWithoutCaseInput = {
    where: CaseTypeAssignmentScalarWhereInput
    data: XOR<CaseTypeAssignmentUpdateManyMutationInput, CaseTypeAssignmentUncheckedUpdateManyWithoutCaseInput>
  }

  export type CaseTypeAssignmentScalarWhereInput = {
    AND?: CaseTypeAssignmentScalarWhereInput | CaseTypeAssignmentScalarWhereInput[]
    OR?: CaseTypeAssignmentScalarWhereInput[]
    NOT?: CaseTypeAssignmentScalarWhereInput | CaseTypeAssignmentScalarWhereInput[]
    id?: StringFilter<"CaseTypeAssignment"> | string
    caseId?: StringFilter<"CaseTypeAssignment"> | string
    caseTypeId?: StringFilter<"CaseTypeAssignment"> | string
    assignedById?: StringFilter<"CaseTypeAssignment"> | string
    assignedAt?: DateTimeFilter<"CaseTypeAssignment"> | Date | string
  }

  export type ReleaseUpsertWithWhereUniqueWithoutSourceCaseInput = {
    where: ReleaseWhereUniqueInput
    update: XOR<ReleaseUpdateWithoutSourceCaseInput, ReleaseUncheckedUpdateWithoutSourceCaseInput>
    create: XOR<ReleaseCreateWithoutSourceCaseInput, ReleaseUncheckedCreateWithoutSourceCaseInput>
  }

  export type ReleaseUpdateWithWhereUniqueWithoutSourceCaseInput = {
    where: ReleaseWhereUniqueInput
    data: XOR<ReleaseUpdateWithoutSourceCaseInput, ReleaseUncheckedUpdateWithoutSourceCaseInput>
  }

  export type ReleaseUpdateManyWithWhereWithoutSourceCaseInput = {
    where: ReleaseScalarWhereInput
    data: XOR<ReleaseUpdateManyMutationInput, ReleaseUncheckedUpdateManyWithoutSourceCaseInput>
  }

  export type ReleaseScalarWhereInput = {
    AND?: ReleaseScalarWhereInput | ReleaseScalarWhereInput[]
    OR?: ReleaseScalarWhereInput[]
    NOT?: ReleaseScalarWhereInput | ReleaseScalarWhereInput[]
    id?: StringFilter<"Release"> | string
    sourceCaseId?: StringFilter<"Release"> | string
    publishedCaseId?: StringNullableFilter<"Release"> | string | null
    title?: StringFilter<"Release"> | string
    description?: StringFilter<"Release"> | string
    currentVersion?: IntFilter<"Release"> | number
    authors?: StringFilter<"Release"> | string
    contactEmail?: StringNullableFilter<"Release"> | string | null
    category?: StringNullableFilter<"Release"> | string | null
    sector?: StringNullableFilter<"Release"> | string | null
    tags?: StringNullableListFilter<"Release">
    status?: EnumReleaseStatusFilter<"Release"> | $Enums.ReleaseStatus
    firstPublishedAt?: DateTimeNullableFilter<"Release"> | Date | string | null
    lastUpdatedAt?: DateTimeNullableFilter<"Release"> | Date | string | null
    allowComments?: BoolFilter<"Release"> | boolean
    createdById?: StringFilter<"Release"> | string
    createdAt?: DateTimeFilter<"Release"> | Date | string
    updatedAt?: DateTimeFilter<"Release"> | Date | string
  }

  export type ReleaseUpsertWithWhereUniqueWithoutPublishedCaseInput = {
    where: ReleaseWhereUniqueInput
    update: XOR<ReleaseUpdateWithoutPublishedCaseInput, ReleaseUncheckedUpdateWithoutPublishedCaseInput>
    create: XOR<ReleaseCreateWithoutPublishedCaseInput, ReleaseUncheckedCreateWithoutPublishedCaseInput>
  }

  export type ReleaseUpdateWithWhereUniqueWithoutPublishedCaseInput = {
    where: ReleaseWhereUniqueInput
    data: XOR<ReleaseUpdateWithoutPublishedCaseInput, ReleaseUncheckedUpdateWithoutPublishedCaseInput>
  }

  export type ReleaseUpdateManyWithWhereWithoutPublishedCaseInput = {
    where: ReleaseScalarWhereInput
    data: XOR<ReleaseUpdateManyMutationInput, ReleaseUncheckedUpdateManyWithoutPublishedCaseInput>
  }

  export type PublishedAssuranceCaseUpsertWithWhereUniqueWithoutAssuranceCaseInput = {
    where: PublishedAssuranceCaseWhereUniqueInput
    update: XOR<PublishedAssuranceCaseUpdateWithoutAssuranceCaseInput, PublishedAssuranceCaseUncheckedUpdateWithoutAssuranceCaseInput>
    create: XOR<PublishedAssuranceCaseCreateWithoutAssuranceCaseInput, PublishedAssuranceCaseUncheckedCreateWithoutAssuranceCaseInput>
  }

  export type PublishedAssuranceCaseUpdateWithWhereUniqueWithoutAssuranceCaseInput = {
    where: PublishedAssuranceCaseWhereUniqueInput
    data: XOR<PublishedAssuranceCaseUpdateWithoutAssuranceCaseInput, PublishedAssuranceCaseUncheckedUpdateWithoutAssuranceCaseInput>
  }

  export type PublishedAssuranceCaseUpdateManyWithWhereWithoutAssuranceCaseInput = {
    where: PublishedAssuranceCaseScalarWhereInput
    data: XOR<PublishedAssuranceCaseUpdateManyMutationInput, PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseInput>
  }

  export type PublishedAssuranceCaseScalarWhereInput = {
    AND?: PublishedAssuranceCaseScalarWhereInput | PublishedAssuranceCaseScalarWhereInput[]
    OR?: PublishedAssuranceCaseScalarWhereInput[]
    NOT?: PublishedAssuranceCaseScalarWhereInput | PublishedAssuranceCaseScalarWhereInput[]
    id?: UuidFilter<"PublishedAssuranceCase"> | string
    title?: StringFilter<"PublishedAssuranceCase"> | string
    content?: JsonFilter<"PublishedAssuranceCase">
    createdAt?: DateTimeFilter<"PublishedAssuranceCase"> | Date | string
    assuranceCaseId?: StringFilter<"PublishedAssuranceCase"> | string
    description?: StringNullableFilter<"PublishedAssuranceCase"> | string | null
  }

  export type AssuranceElementUpsertWithWhereUniqueWithoutModuleReferenceInput = {
    where: AssuranceElementWhereUniqueInput
    update: XOR<AssuranceElementUpdateWithoutModuleReferenceInput, AssuranceElementUncheckedUpdateWithoutModuleReferenceInput>
    create: XOR<AssuranceElementCreateWithoutModuleReferenceInput, AssuranceElementUncheckedCreateWithoutModuleReferenceInput>
  }

  export type AssuranceElementUpdateWithWhereUniqueWithoutModuleReferenceInput = {
    where: AssuranceElementWhereUniqueInput
    data: XOR<AssuranceElementUpdateWithoutModuleReferenceInput, AssuranceElementUncheckedUpdateWithoutModuleReferenceInput>
  }

  export type AssuranceElementUpdateManyWithWhereWithoutModuleReferenceInput = {
    where: AssuranceElementScalarWhereInput
    data: XOR<AssuranceElementUpdateManyMutationInput, AssuranceElementUncheckedUpdateManyWithoutModuleReferenceInput>
  }

  export type AssuranceCaseCreateWithoutUserPermissionsInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutUserPermissionsInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutUserPermissionsInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutUserPermissionsInput, AssuranceCaseUncheckedCreateWithoutUserPermissionsInput>
  }

  export type UserCreateWithoutCasePermissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutCasePermissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutCasePermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCasePermissionsInput, UserUncheckedCreateWithoutCasePermissionsInput>
  }

  export type UserCreateWithoutGrantedPermissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutGrantedPermissionsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutGrantedPermissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGrantedPermissionsInput, UserUncheckedCreateWithoutGrantedPermissionsInput>
  }

  export type AssuranceCaseUpsertWithoutUserPermissionsInput = {
    update: XOR<AssuranceCaseUpdateWithoutUserPermissionsInput, AssuranceCaseUncheckedUpdateWithoutUserPermissionsInput>
    create: XOR<AssuranceCaseCreateWithoutUserPermissionsInput, AssuranceCaseUncheckedCreateWithoutUserPermissionsInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutUserPermissionsInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutUserPermissionsInput, AssuranceCaseUncheckedUpdateWithoutUserPermissionsInput>
  }

  export type AssuranceCaseUpdateWithoutUserPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutUserPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type UserUpsertWithoutCasePermissionsInput = {
    update: XOR<UserUpdateWithoutCasePermissionsInput, UserUncheckedUpdateWithoutCasePermissionsInput>
    create: XOR<UserCreateWithoutCasePermissionsInput, UserUncheckedCreateWithoutCasePermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCasePermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCasePermissionsInput, UserUncheckedUpdateWithoutCasePermissionsInput>
  }

  export type UserUpdateWithoutCasePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutCasePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUpsertWithoutGrantedPermissionsInput = {
    update: XOR<UserUpdateWithoutGrantedPermissionsInput, UserUncheckedUpdateWithoutGrantedPermissionsInput>
    create: XOR<UserCreateWithoutGrantedPermissionsInput, UserUncheckedCreateWithoutGrantedPermissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGrantedPermissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGrantedPermissionsInput, UserUncheckedUpdateWithoutGrantedPermissionsInput>
  }

  export type UserUpdateWithoutGrantedPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutGrantedPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type AssuranceCaseCreateWithoutTeamPermissionsInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutTeamPermissionsInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutTeamPermissionsInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutTeamPermissionsInput, AssuranceCaseUncheckedCreateWithoutTeamPermissionsInput>
  }

  export type TeamCreateWithoutCasePermissionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    patternPermissions?: PatternTeamPermissionCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCasePermissionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    patternPermissions?: PatternTeamPermissionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCasePermissionsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCasePermissionsInput, TeamUncheckedCreateWithoutCasePermissionsInput>
  }

  export type AssuranceCaseUpsertWithoutTeamPermissionsInput = {
    update: XOR<AssuranceCaseUpdateWithoutTeamPermissionsInput, AssuranceCaseUncheckedUpdateWithoutTeamPermissionsInput>
    create: XOR<AssuranceCaseCreateWithoutTeamPermissionsInput, AssuranceCaseUncheckedCreateWithoutTeamPermissionsInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutTeamPermissionsInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutTeamPermissionsInput, AssuranceCaseUncheckedUpdateWithoutTeamPermissionsInput>
  }

  export type AssuranceCaseUpdateWithoutTeamPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutTeamPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type TeamUpsertWithoutCasePermissionsInput = {
    update: XOR<TeamUpdateWithoutCasePermissionsInput, TeamUncheckedUpdateWithoutCasePermissionsInput>
    create: XOR<TeamCreateWithoutCasePermissionsInput, TeamUncheckedCreateWithoutCasePermissionsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutCasePermissionsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutCasePermissionsInput, TeamUncheckedUpdateWithoutCasePermissionsInput>
  }

  export type TeamUpdateWithoutCasePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    patternPermissions?: PatternTeamPermissionUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCasePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    patternPermissions?: PatternTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type AssuranceCaseCreateWithoutInvitesInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutInvitesInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutInvitesInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutInvitesInput, AssuranceCaseUncheckedCreateWithoutInvitesInput>
  }

  export type AssuranceCaseUpsertWithoutInvitesInput = {
    update: XOR<AssuranceCaseUpdateWithoutInvitesInput, AssuranceCaseUncheckedUpdateWithoutInvitesInput>
    create: XOR<AssuranceCaseCreateWithoutInvitesInput, AssuranceCaseUncheckedCreateWithoutInvitesInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutInvitesInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutInvitesInput, AssuranceCaseUncheckedUpdateWithoutInvitesInput>
  }

  export type AssuranceCaseUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseCreateWithoutElementsInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutElementsInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutElementsInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutElementsInput, AssuranceCaseUncheckedCreateWithoutElementsInput>
  }

  export type UserCreateWithoutCreatedElementsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutCreatedElementsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutCreatedElementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedElementsInput, UserUncheckedCreateWithoutCreatedElementsInput>
  }

  export type AssuranceElementCreateWithoutChildrenInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutChildrenInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutChildrenInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutChildrenInput, AssuranceElementUncheckedCreateWithoutChildrenInput>
  }

  export type AssuranceElementCreateWithoutParentInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutParentInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutParentInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutParentInput, AssuranceElementUncheckedCreateWithoutParentInput>
  }

  export type AssuranceElementCreateManyParentInputEnvelope = {
    data: AssuranceElementCreateManyParentInput | AssuranceElementCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceElementCreateWithoutDefeatedByInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutDefeatedByInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutDefeatedByInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutDefeatedByInput, AssuranceElementUncheckedCreateWithoutDefeatedByInput>
  }

  export type AssuranceElementCreateWithoutDefeatsElementInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutDefeatsElementInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutDefeatsElementInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutDefeatsElementInput, AssuranceElementUncheckedCreateWithoutDefeatsElementInput>
  }

  export type AssuranceElementCreateManyDefeatsElementInputEnvelope = {
    data: AssuranceElementCreateManyDefeatsElementInput | AssuranceElementCreateManyDefeatsElementInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceCaseCreateWithoutEmbeddedInInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
  }

  export type AssuranceCaseUncheckedCreateWithoutEmbeddedInInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
  }

  export type AssuranceCaseCreateOrConnectWithoutEmbeddedInInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutEmbeddedInInput, AssuranceCaseUncheckedCreateWithoutEmbeddedInInput>
  }

  export type EvidenceLinkCreateWithoutEvidenceInput = {
    id?: string
    createdAt?: Date | string
    claim: AssuranceElementCreateNestedOneWithoutEvidenceLinksToInput
  }

  export type EvidenceLinkUncheckedCreateWithoutEvidenceInput = {
    id?: string
    claimId: string
    createdAt?: Date | string
  }

  export type EvidenceLinkCreateOrConnectWithoutEvidenceInput = {
    where: EvidenceLinkWhereUniqueInput
    create: XOR<EvidenceLinkCreateWithoutEvidenceInput, EvidenceLinkUncheckedCreateWithoutEvidenceInput>
  }

  export type EvidenceLinkCreateManyEvidenceInputEnvelope = {
    data: EvidenceLinkCreateManyEvidenceInput | EvidenceLinkCreateManyEvidenceInput[]
    skipDuplicates?: boolean
  }

  export type EvidenceLinkCreateWithoutClaimInput = {
    id?: string
    createdAt?: Date | string
    evidence: AssuranceElementCreateNestedOneWithoutEvidenceLinksFromInput
  }

  export type EvidenceLinkUncheckedCreateWithoutClaimInput = {
    id?: string
    evidenceId: string
    createdAt?: Date | string
  }

  export type EvidenceLinkCreateOrConnectWithoutClaimInput = {
    where: EvidenceLinkWhereUniqueInput
    create: XOR<EvidenceLinkCreateWithoutClaimInput, EvidenceLinkUncheckedCreateWithoutClaimInput>
  }

  export type EvidenceLinkCreateManyClaimInputEnvelope = {
    data: EvidenceLinkCreateManyClaimInput | EvidenceLinkCreateManyClaimInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutElementInput = {
    id?: string
    content: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case?: AssuranceCaseCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutAuthoredCommentsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
  }

  export type CommentUncheckedCreateWithoutElementInput = {
    id?: string
    caseId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type CommentCreateOrConnectWithoutElementInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutElementInput, CommentUncheckedCreateWithoutElementInput>
  }

  export type CommentCreateManyElementInputEnvelope = {
    data: CommentCreateManyElementInput | CommentCreateManyElementInput[]
    skipDuplicates?: boolean
  }

  export type ReleaseCommentCreateWithoutElementInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    release: ReleaseCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutReleaseCommentsInput
    parentComment?: ReleaseCommentCreateNestedOneWithoutRepliesInput
    replies?: ReleaseCommentCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentUncheckedCreateWithoutElementInput = {
    id?: string
    releaseId: string
    parentCommentId?: string | null
    content: string
    authorId: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReleaseCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentCreateOrConnectWithoutElementInput = {
    where: ReleaseCommentWhereUniqueInput
    create: XOR<ReleaseCommentCreateWithoutElementInput, ReleaseCommentUncheckedCreateWithoutElementInput>
  }

  export type ReleaseCommentCreateManyElementInputEnvelope = {
    data: ReleaseCommentCreateManyElementInput | ReleaseCommentCreateManyElementInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceCaseUpsertWithoutElementsInput = {
    update: XOR<AssuranceCaseUpdateWithoutElementsInput, AssuranceCaseUncheckedUpdateWithoutElementsInput>
    create: XOR<AssuranceCaseCreateWithoutElementsInput, AssuranceCaseUncheckedCreateWithoutElementsInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutElementsInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutElementsInput, AssuranceCaseUncheckedUpdateWithoutElementsInput>
  }

  export type AssuranceCaseUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type UserUpsertWithoutCreatedElementsInput = {
    update: XOR<UserUpdateWithoutCreatedElementsInput, UserUncheckedUpdateWithoutCreatedElementsInput>
    create: XOR<UserCreateWithoutCreatedElementsInput, UserUncheckedCreateWithoutCreatedElementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedElementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedElementsInput, UserUncheckedUpdateWithoutCreatedElementsInput>
  }

  export type UserUpdateWithoutCreatedElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type AssuranceElementUpsertWithoutChildrenInput = {
    update: XOR<AssuranceElementUpdateWithoutChildrenInput, AssuranceElementUncheckedUpdateWithoutChildrenInput>
    create: XOR<AssuranceElementCreateWithoutChildrenInput, AssuranceElementUncheckedCreateWithoutChildrenInput>
    where?: AssuranceElementWhereInput
  }

  export type AssuranceElementUpdateToOneWithWhereWithoutChildrenInput = {
    where?: AssuranceElementWhereInput
    data: XOR<AssuranceElementUpdateWithoutChildrenInput, AssuranceElementUncheckedUpdateWithoutChildrenInput>
  }

  export type AssuranceElementUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUpsertWithWhereUniqueWithoutParentInput = {
    where: AssuranceElementWhereUniqueInput
    update: XOR<AssuranceElementUpdateWithoutParentInput, AssuranceElementUncheckedUpdateWithoutParentInput>
    create: XOR<AssuranceElementCreateWithoutParentInput, AssuranceElementUncheckedCreateWithoutParentInput>
  }

  export type AssuranceElementUpdateWithWhereUniqueWithoutParentInput = {
    where: AssuranceElementWhereUniqueInput
    data: XOR<AssuranceElementUpdateWithoutParentInput, AssuranceElementUncheckedUpdateWithoutParentInput>
  }

  export type AssuranceElementUpdateManyWithWhereWithoutParentInput = {
    where: AssuranceElementScalarWhereInput
    data: XOR<AssuranceElementUpdateManyMutationInput, AssuranceElementUncheckedUpdateManyWithoutParentInput>
  }

  export type AssuranceElementUpsertWithoutDefeatedByInput = {
    update: XOR<AssuranceElementUpdateWithoutDefeatedByInput, AssuranceElementUncheckedUpdateWithoutDefeatedByInput>
    create: XOR<AssuranceElementCreateWithoutDefeatedByInput, AssuranceElementUncheckedCreateWithoutDefeatedByInput>
    where?: AssuranceElementWhereInput
  }

  export type AssuranceElementUpdateToOneWithWhereWithoutDefeatedByInput = {
    where?: AssuranceElementWhereInput
    data: XOR<AssuranceElementUpdateWithoutDefeatedByInput, AssuranceElementUncheckedUpdateWithoutDefeatedByInput>
  }

  export type AssuranceElementUpdateWithoutDefeatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutDefeatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUpsertWithWhereUniqueWithoutDefeatsElementInput = {
    where: AssuranceElementWhereUniqueInput
    update: XOR<AssuranceElementUpdateWithoutDefeatsElementInput, AssuranceElementUncheckedUpdateWithoutDefeatsElementInput>
    create: XOR<AssuranceElementCreateWithoutDefeatsElementInput, AssuranceElementUncheckedCreateWithoutDefeatsElementInput>
  }

  export type AssuranceElementUpdateWithWhereUniqueWithoutDefeatsElementInput = {
    where: AssuranceElementWhereUniqueInput
    data: XOR<AssuranceElementUpdateWithoutDefeatsElementInput, AssuranceElementUncheckedUpdateWithoutDefeatsElementInput>
  }

  export type AssuranceElementUpdateManyWithWhereWithoutDefeatsElementInput = {
    where: AssuranceElementScalarWhereInput
    data: XOR<AssuranceElementUpdateManyMutationInput, AssuranceElementUncheckedUpdateManyWithoutDefeatsElementInput>
  }

  export type AssuranceCaseUpsertWithoutEmbeddedInInput = {
    update: XOR<AssuranceCaseUpdateWithoutEmbeddedInInput, AssuranceCaseUncheckedUpdateWithoutEmbeddedInInput>
    create: XOR<AssuranceCaseCreateWithoutEmbeddedInInput, AssuranceCaseUncheckedCreateWithoutEmbeddedInInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutEmbeddedInInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutEmbeddedInInput, AssuranceCaseUncheckedUpdateWithoutEmbeddedInInput>
  }

  export type AssuranceCaseUpdateWithoutEmbeddedInInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutEmbeddedInInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
  }

  export type EvidenceLinkUpsertWithWhereUniqueWithoutEvidenceInput = {
    where: EvidenceLinkWhereUniqueInput
    update: XOR<EvidenceLinkUpdateWithoutEvidenceInput, EvidenceLinkUncheckedUpdateWithoutEvidenceInput>
    create: XOR<EvidenceLinkCreateWithoutEvidenceInput, EvidenceLinkUncheckedCreateWithoutEvidenceInput>
  }

  export type EvidenceLinkUpdateWithWhereUniqueWithoutEvidenceInput = {
    where: EvidenceLinkWhereUniqueInput
    data: XOR<EvidenceLinkUpdateWithoutEvidenceInput, EvidenceLinkUncheckedUpdateWithoutEvidenceInput>
  }

  export type EvidenceLinkUpdateManyWithWhereWithoutEvidenceInput = {
    where: EvidenceLinkScalarWhereInput
    data: XOR<EvidenceLinkUpdateManyMutationInput, EvidenceLinkUncheckedUpdateManyWithoutEvidenceInput>
  }

  export type EvidenceLinkScalarWhereInput = {
    AND?: EvidenceLinkScalarWhereInput | EvidenceLinkScalarWhereInput[]
    OR?: EvidenceLinkScalarWhereInput[]
    NOT?: EvidenceLinkScalarWhereInput | EvidenceLinkScalarWhereInput[]
    id?: StringFilter<"EvidenceLink"> | string
    evidenceId?: StringFilter<"EvidenceLink"> | string
    claimId?: StringFilter<"EvidenceLink"> | string
    createdAt?: DateTimeFilter<"EvidenceLink"> | Date | string
  }

  export type EvidenceLinkUpsertWithWhereUniqueWithoutClaimInput = {
    where: EvidenceLinkWhereUniqueInput
    update: XOR<EvidenceLinkUpdateWithoutClaimInput, EvidenceLinkUncheckedUpdateWithoutClaimInput>
    create: XOR<EvidenceLinkCreateWithoutClaimInput, EvidenceLinkUncheckedCreateWithoutClaimInput>
  }

  export type EvidenceLinkUpdateWithWhereUniqueWithoutClaimInput = {
    where: EvidenceLinkWhereUniqueInput
    data: XOR<EvidenceLinkUpdateWithoutClaimInput, EvidenceLinkUncheckedUpdateWithoutClaimInput>
  }

  export type EvidenceLinkUpdateManyWithWhereWithoutClaimInput = {
    where: EvidenceLinkScalarWhereInput
    data: XOR<EvidenceLinkUpdateManyMutationInput, EvidenceLinkUncheckedUpdateManyWithoutClaimInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutElementInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutElementInput, CommentUncheckedUpdateWithoutElementInput>
    create: XOR<CommentCreateWithoutElementInput, CommentUncheckedCreateWithoutElementInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutElementInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutElementInput, CommentUncheckedUpdateWithoutElementInput>
  }

  export type CommentUpdateManyWithWhereWithoutElementInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutElementInput>
  }

  export type ReleaseCommentUpsertWithWhereUniqueWithoutElementInput = {
    where: ReleaseCommentWhereUniqueInput
    update: XOR<ReleaseCommentUpdateWithoutElementInput, ReleaseCommentUncheckedUpdateWithoutElementInput>
    create: XOR<ReleaseCommentCreateWithoutElementInput, ReleaseCommentUncheckedCreateWithoutElementInput>
  }

  export type ReleaseCommentUpdateWithWhereUniqueWithoutElementInput = {
    where: ReleaseCommentWhereUniqueInput
    data: XOR<ReleaseCommentUpdateWithoutElementInput, ReleaseCommentUncheckedUpdateWithoutElementInput>
  }

  export type ReleaseCommentUpdateManyWithWhereWithoutElementInput = {
    where: ReleaseCommentScalarWhereInput
    data: XOR<ReleaseCommentUpdateManyMutationInput, ReleaseCommentUncheckedUpdateManyWithoutElementInput>
  }

  export type AssuranceElementCreateWithoutEvidenceLinksFromInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutEvidenceLinksFromInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutEvidenceLinksFromInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutEvidenceLinksFromInput, AssuranceElementUncheckedCreateWithoutEvidenceLinksFromInput>
  }

  export type AssuranceElementCreateWithoutEvidenceLinksToInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    comments?: CommentCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutEvidenceLinksToInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutEvidenceLinksToInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutEvidenceLinksToInput, AssuranceElementUncheckedCreateWithoutEvidenceLinksToInput>
  }

  export type AssuranceElementUpsertWithoutEvidenceLinksFromInput = {
    update: XOR<AssuranceElementUpdateWithoutEvidenceLinksFromInput, AssuranceElementUncheckedUpdateWithoutEvidenceLinksFromInput>
    create: XOR<AssuranceElementCreateWithoutEvidenceLinksFromInput, AssuranceElementUncheckedCreateWithoutEvidenceLinksFromInput>
    where?: AssuranceElementWhereInput
  }

  export type AssuranceElementUpdateToOneWithWhereWithoutEvidenceLinksFromInput = {
    where?: AssuranceElementWhereInput
    data: XOR<AssuranceElementUpdateWithoutEvidenceLinksFromInput, AssuranceElementUncheckedUpdateWithoutEvidenceLinksFromInput>
  }

  export type AssuranceElementUpdateWithoutEvidenceLinksFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutEvidenceLinksFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUpsertWithoutEvidenceLinksToInput = {
    update: XOR<AssuranceElementUpdateWithoutEvidenceLinksToInput, AssuranceElementUncheckedUpdateWithoutEvidenceLinksToInput>
    create: XOR<AssuranceElementCreateWithoutEvidenceLinksToInput, AssuranceElementUncheckedCreateWithoutEvidenceLinksToInput>
    where?: AssuranceElementWhereInput
  }

  export type AssuranceElementUpdateToOneWithWhereWithoutEvidenceLinksToInput = {
    where?: AssuranceElementWhereInput
    data: XOR<AssuranceElementUpdateWithoutEvidenceLinksToInput, AssuranceElementUncheckedUpdateWithoutEvidenceLinksToInput>
  }

  export type AssuranceElementUpdateWithoutEvidenceLinksToInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutEvidenceLinksToInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type PatternElementCreateWithoutPatternInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: PatternElementCreateNestedOneWithoutChildrenInput
    children?: PatternElementCreateNestedManyWithoutParentInput
  }

  export type PatternElementUncheckedCreateWithoutPatternInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PatternElementUncheckedCreateNestedManyWithoutParentInput
  }

  export type PatternElementCreateOrConnectWithoutPatternInput = {
    where: PatternElementWhereUniqueInput
    create: XOR<PatternElementCreateWithoutPatternInput, PatternElementUncheckedCreateWithoutPatternInput>
  }

  export type PatternElementCreateManyPatternInputEnvelope = {
    data: PatternElementCreateManyPatternInput | PatternElementCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type PatternPermissionCreateWithoutPatternInput = {
    id?: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternPermissionUncheckedCreateWithoutPatternInput = {
    id?: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternPermissionCreateOrConnectWithoutPatternInput = {
    where: PatternPermissionWhereUniqueInput
    create: XOR<PatternPermissionCreateWithoutPatternInput, PatternPermissionUncheckedCreateWithoutPatternInput>
  }

  export type PatternPermissionCreateManyPatternInputEnvelope = {
    data: PatternPermissionCreateManyPatternInput | PatternPermissionCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type PatternTeamPermissionCreateWithoutPatternInput = {
    id?: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
    team: TeamCreateNestedOneWithoutPatternPermissionsInput
  }

  export type PatternTeamPermissionUncheckedCreateWithoutPatternInput = {
    id?: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternTeamPermissionCreateOrConnectWithoutPatternInput = {
    where: PatternTeamPermissionWhereUniqueInput
    create: XOR<PatternTeamPermissionCreateWithoutPatternInput, PatternTeamPermissionUncheckedCreateWithoutPatternInput>
  }

  export type PatternTeamPermissionCreateManyPatternInputEnvelope = {
    data: PatternTeamPermissionCreateManyPatternInput | PatternTeamPermissionCreateManyPatternInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceCaseCreateWithoutSourcePatternInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutSourcePatternInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutSourcePatternInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutSourcePatternInput, AssuranceCaseUncheckedCreateWithoutSourcePatternInput>
  }

  export type AssuranceCaseCreateManySourcePatternInputEnvelope = {
    data: AssuranceCaseCreateManySourcePatternInput | AssuranceCaseCreateManySourcePatternInput[]
    skipDuplicates?: boolean
  }

  export type PatternElementUpsertWithWhereUniqueWithoutPatternInput = {
    where: PatternElementWhereUniqueInput
    update: XOR<PatternElementUpdateWithoutPatternInput, PatternElementUncheckedUpdateWithoutPatternInput>
    create: XOR<PatternElementCreateWithoutPatternInput, PatternElementUncheckedCreateWithoutPatternInput>
  }

  export type PatternElementUpdateWithWhereUniqueWithoutPatternInput = {
    where: PatternElementWhereUniqueInput
    data: XOR<PatternElementUpdateWithoutPatternInput, PatternElementUncheckedUpdateWithoutPatternInput>
  }

  export type PatternElementUpdateManyWithWhereWithoutPatternInput = {
    where: PatternElementScalarWhereInput
    data: XOR<PatternElementUpdateManyMutationInput, PatternElementUncheckedUpdateManyWithoutPatternInput>
  }

  export type PatternElementScalarWhereInput = {
    AND?: PatternElementScalarWhereInput | PatternElementScalarWhereInput[]
    OR?: PatternElementScalarWhereInput[]
    NOT?: PatternElementScalarWhereInput | PatternElementScalarWhereInput[]
    id?: StringFilter<"PatternElement"> | string
    patternId?: StringFilter<"PatternElement"> | string
    elementType?: EnumElementTypeFilter<"PatternElement"> | $Enums.ElementType
    role?: EnumElementRoleNullableFilter<"PatternElement"> | $Enums.ElementRole | null
    parentId?: StringNullableFilter<"PatternElement"> | string | null
    name?: StringNullableFilter<"PatternElement"> | string | null
    description?: StringFilter<"PatternElement"> | string
    assumption?: StringNullableFilter<"PatternElement"> | string | null
    justification?: StringNullableFilter<"PatternElement"> | string | null
    url?: StringNullableFilter<"PatternElement"> | string | null
    isPlaceholder?: BoolFilter<"PatternElement"> | boolean
    placeholderHint?: StringNullableFilter<"PatternElement"> | string | null
    displayOrder?: IntFilter<"PatternElement"> | number
    createdAt?: DateTimeFilter<"PatternElement"> | Date | string
    updatedAt?: DateTimeFilter<"PatternElement"> | Date | string
  }

  export type PatternPermissionUpsertWithWhereUniqueWithoutPatternInput = {
    where: PatternPermissionWhereUniqueInput
    update: XOR<PatternPermissionUpdateWithoutPatternInput, PatternPermissionUncheckedUpdateWithoutPatternInput>
    create: XOR<PatternPermissionCreateWithoutPatternInput, PatternPermissionUncheckedCreateWithoutPatternInput>
  }

  export type PatternPermissionUpdateWithWhereUniqueWithoutPatternInput = {
    where: PatternPermissionWhereUniqueInput
    data: XOR<PatternPermissionUpdateWithoutPatternInput, PatternPermissionUncheckedUpdateWithoutPatternInput>
  }

  export type PatternPermissionUpdateManyWithWhereWithoutPatternInput = {
    where: PatternPermissionScalarWhereInput
    data: XOR<PatternPermissionUpdateManyMutationInput, PatternPermissionUncheckedUpdateManyWithoutPatternInput>
  }

  export type PatternPermissionScalarWhereInput = {
    AND?: PatternPermissionScalarWhereInput | PatternPermissionScalarWhereInput[]
    OR?: PatternPermissionScalarWhereInput[]
    NOT?: PatternPermissionScalarWhereInput | PatternPermissionScalarWhereInput[]
    id?: StringFilter<"PatternPermission"> | string
    patternId?: StringFilter<"PatternPermission"> | string
    userId?: StringFilter<"PatternPermission"> | string
    permission?: EnumPermissionLevelFilter<"PatternPermission"> | $Enums.PermissionLevel
    grantedById?: StringFilter<"PatternPermission"> | string
    grantedAt?: DateTimeFilter<"PatternPermission"> | Date | string
  }

  export type PatternTeamPermissionUpsertWithWhereUniqueWithoutPatternInput = {
    where: PatternTeamPermissionWhereUniqueInput
    update: XOR<PatternTeamPermissionUpdateWithoutPatternInput, PatternTeamPermissionUncheckedUpdateWithoutPatternInput>
    create: XOR<PatternTeamPermissionCreateWithoutPatternInput, PatternTeamPermissionUncheckedCreateWithoutPatternInput>
  }

  export type PatternTeamPermissionUpdateWithWhereUniqueWithoutPatternInput = {
    where: PatternTeamPermissionWhereUniqueInput
    data: XOR<PatternTeamPermissionUpdateWithoutPatternInput, PatternTeamPermissionUncheckedUpdateWithoutPatternInput>
  }

  export type PatternTeamPermissionUpdateManyWithWhereWithoutPatternInput = {
    where: PatternTeamPermissionScalarWhereInput
    data: XOR<PatternTeamPermissionUpdateManyMutationInput, PatternTeamPermissionUncheckedUpdateManyWithoutPatternInput>
  }

  export type AssuranceCaseUpsertWithWhereUniqueWithoutSourcePatternInput = {
    where: AssuranceCaseWhereUniqueInput
    update: XOR<AssuranceCaseUpdateWithoutSourcePatternInput, AssuranceCaseUncheckedUpdateWithoutSourcePatternInput>
    create: XOR<AssuranceCaseCreateWithoutSourcePatternInput, AssuranceCaseUncheckedCreateWithoutSourcePatternInput>
  }

  export type AssuranceCaseUpdateWithWhereUniqueWithoutSourcePatternInput = {
    where: AssuranceCaseWhereUniqueInput
    data: XOR<AssuranceCaseUpdateWithoutSourcePatternInput, AssuranceCaseUncheckedUpdateWithoutSourcePatternInput>
  }

  export type AssuranceCaseUpdateManyWithWhereWithoutSourcePatternInput = {
    where: AssuranceCaseScalarWhereInput
    data: XOR<AssuranceCaseUpdateManyMutationInput, AssuranceCaseUncheckedUpdateManyWithoutSourcePatternInput>
  }

  export type ArgumentPatternCreateWithoutElementsInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userPermissions?: PatternPermissionCreateNestedManyWithoutPatternInput
    teamPermissions?: PatternTeamPermissionCreateNestedManyWithoutPatternInput
    derivedCases?: AssuranceCaseCreateNestedManyWithoutSourcePatternInput
  }

  export type ArgumentPatternUncheckedCreateWithoutElementsInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userPermissions?: PatternPermissionUncheckedCreateNestedManyWithoutPatternInput
    teamPermissions?: PatternTeamPermissionUncheckedCreateNestedManyWithoutPatternInput
    derivedCases?: AssuranceCaseUncheckedCreateNestedManyWithoutSourcePatternInput
  }

  export type ArgumentPatternCreateOrConnectWithoutElementsInput = {
    where: ArgumentPatternWhereUniqueInput
    create: XOR<ArgumentPatternCreateWithoutElementsInput, ArgumentPatternUncheckedCreateWithoutElementsInput>
  }

  export type PatternElementCreateWithoutChildrenInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pattern: ArgumentPatternCreateNestedOneWithoutElementsInput
    parent?: PatternElementCreateNestedOneWithoutChildrenInput
  }

  export type PatternElementUncheckedCreateWithoutChildrenInput = {
    id?: string
    patternId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatternElementCreateOrConnectWithoutChildrenInput = {
    where: PatternElementWhereUniqueInput
    create: XOR<PatternElementCreateWithoutChildrenInput, PatternElementUncheckedCreateWithoutChildrenInput>
  }

  export type PatternElementCreateWithoutParentInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pattern: ArgumentPatternCreateNestedOneWithoutElementsInput
    children?: PatternElementCreateNestedManyWithoutParentInput
  }

  export type PatternElementUncheckedCreateWithoutParentInput = {
    id?: string
    patternId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: PatternElementUncheckedCreateNestedManyWithoutParentInput
  }

  export type PatternElementCreateOrConnectWithoutParentInput = {
    where: PatternElementWhereUniqueInput
    create: XOR<PatternElementCreateWithoutParentInput, PatternElementUncheckedCreateWithoutParentInput>
  }

  export type PatternElementCreateManyParentInputEnvelope = {
    data: PatternElementCreateManyParentInput | PatternElementCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ArgumentPatternUpsertWithoutElementsInput = {
    update: XOR<ArgumentPatternUpdateWithoutElementsInput, ArgumentPatternUncheckedUpdateWithoutElementsInput>
    create: XOR<ArgumentPatternCreateWithoutElementsInput, ArgumentPatternUncheckedCreateWithoutElementsInput>
    where?: ArgumentPatternWhereInput
  }

  export type ArgumentPatternUpdateToOneWithWhereWithoutElementsInput = {
    where?: ArgumentPatternWhereInput
    data: XOR<ArgumentPatternUpdateWithoutElementsInput, ArgumentPatternUncheckedUpdateWithoutElementsInput>
  }

  export type ArgumentPatternUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPermissions?: PatternPermissionUpdateManyWithoutPatternNestedInput
    teamPermissions?: PatternTeamPermissionUpdateManyWithoutPatternNestedInput
    derivedCases?: AssuranceCaseUpdateManyWithoutSourcePatternNestedInput
  }

  export type ArgumentPatternUncheckedUpdateWithoutElementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userPermissions?: PatternPermissionUncheckedUpdateManyWithoutPatternNestedInput
    teamPermissions?: PatternTeamPermissionUncheckedUpdateManyWithoutPatternNestedInput
    derivedCases?: AssuranceCaseUncheckedUpdateManyWithoutSourcePatternNestedInput
  }

  export type PatternElementUpsertWithoutChildrenInput = {
    update: XOR<PatternElementUpdateWithoutChildrenInput, PatternElementUncheckedUpdateWithoutChildrenInput>
    create: XOR<PatternElementCreateWithoutChildrenInput, PatternElementUncheckedCreateWithoutChildrenInput>
    where?: PatternElementWhereInput
  }

  export type PatternElementUpdateToOneWithWhereWithoutChildrenInput = {
    where?: PatternElementWhereInput
    data: XOR<PatternElementUpdateWithoutChildrenInput, PatternElementUncheckedUpdateWithoutChildrenInput>
  }

  export type PatternElementUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: ArgumentPatternUpdateOneRequiredWithoutElementsNestedInput
    parent?: PatternElementUpdateOneWithoutChildrenNestedInput
  }

  export type PatternElementUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternElementUpsertWithWhereUniqueWithoutParentInput = {
    where: PatternElementWhereUniqueInput
    update: XOR<PatternElementUpdateWithoutParentInput, PatternElementUncheckedUpdateWithoutParentInput>
    create: XOR<PatternElementCreateWithoutParentInput, PatternElementUncheckedCreateWithoutParentInput>
  }

  export type PatternElementUpdateWithWhereUniqueWithoutParentInput = {
    where: PatternElementWhereUniqueInput
    data: XOR<PatternElementUpdateWithoutParentInput, PatternElementUncheckedUpdateWithoutParentInput>
  }

  export type PatternElementUpdateManyWithWhereWithoutParentInput = {
    where: PatternElementScalarWhereInput
    data: XOR<PatternElementUpdateManyMutationInput, PatternElementUncheckedUpdateManyWithoutParentInput>
  }

  export type ArgumentPatternCreateWithoutUserPermissionsInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PatternElementCreateNestedManyWithoutPatternInput
    teamPermissions?: PatternTeamPermissionCreateNestedManyWithoutPatternInput
    derivedCases?: AssuranceCaseCreateNestedManyWithoutSourcePatternInput
  }

  export type ArgumentPatternUncheckedCreateWithoutUserPermissionsInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PatternElementUncheckedCreateNestedManyWithoutPatternInput
    teamPermissions?: PatternTeamPermissionUncheckedCreateNestedManyWithoutPatternInput
    derivedCases?: AssuranceCaseUncheckedCreateNestedManyWithoutSourcePatternInput
  }

  export type ArgumentPatternCreateOrConnectWithoutUserPermissionsInput = {
    where: ArgumentPatternWhereUniqueInput
    create: XOR<ArgumentPatternCreateWithoutUserPermissionsInput, ArgumentPatternUncheckedCreateWithoutUserPermissionsInput>
  }

  export type ArgumentPatternUpsertWithoutUserPermissionsInput = {
    update: XOR<ArgumentPatternUpdateWithoutUserPermissionsInput, ArgumentPatternUncheckedUpdateWithoutUserPermissionsInput>
    create: XOR<ArgumentPatternCreateWithoutUserPermissionsInput, ArgumentPatternUncheckedCreateWithoutUserPermissionsInput>
    where?: ArgumentPatternWhereInput
  }

  export type ArgumentPatternUpdateToOneWithWhereWithoutUserPermissionsInput = {
    where?: ArgumentPatternWhereInput
    data: XOR<ArgumentPatternUpdateWithoutUserPermissionsInput, ArgumentPatternUncheckedUpdateWithoutUserPermissionsInput>
  }

  export type ArgumentPatternUpdateWithoutUserPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PatternElementUpdateManyWithoutPatternNestedInput
    teamPermissions?: PatternTeamPermissionUpdateManyWithoutPatternNestedInput
    derivedCases?: AssuranceCaseUpdateManyWithoutSourcePatternNestedInput
  }

  export type ArgumentPatternUncheckedUpdateWithoutUserPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PatternElementUncheckedUpdateManyWithoutPatternNestedInput
    teamPermissions?: PatternTeamPermissionUncheckedUpdateManyWithoutPatternNestedInput
    derivedCases?: AssuranceCaseUncheckedUpdateManyWithoutSourcePatternNestedInput
  }

  export type ArgumentPatternCreateWithoutTeamPermissionsInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PatternElementCreateNestedManyWithoutPatternInput
    userPermissions?: PatternPermissionCreateNestedManyWithoutPatternInput
    derivedCases?: AssuranceCaseCreateNestedManyWithoutSourcePatternInput
  }

  export type ArgumentPatternUncheckedCreateWithoutTeamPermissionsInput = {
    id?: string
    name: string
    description: string
    version: string
    category?: string | null
    tags?: ArgumentPatternCreatetagsInput | string[]
    published?: boolean
    publishedAt?: Date | string | null
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: PatternElementUncheckedCreateNestedManyWithoutPatternInput
    userPermissions?: PatternPermissionUncheckedCreateNestedManyWithoutPatternInput
    derivedCases?: AssuranceCaseUncheckedCreateNestedManyWithoutSourcePatternInput
  }

  export type ArgumentPatternCreateOrConnectWithoutTeamPermissionsInput = {
    where: ArgumentPatternWhereUniqueInput
    create: XOR<ArgumentPatternCreateWithoutTeamPermissionsInput, ArgumentPatternUncheckedCreateWithoutTeamPermissionsInput>
  }

  export type TeamCreateWithoutPatternPermissionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutCreatedTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    casePermissions?: CaseTeamPermissionCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutPatternPermissionsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    casePermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutPatternPermissionsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutPatternPermissionsInput, TeamUncheckedCreateWithoutPatternPermissionsInput>
  }

  export type ArgumentPatternUpsertWithoutTeamPermissionsInput = {
    update: XOR<ArgumentPatternUpdateWithoutTeamPermissionsInput, ArgumentPatternUncheckedUpdateWithoutTeamPermissionsInput>
    create: XOR<ArgumentPatternCreateWithoutTeamPermissionsInput, ArgumentPatternUncheckedCreateWithoutTeamPermissionsInput>
    where?: ArgumentPatternWhereInput
  }

  export type ArgumentPatternUpdateToOneWithWhereWithoutTeamPermissionsInput = {
    where?: ArgumentPatternWhereInput
    data: XOR<ArgumentPatternUpdateWithoutTeamPermissionsInput, ArgumentPatternUncheckedUpdateWithoutTeamPermissionsInput>
  }

  export type ArgumentPatternUpdateWithoutTeamPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PatternElementUpdateManyWithoutPatternNestedInput
    userPermissions?: PatternPermissionUpdateManyWithoutPatternNestedInput
    derivedCases?: AssuranceCaseUpdateManyWithoutSourcePatternNestedInput
  }

  export type ArgumentPatternUncheckedUpdateWithoutTeamPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ArgumentPatternUpdatetagsInput | string[]
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: PatternElementUncheckedUpdateManyWithoutPatternNestedInput
    userPermissions?: PatternPermissionUncheckedUpdateManyWithoutPatternNestedInput
    derivedCases?: AssuranceCaseUncheckedUpdateManyWithoutSourcePatternNestedInput
  }

  export type TeamUpsertWithoutPatternPermissionsInput = {
    update: XOR<TeamUpdateWithoutPatternPermissionsInput, TeamUncheckedUpdateWithoutPatternPermissionsInput>
    create: XOR<TeamCreateWithoutPatternPermissionsInput, TeamUncheckedCreateWithoutPatternPermissionsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutPatternPermissionsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutPatternPermissionsInput, TeamUncheckedUpdateWithoutPatternPermissionsInput>
  }

  export type TeamUpdateWithoutPatternPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    casePermissions?: CaseTeamPermissionUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutPatternPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    casePermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type AssuranceCaseCreateWithoutSourceReleasesInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutSourceReleasesInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutSourceReleasesInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutSourceReleasesInput, AssuranceCaseUncheckedCreateWithoutSourceReleasesInput>
  }

  export type AssuranceCaseCreateWithoutPublishedReleasesInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutPublishedReleasesInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutPublishedReleasesInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutPublishedReleasesInput, AssuranceCaseUncheckedCreateWithoutPublishedReleasesInput>
  }

  export type ReleaseSnapshotCreateWithoutReleaseInput = {
    id?: string
    versionNumber: number
    versionLabel?: string | null
    content: JsonNullValueInput | InputJsonValue
    snapshotTakenAt: Date | string
    snapshotTakenById: string
    reason: $Enums.SnapshotReason
    createdAt?: Date | string
  }

  export type ReleaseSnapshotUncheckedCreateWithoutReleaseInput = {
    id?: string
    versionNumber: number
    versionLabel?: string | null
    content: JsonNullValueInput | InputJsonValue
    snapshotTakenAt: Date | string
    snapshotTakenById: string
    reason: $Enums.SnapshotReason
    createdAt?: Date | string
  }

  export type ReleaseSnapshotCreateOrConnectWithoutReleaseInput = {
    where: ReleaseSnapshotWhereUniqueInput
    create: XOR<ReleaseSnapshotCreateWithoutReleaseInput, ReleaseSnapshotUncheckedCreateWithoutReleaseInput>
  }

  export type ReleaseSnapshotCreateManyReleaseInputEnvelope = {
    data: ReleaseSnapshotCreateManyReleaseInput | ReleaseSnapshotCreateManyReleaseInput[]
    skipDuplicates?: boolean
  }

  export type ReleaseCommentCreateWithoutReleaseInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    element?: AssuranceElementCreateNestedOneWithoutReleaseCommentsInput
    author: UserCreateNestedOneWithoutReleaseCommentsInput
    parentComment?: ReleaseCommentCreateNestedOneWithoutRepliesInput
    replies?: ReleaseCommentCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentUncheckedCreateWithoutReleaseInput = {
    id?: string
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReleaseCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentCreateOrConnectWithoutReleaseInput = {
    where: ReleaseCommentWhereUniqueInput
    create: XOR<ReleaseCommentCreateWithoutReleaseInput, ReleaseCommentUncheckedCreateWithoutReleaseInput>
  }

  export type ReleaseCommentCreateManyReleaseInputEnvelope = {
    data: ReleaseCommentCreateManyReleaseInput | ReleaseCommentCreateManyReleaseInput[]
    skipDuplicates?: boolean
  }

  export type ReleaseImageCreateWithoutReleaseInput = {
    id?: string
    imageUrl: string
    altText?: string | null
    uploadedAt: Date | string
    uploadedById: string
  }

  export type ReleaseImageUncheckedCreateWithoutReleaseInput = {
    id?: string
    imageUrl: string
    altText?: string | null
    uploadedAt: Date | string
    uploadedById: string
  }

  export type ReleaseImageCreateOrConnectWithoutReleaseInput = {
    where: ReleaseImageWhereUniqueInput
    create: XOR<ReleaseImageCreateWithoutReleaseInput, ReleaseImageUncheckedCreateWithoutReleaseInput>
  }

  export type AssuranceCaseUpsertWithoutSourceReleasesInput = {
    update: XOR<AssuranceCaseUpdateWithoutSourceReleasesInput, AssuranceCaseUncheckedUpdateWithoutSourceReleasesInput>
    create: XOR<AssuranceCaseCreateWithoutSourceReleasesInput, AssuranceCaseUncheckedCreateWithoutSourceReleasesInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutSourceReleasesInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutSourceReleasesInput, AssuranceCaseUncheckedUpdateWithoutSourceReleasesInput>
  }

  export type AssuranceCaseUpdateWithoutSourceReleasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutSourceReleasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUpsertWithoutPublishedReleasesInput = {
    update: XOR<AssuranceCaseUpdateWithoutPublishedReleasesInput, AssuranceCaseUncheckedUpdateWithoutPublishedReleasesInput>
    create: XOR<AssuranceCaseCreateWithoutPublishedReleasesInput, AssuranceCaseUncheckedCreateWithoutPublishedReleasesInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutPublishedReleasesInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutPublishedReleasesInput, AssuranceCaseUncheckedUpdateWithoutPublishedReleasesInput>
  }

  export type AssuranceCaseUpdateWithoutPublishedReleasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutPublishedReleasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type ReleaseSnapshotUpsertWithWhereUniqueWithoutReleaseInput = {
    where: ReleaseSnapshotWhereUniqueInput
    update: XOR<ReleaseSnapshotUpdateWithoutReleaseInput, ReleaseSnapshotUncheckedUpdateWithoutReleaseInput>
    create: XOR<ReleaseSnapshotCreateWithoutReleaseInput, ReleaseSnapshotUncheckedCreateWithoutReleaseInput>
  }

  export type ReleaseSnapshotUpdateWithWhereUniqueWithoutReleaseInput = {
    where: ReleaseSnapshotWhereUniqueInput
    data: XOR<ReleaseSnapshotUpdateWithoutReleaseInput, ReleaseSnapshotUncheckedUpdateWithoutReleaseInput>
  }

  export type ReleaseSnapshotUpdateManyWithWhereWithoutReleaseInput = {
    where: ReleaseSnapshotScalarWhereInput
    data: XOR<ReleaseSnapshotUpdateManyMutationInput, ReleaseSnapshotUncheckedUpdateManyWithoutReleaseInput>
  }

  export type ReleaseSnapshotScalarWhereInput = {
    AND?: ReleaseSnapshotScalarWhereInput | ReleaseSnapshotScalarWhereInput[]
    OR?: ReleaseSnapshotScalarWhereInput[]
    NOT?: ReleaseSnapshotScalarWhereInput | ReleaseSnapshotScalarWhereInput[]
    id?: StringFilter<"ReleaseSnapshot"> | string
    releaseId?: StringFilter<"ReleaseSnapshot"> | string
    versionNumber?: IntFilter<"ReleaseSnapshot"> | number
    versionLabel?: StringNullableFilter<"ReleaseSnapshot"> | string | null
    content?: JsonFilter<"ReleaseSnapshot">
    snapshotTakenAt?: DateTimeFilter<"ReleaseSnapshot"> | Date | string
    snapshotTakenById?: StringFilter<"ReleaseSnapshot"> | string
    reason?: EnumSnapshotReasonFilter<"ReleaseSnapshot"> | $Enums.SnapshotReason
    createdAt?: DateTimeFilter<"ReleaseSnapshot"> | Date | string
  }

  export type ReleaseCommentUpsertWithWhereUniqueWithoutReleaseInput = {
    where: ReleaseCommentWhereUniqueInput
    update: XOR<ReleaseCommentUpdateWithoutReleaseInput, ReleaseCommentUncheckedUpdateWithoutReleaseInput>
    create: XOR<ReleaseCommentCreateWithoutReleaseInput, ReleaseCommentUncheckedCreateWithoutReleaseInput>
  }

  export type ReleaseCommentUpdateWithWhereUniqueWithoutReleaseInput = {
    where: ReleaseCommentWhereUniqueInput
    data: XOR<ReleaseCommentUpdateWithoutReleaseInput, ReleaseCommentUncheckedUpdateWithoutReleaseInput>
  }

  export type ReleaseCommentUpdateManyWithWhereWithoutReleaseInput = {
    where: ReleaseCommentScalarWhereInput
    data: XOR<ReleaseCommentUpdateManyMutationInput, ReleaseCommentUncheckedUpdateManyWithoutReleaseInput>
  }

  export type ReleaseImageUpsertWithoutReleaseInput = {
    update: XOR<ReleaseImageUpdateWithoutReleaseInput, ReleaseImageUncheckedUpdateWithoutReleaseInput>
    create: XOR<ReleaseImageCreateWithoutReleaseInput, ReleaseImageUncheckedCreateWithoutReleaseInput>
    where?: ReleaseImageWhereInput
  }

  export type ReleaseImageUpdateToOneWithWhereWithoutReleaseInput = {
    where?: ReleaseImageWhereInput
    data: XOR<ReleaseImageUpdateWithoutReleaseInput, ReleaseImageUncheckedUpdateWithoutReleaseInput>
  }

  export type ReleaseImageUpdateWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type ReleaseImageUncheckedUpdateWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploadedById?: StringFieldUpdateOperationsInput | string
  }

  export type ReleaseCreateWithoutSnapshotsInput = {
    id?: string
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceCase: AssuranceCaseCreateNestedOneWithoutSourceReleasesInput
    publishedCase?: AssuranceCaseCreateNestedOneWithoutPublishedReleasesInput
    comments?: ReleaseCommentCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    sourceCaseId: string
    publishedCaseId?: string | null
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ReleaseCommentUncheckedCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageUncheckedCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseCreateOrConnectWithoutSnapshotsInput = {
    where: ReleaseWhereUniqueInput
    create: XOR<ReleaseCreateWithoutSnapshotsInput, ReleaseUncheckedCreateWithoutSnapshotsInput>
  }

  export type ReleaseUpsertWithoutSnapshotsInput = {
    update: XOR<ReleaseUpdateWithoutSnapshotsInput, ReleaseUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<ReleaseCreateWithoutSnapshotsInput, ReleaseUncheckedCreateWithoutSnapshotsInput>
    where?: ReleaseWhereInput
  }

  export type ReleaseUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: ReleaseWhereInput
    data: XOR<ReleaseUpdateWithoutSnapshotsInput, ReleaseUncheckedUpdateWithoutSnapshotsInput>
  }

  export type ReleaseUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceCase?: AssuranceCaseUpdateOneRequiredWithoutSourceReleasesNestedInput
    publishedCase?: AssuranceCaseUpdateOneWithoutPublishedReleasesNestedInput
    comments?: ReleaseCommentUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUpdateOneWithoutReleaseNestedInput
  }

  export type ReleaseUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCaseId?: StringFieldUpdateOperationsInput | string
    publishedCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ReleaseCommentUncheckedUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUncheckedUpdateOneWithoutReleaseNestedInput
  }

  export type ReleaseCreateWithoutCommentsInput = {
    id?: string
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceCase: AssuranceCaseCreateNestedOneWithoutSourceReleasesInput
    publishedCase?: AssuranceCaseCreateNestedOneWithoutPublishedReleasesInput
    snapshots?: ReleaseSnapshotCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseUncheckedCreateWithoutCommentsInput = {
    id?: string
    sourceCaseId: string
    publishedCaseId?: string | null
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshots?: ReleaseSnapshotUncheckedCreateNestedManyWithoutReleaseInput
    image?: ReleaseImageUncheckedCreateNestedOneWithoutReleaseInput
  }

  export type ReleaseCreateOrConnectWithoutCommentsInput = {
    where: ReleaseWhereUniqueInput
    create: XOR<ReleaseCreateWithoutCommentsInput, ReleaseUncheckedCreateWithoutCommentsInput>
  }

  export type AssuranceElementCreateWithoutReleaseCommentsInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    comments?: CommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutReleaseCommentsInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    comments?: CommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutReleaseCommentsInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutReleaseCommentsInput, AssuranceElementUncheckedCreateWithoutReleaseCommentsInput>
  }

  export type UserCreateWithoutReleaseCommentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutReleaseCommentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutReleaseCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReleaseCommentsInput, UserUncheckedCreateWithoutReleaseCommentsInput>
  }

  export type ReleaseCommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    release: ReleaseCreateNestedOneWithoutCommentsInput
    element?: AssuranceElementCreateNestedOneWithoutReleaseCommentsInput
    author: UserCreateNestedOneWithoutReleaseCommentsInput
    parentComment?: ReleaseCommentCreateNestedOneWithoutRepliesInput
  }

  export type ReleaseCommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    releaseId: string
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseCommentCreateOrConnectWithoutRepliesInput = {
    where: ReleaseCommentWhereUniqueInput
    create: XOR<ReleaseCommentCreateWithoutRepliesInput, ReleaseCommentUncheckedCreateWithoutRepliesInput>
  }

  export type ReleaseCommentCreateWithoutParentCommentInput = {
    id?: string
    content: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    release: ReleaseCreateNestedOneWithoutCommentsInput
    element?: AssuranceElementCreateNestedOneWithoutReleaseCommentsInput
    author: UserCreateNestedOneWithoutReleaseCommentsInput
    replies?: ReleaseCommentCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentUncheckedCreateWithoutParentCommentInput = {
    id?: string
    releaseId: string
    elementId?: string | null
    content: string
    authorId: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ReleaseCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type ReleaseCommentCreateOrConnectWithoutParentCommentInput = {
    where: ReleaseCommentWhereUniqueInput
    create: XOR<ReleaseCommentCreateWithoutParentCommentInput, ReleaseCommentUncheckedCreateWithoutParentCommentInput>
  }

  export type ReleaseCommentCreateManyParentCommentInputEnvelope = {
    data: ReleaseCommentCreateManyParentCommentInput | ReleaseCommentCreateManyParentCommentInput[]
    skipDuplicates?: boolean
  }

  export type ReleaseUpsertWithoutCommentsInput = {
    update: XOR<ReleaseUpdateWithoutCommentsInput, ReleaseUncheckedUpdateWithoutCommentsInput>
    create: XOR<ReleaseCreateWithoutCommentsInput, ReleaseUncheckedCreateWithoutCommentsInput>
    where?: ReleaseWhereInput
  }

  export type ReleaseUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ReleaseWhereInput
    data: XOR<ReleaseUpdateWithoutCommentsInput, ReleaseUncheckedUpdateWithoutCommentsInput>
  }

  export type ReleaseUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceCase?: AssuranceCaseUpdateOneRequiredWithoutSourceReleasesNestedInput
    publishedCase?: AssuranceCaseUpdateOneWithoutPublishedReleasesNestedInput
    snapshots?: ReleaseSnapshotUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUpdateOneWithoutReleaseNestedInput
  }

  export type ReleaseUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCaseId?: StringFieldUpdateOperationsInput | string
    publishedCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshots?: ReleaseSnapshotUncheckedUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUncheckedUpdateOneWithoutReleaseNestedInput
  }

  export type AssuranceElementUpsertWithoutReleaseCommentsInput = {
    update: XOR<AssuranceElementUpdateWithoutReleaseCommentsInput, AssuranceElementUncheckedUpdateWithoutReleaseCommentsInput>
    create: XOR<AssuranceElementCreateWithoutReleaseCommentsInput, AssuranceElementUncheckedCreateWithoutReleaseCommentsInput>
    where?: AssuranceElementWhereInput
  }

  export type AssuranceElementUpdateToOneWithWhereWithoutReleaseCommentsInput = {
    where?: AssuranceElementWhereInput
    data: XOR<AssuranceElementUpdateWithoutReleaseCommentsInput, AssuranceElementUncheckedUpdateWithoutReleaseCommentsInput>
  }

  export type AssuranceElementUpdateWithoutReleaseCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutReleaseCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type UserUpsertWithoutReleaseCommentsInput = {
    update: XOR<UserUpdateWithoutReleaseCommentsInput, UserUncheckedUpdateWithoutReleaseCommentsInput>
    create: XOR<UserCreateWithoutReleaseCommentsInput, UserUncheckedCreateWithoutReleaseCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReleaseCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReleaseCommentsInput, UserUncheckedUpdateWithoutReleaseCommentsInput>
  }

  export type UserUpdateWithoutReleaseCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutReleaseCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type ReleaseCommentUpsertWithoutRepliesInput = {
    update: XOR<ReleaseCommentUpdateWithoutRepliesInput, ReleaseCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<ReleaseCommentCreateWithoutRepliesInput, ReleaseCommentUncheckedCreateWithoutRepliesInput>
    where?: ReleaseCommentWhereInput
  }

  export type ReleaseCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: ReleaseCommentWhereInput
    data: XOR<ReleaseCommentUpdateWithoutRepliesInput, ReleaseCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type ReleaseCommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    release?: ReleaseUpdateOneRequiredWithoutCommentsNestedInput
    element?: AssuranceElementUpdateOneWithoutReleaseCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutReleaseCommentsNestedInput
    parentComment?: ReleaseCommentUpdateOneWithoutRepliesNestedInput
  }

  export type ReleaseCommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseCommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: ReleaseCommentWhereUniqueInput
    update: XOR<ReleaseCommentUpdateWithoutParentCommentInput, ReleaseCommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<ReleaseCommentCreateWithoutParentCommentInput, ReleaseCommentUncheckedCreateWithoutParentCommentInput>
  }

  export type ReleaseCommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: ReleaseCommentWhereUniqueInput
    data: XOR<ReleaseCommentUpdateWithoutParentCommentInput, ReleaseCommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type ReleaseCommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: ReleaseCommentScalarWhereInput
    data: XOR<ReleaseCommentUpdateManyMutationInput, ReleaseCommentUncheckedUpdateManyWithoutParentCommentInput>
  }

  export type ReleaseCreateWithoutImageInput = {
    id?: string
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceCase: AssuranceCaseCreateNestedOneWithoutSourceReleasesInput
    publishedCase?: AssuranceCaseCreateNestedOneWithoutPublishedReleasesInput
    snapshots?: ReleaseSnapshotCreateNestedManyWithoutReleaseInput
    comments?: ReleaseCommentCreateNestedManyWithoutReleaseInput
  }

  export type ReleaseUncheckedCreateWithoutImageInput = {
    id?: string
    sourceCaseId: string
    publishedCaseId?: string | null
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
    snapshots?: ReleaseSnapshotUncheckedCreateNestedManyWithoutReleaseInput
    comments?: ReleaseCommentUncheckedCreateNestedManyWithoutReleaseInput
  }

  export type ReleaseCreateOrConnectWithoutImageInput = {
    where: ReleaseWhereUniqueInput
    create: XOR<ReleaseCreateWithoutImageInput, ReleaseUncheckedCreateWithoutImageInput>
  }

  export type ReleaseUpsertWithoutImageInput = {
    update: XOR<ReleaseUpdateWithoutImageInput, ReleaseUncheckedUpdateWithoutImageInput>
    create: XOR<ReleaseCreateWithoutImageInput, ReleaseUncheckedCreateWithoutImageInput>
    where?: ReleaseWhereInput
  }

  export type ReleaseUpdateToOneWithWhereWithoutImageInput = {
    where?: ReleaseWhereInput
    data: XOR<ReleaseUpdateWithoutImageInput, ReleaseUncheckedUpdateWithoutImageInput>
  }

  export type ReleaseUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceCase?: AssuranceCaseUpdateOneRequiredWithoutSourceReleasesNestedInput
    publishedCase?: AssuranceCaseUpdateOneWithoutPublishedReleasesNestedInput
    snapshots?: ReleaseSnapshotUpdateManyWithoutReleaseNestedInput
    comments?: ReleaseCommentUpdateManyWithoutReleaseNestedInput
  }

  export type ReleaseUncheckedUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCaseId?: StringFieldUpdateOperationsInput | string
    publishedCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshots?: ReleaseSnapshotUncheckedUpdateManyWithoutReleaseNestedInput
    comments?: ReleaseCommentUncheckedUpdateManyWithoutReleaseNestedInput
  }

  export type AssuranceCaseCreateWithoutCommentsInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutCommentsInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutCommentsInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutCommentsInput, AssuranceCaseUncheckedCreateWithoutCommentsInput>
  }

  export type AssuranceElementCreateWithoutCommentsInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutElementsInput
    createdBy: UserCreateNestedOneWithoutCreatedElementsInput
    parent?: AssuranceElementCreateNestedOneWithoutChildrenInput
    children?: AssuranceElementCreateNestedManyWithoutParentInput
    defeatsElement?: AssuranceElementCreateNestedOneWithoutDefeatedByInput
    defeatedBy?: AssuranceElementCreateNestedManyWithoutDefeatsElementInput
    moduleReference?: AssuranceCaseCreateNestedOneWithoutEmbeddedInInput
    evidenceLinksFrom?: EvidenceLinkCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkCreateNestedManyWithoutClaimInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementUncheckedCreateWithoutCommentsInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    children?: AssuranceElementUncheckedCreateNestedManyWithoutParentInput
    defeatedBy?: AssuranceElementUncheckedCreateNestedManyWithoutDefeatsElementInput
    evidenceLinksFrom?: EvidenceLinkUncheckedCreateNestedManyWithoutEvidenceInput
    evidenceLinksTo?: EvidenceLinkUncheckedCreateNestedManyWithoutClaimInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutElementInput
  }

  export type AssuranceElementCreateOrConnectWithoutCommentsInput = {
    where: AssuranceElementWhereUniqueInput
    create: XOR<AssuranceElementCreateWithoutCommentsInput, AssuranceElementUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutAuthoredCommentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutAuthoredCommentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutAuthoredCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthoredCommentsInput, UserUncheckedCreateWithoutAuthoredCommentsInput>
  }

  export type UserCreateWithoutResolvedCommentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutResolvedCommentsInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutResolvedCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutResolvedCommentsInput, UserUncheckedCreateWithoutResolvedCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case?: AssuranceCaseCreateNestedOneWithoutCommentsInput
    element?: AssuranceElementCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutAuthoredCommentsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    caseId?: string | null
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentCommentInput = {
    id?: string
    content: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    case?: AssuranceCaseCreateNestedOneWithoutCommentsInput
    element?: AssuranceElementCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutAuthoredCommentsInput
    resolvedBy?: UserCreateNestedOneWithoutResolvedCommentsInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
  }

  export type CommentUncheckedCreateWithoutParentCommentInput = {
    id?: string
    caseId?: string | null
    elementId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type CommentCreateOrConnectWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentCreateManyParentCommentInputEnvelope = {
    data: CommentCreateManyParentCommentInput | CommentCreateManyParentCommentInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceCaseUpsertWithoutCommentsInput = {
    update: XOR<AssuranceCaseUpdateWithoutCommentsInput, AssuranceCaseUncheckedUpdateWithoutCommentsInput>
    create: XOR<AssuranceCaseCreateWithoutCommentsInput, AssuranceCaseUncheckedCreateWithoutCommentsInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutCommentsInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutCommentsInput, AssuranceCaseUncheckedUpdateWithoutCommentsInput>
  }

  export type AssuranceCaseUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceElementUpsertWithoutCommentsInput = {
    update: XOR<AssuranceElementUpdateWithoutCommentsInput, AssuranceElementUncheckedUpdateWithoutCommentsInput>
    create: XOR<AssuranceElementCreateWithoutCommentsInput, AssuranceElementUncheckedCreateWithoutCommentsInput>
    where?: AssuranceElementWhereInput
  }

  export type AssuranceElementUpdateToOneWithWhereWithoutCommentsInput = {
    where?: AssuranceElementWhereInput
    data: XOR<AssuranceElementUpdateWithoutCommentsInput, AssuranceElementUncheckedUpdateWithoutCommentsInput>
  }

  export type AssuranceElementUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type UserUpsertWithoutAuthoredCommentsInput = {
    update: XOR<UserUpdateWithoutAuthoredCommentsInput, UserUncheckedUpdateWithoutAuthoredCommentsInput>
    create: XOR<UserCreateWithoutAuthoredCommentsInput, UserUncheckedCreateWithoutAuthoredCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthoredCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthoredCommentsInput, UserUncheckedUpdateWithoutAuthoredCommentsInput>
  }

  export type UserUpdateWithoutAuthoredCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthoredCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUpsertWithoutResolvedCommentsInput = {
    update: XOR<UserUpdateWithoutResolvedCommentsInput, UserUncheckedUpdateWithoutResolvedCommentsInput>
    create: XOR<UserCreateWithoutResolvedCommentsInput, UserUncheckedCreateWithoutResolvedCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutResolvedCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutResolvedCommentsInput, UserUncheckedUpdateWithoutResolvedCommentsInput>
  }

  export type UserUpdateWithoutResolvedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutResolvedCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneWithoutCommentsNestedInput
    element?: AssuranceElementUpdateOneWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthoredCommentsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentCommentInput>
  }

  export type AssuranceCaseCreateWithoutCaseImageInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutCaseImageInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutCaseImageInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutCaseImageInput, AssuranceCaseUncheckedCreateWithoutCaseImageInput>
  }

  export type AssuranceCaseUpsertWithoutCaseImageInput = {
    update: XOR<AssuranceCaseUpdateWithoutCaseImageInput, AssuranceCaseUncheckedUpdateWithoutCaseImageInput>
    create: XOR<AssuranceCaseCreateWithoutCaseImageInput, AssuranceCaseUncheckedCreateWithoutCaseImageInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutCaseImageInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutCaseImageInput, AssuranceCaseUncheckedUpdateWithoutCaseImageInput>
  }

  export type AssuranceCaseUpdateWithoutCaseImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutCaseImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type CaseTypeAssignmentCreateWithoutCaseTypeInput = {
    id?: string
    assignedById: string
    assignedAt?: Date | string
    case: AssuranceCaseCreateNestedOneWithoutCaseTypesInput
  }

  export type CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput = {
    id?: string
    caseId: string
    assignedById: string
    assignedAt?: Date | string
  }

  export type CaseTypeAssignmentCreateOrConnectWithoutCaseTypeInput = {
    where: CaseTypeAssignmentWhereUniqueInput
    create: XOR<CaseTypeAssignmentCreateWithoutCaseTypeInput, CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput>
  }

  export type CaseTypeAssignmentCreateManyCaseTypeInputEnvelope = {
    data: CaseTypeAssignmentCreateManyCaseTypeInput | CaseTypeAssignmentCreateManyCaseTypeInput[]
    skipDuplicates?: boolean
  }

  export type CaseTypeAssignmentUpsertWithWhereUniqueWithoutCaseTypeInput = {
    where: CaseTypeAssignmentWhereUniqueInput
    update: XOR<CaseTypeAssignmentUpdateWithoutCaseTypeInput, CaseTypeAssignmentUncheckedUpdateWithoutCaseTypeInput>
    create: XOR<CaseTypeAssignmentCreateWithoutCaseTypeInput, CaseTypeAssignmentUncheckedCreateWithoutCaseTypeInput>
  }

  export type CaseTypeAssignmentUpdateWithWhereUniqueWithoutCaseTypeInput = {
    where: CaseTypeAssignmentWhereUniqueInput
    data: XOR<CaseTypeAssignmentUpdateWithoutCaseTypeInput, CaseTypeAssignmentUncheckedUpdateWithoutCaseTypeInput>
  }

  export type CaseTypeAssignmentUpdateManyWithWhereWithoutCaseTypeInput = {
    where: CaseTypeAssignmentScalarWhereInput
    data: XOR<CaseTypeAssignmentUpdateManyMutationInput, CaseTypeAssignmentUncheckedUpdateManyWithoutCaseTypeInput>
  }

  export type AssuranceCaseCreateWithoutCaseTypesInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutCaseTypesInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    publishedVersions?: PublishedAssuranceCaseUncheckedCreateNestedManyWithoutAssuranceCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutCaseTypesInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutCaseTypesInput, AssuranceCaseUncheckedCreateWithoutCaseTypesInput>
  }

  export type CaseTypeCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CaseTypeCategory
    externalUrl?: string | null
    createdAt?: Date | string
  }

  export type CaseTypeUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    description?: string | null
    category: $Enums.CaseTypeCategory
    externalUrl?: string | null
    createdAt?: Date | string
  }

  export type CaseTypeCreateOrConnectWithoutAssignmentsInput = {
    where: CaseTypeWhereUniqueInput
    create: XOR<CaseTypeCreateWithoutAssignmentsInput, CaseTypeUncheckedCreateWithoutAssignmentsInput>
  }

  export type AssuranceCaseUpsertWithoutCaseTypesInput = {
    update: XOR<AssuranceCaseUpdateWithoutCaseTypesInput, AssuranceCaseUncheckedUpdateWithoutCaseTypesInput>
    create: XOR<AssuranceCaseCreateWithoutCaseTypesInput, AssuranceCaseUncheckedCreateWithoutCaseTypesInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutCaseTypesInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutCaseTypesInput, AssuranceCaseUncheckedUpdateWithoutCaseTypesInput>
  }

  export type AssuranceCaseUpdateWithoutCaseTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutCaseTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type CaseTypeUpsertWithoutAssignmentsInput = {
    update: XOR<CaseTypeUpdateWithoutAssignmentsInput, CaseTypeUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<CaseTypeCreateWithoutAssignmentsInput, CaseTypeUncheckedCreateWithoutAssignmentsInput>
    where?: CaseTypeWhereInput
  }

  export type CaseTypeUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: CaseTypeWhereInput
    data: XOR<CaseTypeUpdateWithoutAssignmentsInput, CaseTypeUncheckedUpdateWithoutAssignmentsInput>
  }

  export type CaseTypeUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCaseTypeCategoryFieldUpdateOperationsInput | $Enums.CaseTypeCategory
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTypeUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumCaseTypeCategoryFieldUpdateOperationsInput | $Enums.CaseTypeCategory
    externalUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutGithubRepositoriesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutGithubRepositoriesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    caseStudies?: CaseStudyUncheckedCreateNestedManyWithoutOwnerInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutGithubRepositoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGithubRepositoriesInput, UserUncheckedCreateWithoutGithubRepositoriesInput>
  }

  export type UserUpsertWithoutGithubRepositoriesInput = {
    update: XOR<UserUpdateWithoutGithubRepositoriesInput, UserUncheckedUpdateWithoutGithubRepositoriesInput>
    create: XOR<UserCreateWithoutGithubRepositoriesInput, UserUncheckedCreateWithoutGithubRepositoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGithubRepositoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGithubRepositoriesInput, UserUncheckedUpdateWithoutGithubRepositoriesInput>
  }

  export type UserUpdateWithoutGithubRepositoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutGithubRepositoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    caseStudies?: CaseStudyUncheckedUpdateManyWithoutOwnerNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserCreateWithoutCaseStudiesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    createdTeams?: TeamCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    markedReadyCases?: AssuranceCaseCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserUncheckedCreateWithoutCaseStudiesInput = {
    id?: string
    email: string
    username: string
    passwordHash?: string | null
    passwordAlgorithm?: string
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    authProvider?: $Enums.AuthProvider
    githubId?: string | null
    githubUsername?: string | null
    emailVerified?: boolean
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    defaultCaseMode?: $Enums.CaseMode
    hasSeenMigrationNotice?: boolean
    isSystemUser?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLoginAt?: Date | string | null
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    createdTeams?: TeamUncheckedCreateNestedManyWithoutCreatedByInput
    createdCases?: AssuranceCaseUncheckedCreateNestedManyWithoutCreatedByInput
    casePermissions?: CasePermissionUncheckedCreateNestedManyWithoutUserInput
    grantedPermissions?: CasePermissionUncheckedCreateNestedManyWithoutGrantedByInput
    createdElements?: AssuranceElementUncheckedCreateNestedManyWithoutCreatedByInput
    authoredComments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    resolvedComments?: CommentUncheckedCreateNestedManyWithoutResolvedByInput
    releaseComments?: ReleaseCommentUncheckedCreateNestedManyWithoutAuthorInput
    githubRepositories?: GitHubRepositoryUncheckedCreateNestedManyWithoutUserInput
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    markedReadyCases?: AssuranceCaseUncheckedCreateNestedManyWithoutMarkedReadyByInput
  }

  export type UserCreateOrConnectWithoutCaseStudiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCaseStudiesInput, UserUncheckedCreateWithoutCaseStudiesInput>
  }

  export type CaseStudyPublishedCaseCreateWithoutCaseStudyInput = {
    id?: bigint | number
    publishedAssuranceCase: PublishedAssuranceCaseCreateNestedOneWithoutCaseStudyLinksInput
  }

  export type CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput = {
    id?: bigint | number
    publishedAssuranceCaseId: string
  }

  export type CaseStudyPublishedCaseCreateOrConnectWithoutCaseStudyInput = {
    where: CaseStudyPublishedCaseWhereUniqueInput
    create: XOR<CaseStudyPublishedCaseCreateWithoutCaseStudyInput, CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput>
  }

  export type CaseStudyPublishedCaseCreateManyCaseStudyInputEnvelope = {
    data: CaseStudyPublishedCaseCreateManyCaseStudyInput | CaseStudyPublishedCaseCreateManyCaseStudyInput[]
    skipDuplicates?: boolean
  }

  export type CaseStudyImageCreateWithoutCaseStudyInput = {
    id?: bigint | number
    image: string
    uploadedAt: Date | string
  }

  export type CaseStudyImageUncheckedCreateWithoutCaseStudyInput = {
    id?: bigint | number
    image: string
    uploadedAt: Date | string
  }

  export type CaseStudyImageCreateOrConnectWithoutCaseStudyInput = {
    where: CaseStudyImageWhereUniqueInput
    create: XOR<CaseStudyImageCreateWithoutCaseStudyInput, CaseStudyImageUncheckedCreateWithoutCaseStudyInput>
  }

  export type UserUpsertWithoutCaseStudiesInput = {
    update: XOR<UserUpdateWithoutCaseStudiesInput, UserUncheckedUpdateWithoutCaseStudiesInput>
    create: XOR<UserCreateWithoutCaseStudiesInput, UserUncheckedCreateWithoutCaseStudiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCaseStudiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCaseStudiesInput, UserUncheckedUpdateWithoutCaseStudiesInput>
  }

  export type UserUpdateWithoutCaseStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    markedReadyCases?: AssuranceCaseUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type UserUncheckedUpdateWithoutCaseStudiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordAlgorithm?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    authProvider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    defaultCaseMode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    hasSeenMigrationNotice?: BoolFieldUpdateOperationsInput | boolean
    isSystemUser?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    createdTeams?: TeamUncheckedUpdateManyWithoutCreatedByNestedInput
    createdCases?: AssuranceCaseUncheckedUpdateManyWithoutCreatedByNestedInput
    casePermissions?: CasePermissionUncheckedUpdateManyWithoutUserNestedInput
    grantedPermissions?: CasePermissionUncheckedUpdateManyWithoutGrantedByNestedInput
    createdElements?: AssuranceElementUncheckedUpdateManyWithoutCreatedByNestedInput
    authoredComments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    resolvedComments?: CommentUncheckedUpdateManyWithoutResolvedByNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutAuthorNestedInput
    githubRepositories?: GitHubRepositoryUncheckedUpdateManyWithoutUserNestedInput
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    markedReadyCases?: AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByNestedInput
  }

  export type CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutCaseStudyInput = {
    where: CaseStudyPublishedCaseWhereUniqueInput
    update: XOR<CaseStudyPublishedCaseUpdateWithoutCaseStudyInput, CaseStudyPublishedCaseUncheckedUpdateWithoutCaseStudyInput>
    create: XOR<CaseStudyPublishedCaseCreateWithoutCaseStudyInput, CaseStudyPublishedCaseUncheckedCreateWithoutCaseStudyInput>
  }

  export type CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutCaseStudyInput = {
    where: CaseStudyPublishedCaseWhereUniqueInput
    data: XOR<CaseStudyPublishedCaseUpdateWithoutCaseStudyInput, CaseStudyPublishedCaseUncheckedUpdateWithoutCaseStudyInput>
  }

  export type CaseStudyPublishedCaseUpdateManyWithWhereWithoutCaseStudyInput = {
    where: CaseStudyPublishedCaseScalarWhereInput
    data: XOR<CaseStudyPublishedCaseUpdateManyMutationInput, CaseStudyPublishedCaseUncheckedUpdateManyWithoutCaseStudyInput>
  }

  export type CaseStudyPublishedCaseScalarWhereInput = {
    AND?: CaseStudyPublishedCaseScalarWhereInput | CaseStudyPublishedCaseScalarWhereInput[]
    OR?: CaseStudyPublishedCaseScalarWhereInput[]
    NOT?: CaseStudyPublishedCaseScalarWhereInput | CaseStudyPublishedCaseScalarWhereInput[]
    id?: BigIntFilter<"CaseStudyPublishedCase"> | bigint | number
    caseStudyId?: IntFilter<"CaseStudyPublishedCase"> | number
    publishedAssuranceCaseId?: UuidFilter<"CaseStudyPublishedCase"> | string
  }

  export type CaseStudyImageUpsertWithoutCaseStudyInput = {
    update: XOR<CaseStudyImageUpdateWithoutCaseStudyInput, CaseStudyImageUncheckedUpdateWithoutCaseStudyInput>
    create: XOR<CaseStudyImageCreateWithoutCaseStudyInput, CaseStudyImageUncheckedCreateWithoutCaseStudyInput>
    where?: CaseStudyImageWhereInput
  }

  export type CaseStudyImageUpdateToOneWithWhereWithoutCaseStudyInput = {
    where?: CaseStudyImageWhereInput
    data: XOR<CaseStudyImageUpdateWithoutCaseStudyInput, CaseStudyImageUncheckedUpdateWithoutCaseStudyInput>
  }

  export type CaseStudyImageUpdateWithoutCaseStudyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    image?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyImageUncheckedUpdateWithoutCaseStudyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    image?: StringFieldUpdateOperationsInput | string
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyCreateWithoutPublishedCasesInput = {
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    type?: string | null
    owner?: UserCreateNestedOneWithoutCaseStudiesInput
    featureImage?: CaseStudyImageCreateNestedOneWithoutCaseStudyInput
  }

  export type CaseStudyUncheckedCreateWithoutPublishedCasesInput = {
    id?: number
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    ownerId?: string | null
    type?: string | null
    featureImage?: CaseStudyImageUncheckedCreateNestedOneWithoutCaseStudyInput
  }

  export type CaseStudyCreateOrConnectWithoutPublishedCasesInput = {
    where: CaseStudyWhereUniqueInput
    create: XOR<CaseStudyCreateWithoutPublishedCasesInput, CaseStudyUncheckedCreateWithoutPublishedCasesInput>
  }

  export type PublishedAssuranceCaseCreateWithoutCaseStudyLinksInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
    assuranceCase: AssuranceCaseCreateNestedOneWithoutPublishedVersionsInput
  }

  export type PublishedAssuranceCaseUncheckedCreateWithoutCaseStudyLinksInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    assuranceCaseId: string
    description?: string | null
  }

  export type PublishedAssuranceCaseCreateOrConnectWithoutCaseStudyLinksInput = {
    where: PublishedAssuranceCaseWhereUniqueInput
    create: XOR<PublishedAssuranceCaseCreateWithoutCaseStudyLinksInput, PublishedAssuranceCaseUncheckedCreateWithoutCaseStudyLinksInput>
  }

  export type CaseStudyUpsertWithoutPublishedCasesInput = {
    update: XOR<CaseStudyUpdateWithoutPublishedCasesInput, CaseStudyUncheckedUpdateWithoutPublishedCasesInput>
    create: XOR<CaseStudyCreateWithoutPublishedCasesInput, CaseStudyUncheckedCreateWithoutPublishedCasesInput>
    where?: CaseStudyWhereInput
  }

  export type CaseStudyUpdateToOneWithWhereWithoutPublishedCasesInput = {
    where?: CaseStudyWhereInput
    data: XOR<CaseStudyUpdateWithoutPublishedCasesInput, CaseStudyUncheckedUpdateWithoutPublishedCasesInput>
  }

  export type CaseStudyUpdateWithoutPublishedCasesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneWithoutCaseStudiesNestedInput
    featureImage?: CaseStudyImageUpdateOneWithoutCaseStudyNestedInput
  }

  export type CaseStudyUncheckedUpdateWithoutPublishedCasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    featureImage?: CaseStudyImageUncheckedUpdateOneWithoutCaseStudyNestedInput
  }

  export type PublishedAssuranceCaseUpsertWithoutCaseStudyLinksInput = {
    update: XOR<PublishedAssuranceCaseUpdateWithoutCaseStudyLinksInput, PublishedAssuranceCaseUncheckedUpdateWithoutCaseStudyLinksInput>
    create: XOR<PublishedAssuranceCaseCreateWithoutCaseStudyLinksInput, PublishedAssuranceCaseUncheckedCreateWithoutCaseStudyLinksInput>
    where?: PublishedAssuranceCaseWhereInput
  }

  export type PublishedAssuranceCaseUpdateToOneWithWhereWithoutCaseStudyLinksInput = {
    where?: PublishedAssuranceCaseWhereInput
    data: XOR<PublishedAssuranceCaseUpdateWithoutCaseStudyLinksInput, PublishedAssuranceCaseUncheckedUpdateWithoutCaseStudyLinksInput>
  }

  export type PublishedAssuranceCaseUpdateWithoutCaseStudyLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    assuranceCase?: AssuranceCaseUpdateOneRequiredWithoutPublishedVersionsNestedInput
  }

  export type PublishedAssuranceCaseUncheckedUpdateWithoutCaseStudyLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assuranceCaseId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaseStudyCreateWithoutFeatureImageInput = {
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    type?: string | null
    owner?: UserCreateNestedOneWithoutCaseStudiesInput
    publishedCases?: CaseStudyPublishedCaseCreateNestedManyWithoutCaseStudyInput
  }

  export type CaseStudyUncheckedCreateWithoutFeatureImageInput = {
    id?: number
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    ownerId?: string | null
    type?: string | null
    publishedCases?: CaseStudyPublishedCaseUncheckedCreateNestedManyWithoutCaseStudyInput
  }

  export type CaseStudyCreateOrConnectWithoutFeatureImageInput = {
    where: CaseStudyWhereUniqueInput
    create: XOR<CaseStudyCreateWithoutFeatureImageInput, CaseStudyUncheckedCreateWithoutFeatureImageInput>
  }

  export type CaseStudyUpsertWithoutFeatureImageInput = {
    update: XOR<CaseStudyUpdateWithoutFeatureImageInput, CaseStudyUncheckedUpdateWithoutFeatureImageInput>
    create: XOR<CaseStudyCreateWithoutFeatureImageInput, CaseStudyUncheckedCreateWithoutFeatureImageInput>
    where?: CaseStudyWhereInput
  }

  export type CaseStudyUpdateToOneWithWhereWithoutFeatureImageInput = {
    where?: CaseStudyWhereInput
    data: XOR<CaseStudyUpdateWithoutFeatureImageInput, CaseStudyUncheckedUpdateWithoutFeatureImageInput>
  }

  export type CaseStudyUpdateWithoutFeatureImageInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
    owner?: UserUpdateOneWithoutCaseStudiesNestedInput
    publishedCases?: CaseStudyPublishedCaseUpdateManyWithoutCaseStudyNestedInput
  }

  export type CaseStudyUncheckedUpdateWithoutFeatureImageInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    publishedCases?: CaseStudyPublishedCaseUncheckedUpdateManyWithoutCaseStudyNestedInput
  }

  export type AssuranceCaseCreateWithoutPublishedVersionsInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    createdBy: UserCreateNestedOneWithoutCreatedCasesInput
    markedReadyBy?: UserCreateNestedOneWithoutMarkedReadyCasesInput
    sourcePattern?: ArgumentPatternCreateNestedOneWithoutDerivedCasesInput
    elements?: AssuranceElementCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionCreateNestedManyWithoutCaseInput
    invites?: CaseInviteCreateNestedManyWithoutCaseInput
    comments?: CommentCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseCreateNestedManyWithoutPublishedCaseInput
    embeddedIn?: AssuranceElementCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseUncheckedCreateWithoutPublishedVersionsInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
    elements?: AssuranceElementUncheckedCreateNestedManyWithoutCaseInput
    userPermissions?: CasePermissionUncheckedCreateNestedManyWithoutCaseInput
    teamPermissions?: CaseTeamPermissionUncheckedCreateNestedManyWithoutCaseInput
    invites?: CaseInviteUncheckedCreateNestedManyWithoutCaseInput
    comments?: CommentUncheckedCreateNestedManyWithoutCaseInput
    caseImage?: CaseImageUncheckedCreateNestedOneWithoutCaseInput
    caseTypes?: CaseTypeAssignmentUncheckedCreateNestedManyWithoutCaseInput
    sourceReleases?: ReleaseUncheckedCreateNestedManyWithoutSourceCaseInput
    publishedReleases?: ReleaseUncheckedCreateNestedManyWithoutPublishedCaseInput
    embeddedIn?: AssuranceElementUncheckedCreateNestedManyWithoutModuleReferenceInput
  }

  export type AssuranceCaseCreateOrConnectWithoutPublishedVersionsInput = {
    where: AssuranceCaseWhereUniqueInput
    create: XOR<AssuranceCaseCreateWithoutPublishedVersionsInput, AssuranceCaseUncheckedCreateWithoutPublishedVersionsInput>
  }

  export type CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput = {
    id?: bigint | number
    caseStudy: CaseStudyCreateNestedOneWithoutPublishedCasesInput
  }

  export type CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput = {
    id?: bigint | number
    caseStudyId: number
  }

  export type CaseStudyPublishedCaseCreateOrConnectWithoutPublishedAssuranceCaseInput = {
    where: CaseStudyPublishedCaseWhereUniqueInput
    create: XOR<CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput, CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput>
  }

  export type CaseStudyPublishedCaseCreateManyPublishedAssuranceCaseInputEnvelope = {
    data: CaseStudyPublishedCaseCreateManyPublishedAssuranceCaseInput | CaseStudyPublishedCaseCreateManyPublishedAssuranceCaseInput[]
    skipDuplicates?: boolean
  }

  export type AssuranceCaseUpsertWithoutPublishedVersionsInput = {
    update: XOR<AssuranceCaseUpdateWithoutPublishedVersionsInput, AssuranceCaseUncheckedUpdateWithoutPublishedVersionsInput>
    create: XOR<AssuranceCaseCreateWithoutPublishedVersionsInput, AssuranceCaseUncheckedCreateWithoutPublishedVersionsInput>
    where?: AssuranceCaseWhereInput
  }

  export type AssuranceCaseUpdateToOneWithWhereWithoutPublishedVersionsInput = {
    where?: AssuranceCaseWhereInput
    data: XOR<AssuranceCaseUpdateWithoutPublishedVersionsInput, AssuranceCaseUncheckedUpdateWithoutPublishedVersionsInput>
  }

  export type AssuranceCaseUpdateWithoutPublishedVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutPublishedVersionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type CaseStudyPublishedCaseUpsertWithWhereUniqueWithoutPublishedAssuranceCaseInput = {
    where: CaseStudyPublishedCaseWhereUniqueInput
    update: XOR<CaseStudyPublishedCaseUpdateWithoutPublishedAssuranceCaseInput, CaseStudyPublishedCaseUncheckedUpdateWithoutPublishedAssuranceCaseInput>
    create: XOR<CaseStudyPublishedCaseCreateWithoutPublishedAssuranceCaseInput, CaseStudyPublishedCaseUncheckedCreateWithoutPublishedAssuranceCaseInput>
  }

  export type CaseStudyPublishedCaseUpdateWithWhereUniqueWithoutPublishedAssuranceCaseInput = {
    where: CaseStudyPublishedCaseWhereUniqueInput
    data: XOR<CaseStudyPublishedCaseUpdateWithoutPublishedAssuranceCaseInput, CaseStudyPublishedCaseUncheckedUpdateWithoutPublishedAssuranceCaseInput>
  }

  export type CaseStudyPublishedCaseUpdateManyWithWhereWithoutPublishedAssuranceCaseInput = {
    where: CaseStudyPublishedCaseScalarWhereInput
    data: XOR<CaseStudyPublishedCaseUpdateManyMutationInput, CaseStudyPublishedCaseUncheckedUpdateManyWithoutPublishedAssuranceCaseInput>
  }

  export type TeamMemberCreateManyUserInput = {
    id?: string
    teamId: string
    role?: $Enums.TeamRole
    invitedById?: string | null
    joinedAt?: Date | string
  }

  export type TeamCreateManyCreatedByInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    organisationId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssuranceCaseCreateManyCreatedByInput = {
    id?: string
    name: string
    description: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
  }

  export type CasePermissionCreateManyUserInput = {
    id?: string
    caseId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CasePermissionCreateManyGrantedByInput = {
    id?: string
    caseId: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedAt?: Date | string
  }

  export type AssuranceElementCreateManyCreatedByInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    caseId?: string | null
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyResolvedByInput = {
    id?: string
    caseId?: string | null
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseCommentCreateManyAuthorInput = {
    id?: string
    releaseId: string
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GitHubRepositoryCreateManyUserInput = {
    id?: string
    name: string
    url: string
    description?: string | null
    githubId?: string | null
    defaultBranch?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    revokedAt?: Date | string | null
    userAgent?: string | null
    ipAddress?: string | null
  }

  export type CaseStudyCreateManyOwnerInput = {
    id?: number
    title: string
    description?: string | null
    authors?: string | null
    category?: string | null
    publishedDate?: Date | string | null
    lastModifiedOn: Date | string
    createdOn: Date | string
    sector?: string | null
    contact?: string | null
    image?: string | null
    published: boolean
    type?: string | null
  }

  export type AssuranceCaseCreateManyMarkedReadyByInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    sourcePatternId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
  }

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    casePermissions?: CaseTeamPermissionUpdateManyWithoutTeamNestedInput
    patternPermissions?: PatternTeamPermissionUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    casePermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput
    patternPermissions?: PatternTeamPermissionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssuranceCaseUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CasePermissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutUserPermissionsNestedInput
    grantedBy?: UserUpdateOneRequiredWithoutGrantedPermissionsNestedInput
  }

  export type CasePermissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CasePermissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CasePermissionUpdateWithoutGrantedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutUserPermissionsNestedInput
    user?: UserUpdateOneRequiredWithoutCasePermissionsNestedInput
  }

  export type CasePermissionUncheckedUpdateWithoutGrantedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CasePermissionUncheckedUpdateManyWithoutGrantedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssuranceElementUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneWithoutCommentsNestedInput
    element?: AssuranceElementUpdateOneWithoutCommentsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneWithoutCommentsNestedInput
    element?: AssuranceElementUpdateOneWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthoredCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseCommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    release?: ReleaseUpdateOneRequiredWithoutCommentsNestedInput
    element?: AssuranceElementUpdateOneWithoutReleaseCommentsNestedInput
    parentComment?: ReleaseCommentUpdateOneWithoutRepliesNestedInput
    replies?: ReleaseCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReleaseCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GitHubRepositoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultBranch?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GitHubRepositoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultBranch?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GitHubRepositoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    githubId?: NullableStringFieldUpdateOperationsInput | string | null
    defaultBranch?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CaseStudyUpdateWithoutOwnerInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
    publishedCases?: CaseStudyPublishedCaseUpdateManyWithoutCaseStudyNestedInput
    featureImage?: CaseStudyImageUpdateOneWithoutCaseStudyNestedInput
  }

  export type CaseStudyUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
    publishedCases?: CaseStudyPublishedCaseUncheckedUpdateManyWithoutCaseStudyNestedInput
    featureImage?: CaseStudyImageUncheckedUpdateOneWithoutCaseStudyNestedInput
  }

  export type CaseStudyUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publishedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastModifiedOn?: DateTimeFieldUpdateOperationsInput | Date | string
    createdOn?: DateTimeFieldUpdateOperationsInput | Date | string
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    published?: BoolFieldUpdateOperationsInput | boolean
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssuranceCaseUpdateWithoutMarkedReadyByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    sourcePattern?: ArgumentPatternUpdateOneWithoutDerivedCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutMarkedReadyByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateManyWithoutMarkedReadyByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sourcePatternId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    userId: string
    role?: $Enums.TeamRole
    invitedById?: string | null
    joinedAt?: Date | string
  }

  export type CaseTeamPermissionCreateManyTeamInput = {
    id?: string
    caseId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternTeamPermissionCreateManyTeamInput = {
    id?: string
    patternId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumTeamRoleFieldUpdateOperationsInput | $Enums.TeamRole
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTeamPermissionUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutTeamPermissionsNestedInput
  }

  export type CaseTeamPermissionUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTeamPermissionUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternTeamPermissionUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: ArgumentPatternUpdateOneRequiredWithoutTeamPermissionsNestedInput
  }

  export type PatternTeamPermissionUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternTeamPermissionUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssuranceElementCreateManyCaseInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type CasePermissionCreateManyCaseInput = {
    id?: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CaseTeamPermissionCreateManyCaseInput = {
    id?: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type CaseInviteCreateManyCaseInput = {
    id?: string
    email: string
    permission: $Enums.PermissionLevel
    inviteToken: string
    inviteExpiresAt: Date | string
    acceptedAt?: Date | string | null
    acceptedById?: string | null
    invitedById: string
    createdAt?: Date | string
  }

  export type CommentCreateManyCaseInput = {
    id?: string
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CaseTypeAssignmentCreateManyCaseInput = {
    id?: string
    caseTypeId: string
    assignedById: string
    assignedAt?: Date | string
  }

  export type ReleaseCreateManySourceCaseInput = {
    id?: string
    publishedCaseId?: string | null
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseCreateManyPublishedCaseInput = {
    id?: string
    sourceCaseId: string
    title: string
    description: string
    currentVersion?: number
    authors: string
    contactEmail?: string | null
    category?: string | null
    sector?: string | null
    tags?: ReleaseCreatetagsInput | string[]
    status?: $Enums.ReleaseStatus
    firstPublishedAt?: Date | string | null
    lastUpdatedAt?: Date | string | null
    allowComments?: boolean
    createdById: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PublishedAssuranceCaseCreateManyAssuranceCaseInput = {
    id?: string
    title: string
    content: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    description?: string | null
  }

  export type AssuranceElementCreateManyModuleReferenceInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type AssuranceElementUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type CasePermissionUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCasePermissionsNestedInput
    grantedBy?: UserUpdateOneRequiredWithoutGrantedPermissionsNestedInput
  }

  export type CasePermissionUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CasePermissionUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTeamPermissionUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutCasePermissionsNestedInput
  }

  export type CaseTeamPermissionUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTeamPermissionUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseInviteUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    inviteToken?: StringFieldUpdateOperationsInput | string
    inviteExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseInviteUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    inviteToken?: StringFieldUpdateOperationsInput | string
    inviteExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseInviteUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    inviteToken?: StringFieldUpdateOperationsInput | string
    inviteExpiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedById?: NullableStringFieldUpdateOperationsInput | string | null
    invitedById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: AssuranceElementUpdateOneWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthoredCommentsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTypeAssignmentUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    caseType?: CaseTypeUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type CaseTypeAssignmentUncheckedUpdateWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTypeId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTypeAssignmentUncheckedUpdateManyWithoutCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseTypeId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseUpdateWithoutSourceCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedCase?: AssuranceCaseUpdateOneWithoutPublishedReleasesNestedInput
    snapshots?: ReleaseSnapshotUpdateManyWithoutReleaseNestedInput
    comments?: ReleaseCommentUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUpdateOneWithoutReleaseNestedInput
  }

  export type ReleaseUncheckedUpdateWithoutSourceCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    publishedCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshots?: ReleaseSnapshotUncheckedUpdateManyWithoutReleaseNestedInput
    comments?: ReleaseCommentUncheckedUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUncheckedUpdateOneWithoutReleaseNestedInput
  }

  export type ReleaseUncheckedUpdateManyWithoutSourceCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    publishedCaseId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseUpdateWithoutPublishedCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceCase?: AssuranceCaseUpdateOneRequiredWithoutSourceReleasesNestedInput
    snapshots?: ReleaseSnapshotUpdateManyWithoutReleaseNestedInput
    comments?: ReleaseCommentUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUpdateOneWithoutReleaseNestedInput
  }

  export type ReleaseUncheckedUpdateWithoutPublishedCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshots?: ReleaseSnapshotUncheckedUpdateManyWithoutReleaseNestedInput
    comments?: ReleaseCommentUncheckedUpdateManyWithoutReleaseNestedInput
    image?: ReleaseImageUncheckedUpdateOneWithoutReleaseNestedInput
  }

  export type ReleaseUncheckedUpdateManyWithoutPublishedCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    sourceCaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currentVersion?: IntFieldUpdateOperationsInput | number
    authors?: StringFieldUpdateOperationsInput | string
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    sector?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ReleaseUpdatetagsInput | string[]
    status?: EnumReleaseStatusFieldUpdateOperationsInput | $Enums.ReleaseStatus
    firstPublishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUpdatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    allowComments?: BoolFieldUpdateOperationsInput | boolean
    createdById?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublishedAssuranceCaseUpdateWithoutAssuranceCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudyLinks?: CaseStudyPublishedCaseUpdateManyWithoutPublishedAssuranceCaseNestedInput
  }

  export type PublishedAssuranceCaseUncheckedUpdateWithoutAssuranceCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudyLinks?: CaseStudyPublishedCaseUncheckedUpdateManyWithoutPublishedAssuranceCaseNestedInput
  }

  export type PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AssuranceElementUpdateWithoutModuleReferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutModuleReferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateManyWithoutModuleReferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type AssuranceElementCreateManyParentInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    defeatsElementId?: string | null
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type AssuranceElementCreateManyDefeatsElementInput = {
    id?: string
    caseId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    moduleReferenceId?: string | null
    moduleEmbedType?: $Enums.ModuleEmbedType | null
    modulePublicSummary?: string | null
    fromPattern?: boolean
    modifiedFromPattern?: boolean
    inSandbox?: boolean
    isDefeater?: boolean
    level?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type EvidenceLinkCreateManyEvidenceInput = {
    id?: string
    claimId: string
    createdAt?: Date | string
  }

  export type EvidenceLinkCreateManyClaimInput = {
    id?: string
    evidenceId: string
    createdAt?: Date | string
  }

  export type CommentCreateManyElementInput = {
    id?: string
    caseId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseCommentCreateManyElementInput = {
    id?: string
    releaseId: string
    parentCommentId?: string | null
    content: string
    authorId: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AssuranceElementUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatsElement?: AssuranceElementUpdateOneWithoutDefeatedByNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    defeatsElementId?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type AssuranceElementUpdateWithoutDefeatsElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutElementsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedElementsNestedInput
    parent?: AssuranceElementUpdateOneWithoutChildrenNestedInput
    children?: AssuranceElementUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUpdateManyWithoutDefeatsElementNestedInput
    moduleReference?: AssuranceCaseUpdateOneWithoutEmbeddedInNestedInput
    evidenceLinksFrom?: EvidenceLinkUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUpdateManyWithoutClaimNestedInput
    comments?: CommentUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateWithoutDefeatsElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    children?: AssuranceElementUncheckedUpdateManyWithoutParentNestedInput
    defeatedBy?: AssuranceElementUncheckedUpdateManyWithoutDefeatsElementNestedInput
    evidenceLinksFrom?: EvidenceLinkUncheckedUpdateManyWithoutEvidenceNestedInput
    evidenceLinksTo?: EvidenceLinkUncheckedUpdateManyWithoutClaimNestedInput
    comments?: CommentUncheckedUpdateManyWithoutElementNestedInput
    releaseComments?: ReleaseCommentUncheckedUpdateManyWithoutElementNestedInput
  }

  export type AssuranceElementUncheckedUpdateManyWithoutDefeatsElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    moduleReferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    moduleEmbedType?: NullableEnumModuleEmbedTypeFieldUpdateOperationsInput | $Enums.ModuleEmbedType | null
    modulePublicSummary?: NullableStringFieldUpdateOperationsInput | string | null
    fromPattern?: BoolFieldUpdateOperationsInput | boolean
    modifiedFromPattern?: BoolFieldUpdateOperationsInput | boolean
    inSandbox?: BoolFieldUpdateOperationsInput | boolean
    isDefeater?: BoolFieldUpdateOperationsInput | boolean
    level?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type EvidenceLinkUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    claim?: AssuranceElementUpdateOneRequiredWithoutEvidenceLinksToNestedInput
  }

  export type EvidenceLinkUncheckedUpdateWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceLinkUncheckedUpdateManyWithoutEvidenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    claimId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceLinkUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evidence?: AssuranceElementUpdateOneRequiredWithoutEvidenceLinksFromNestedInput
  }

  export type EvidenceLinkUncheckedUpdateWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    evidenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvidenceLinkUncheckedUpdateManyWithoutClaimInput = {
    id?: StringFieldUpdateOperationsInput | string
    evidenceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthoredCommentsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseCommentUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    release?: ReleaseUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutReleaseCommentsNestedInput
    parentComment?: ReleaseCommentUpdateOneWithoutRepliesNestedInput
    replies?: ReleaseCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentUncheckedUpdateWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReleaseCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentUncheckedUpdateManyWithoutElementInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternElementCreateManyPatternInput = {
    id?: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    parentId?: string | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatternPermissionCreateManyPatternInput = {
    id?: string
    userId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type PatternTeamPermissionCreateManyPatternInput = {
    id?: string
    teamId: string
    permission: $Enums.PermissionLevel
    grantedById: string
    grantedAt?: Date | string
  }

  export type AssuranceCaseCreateManySourcePatternInput = {
    id?: string
    name: string
    description: string
    createdById: string
    mode?: $Enums.CaseMode
    colorProfile?: string
    lockUuid?: string | null
    lockedById?: string | null
    lockedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    published?: boolean
    publishedAt?: Date | string | null
    publishStatus?: $Enums.PublishStatus
    markedReadyAt?: Date | string | null
    markedReadyById?: string | null
  }

  export type PatternElementUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: PatternElementUpdateOneWithoutChildrenNestedInput
    children?: PatternElementUpdateManyWithoutParentNestedInput
  }

  export type PatternElementUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PatternElementUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PatternElementUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternPermissionUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternPermissionUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternPermissionUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternTeamPermissionUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: TeamUpdateOneRequiredWithoutPatternPermissionsNestedInput
  }

  export type PatternTeamPermissionUncheckedUpdateWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatternTeamPermissionUncheckedUpdateManyWithoutPatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    permission?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    grantedById?: StringFieldUpdateOperationsInput | string
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssuranceCaseUpdateWithoutSourcePatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserUpdateOneRequiredWithoutCreatedCasesNestedInput
    markedReadyBy?: UserUpdateOneWithoutMarkedReadyCasesNestedInput
    elements?: AssuranceElementUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUpdateManyWithoutCaseNestedInput
    comments?: CommentUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateWithoutSourcePatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
    elements?: AssuranceElementUncheckedUpdateManyWithoutCaseNestedInput
    userPermissions?: CasePermissionUncheckedUpdateManyWithoutCaseNestedInput
    teamPermissions?: CaseTeamPermissionUncheckedUpdateManyWithoutCaseNestedInput
    invites?: CaseInviteUncheckedUpdateManyWithoutCaseNestedInput
    comments?: CommentUncheckedUpdateManyWithoutCaseNestedInput
    caseImage?: CaseImageUncheckedUpdateOneWithoutCaseNestedInput
    caseTypes?: CaseTypeAssignmentUncheckedUpdateManyWithoutCaseNestedInput
    sourceReleases?: ReleaseUncheckedUpdateManyWithoutSourceCaseNestedInput
    publishedReleases?: ReleaseUncheckedUpdateManyWithoutPublishedCaseNestedInput
    publishedVersions?: PublishedAssuranceCaseUncheckedUpdateManyWithoutAssuranceCaseNestedInput
    embeddedIn?: AssuranceElementUncheckedUpdateManyWithoutModuleReferenceNestedInput
  }

  export type AssuranceCaseUncheckedUpdateManyWithoutSourcePatternInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    mode?: EnumCaseModeFieldUpdateOperationsInput | $Enums.CaseMode
    colorProfile?: StringFieldUpdateOperationsInput | string
    lockUuid?: NullableStringFieldUpdateOperationsInput | string | null
    lockedById?: NullableStringFieldUpdateOperationsInput | string | null
    lockedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    published?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    publishStatus?: EnumPublishStatusFieldUpdateOperationsInput | $Enums.PublishStatus
    markedReadyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedReadyById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatternElementCreateManyParentInput = {
    id?: string
    patternId: string
    elementType: $Enums.ElementType
    role?: $Enums.ElementRole | null
    name?: string | null
    description: string
    assumption?: string | null
    justification?: string | null
    url?: string | null
    isPlaceholder?: boolean
    placeholderHint?: string | null
    displayOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatternElementUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pattern?: ArgumentPatternUpdateOneRequiredWithoutElementsNestedInput
    children?: PatternElementUpdateManyWithoutParentNestedInput
  }

  export type PatternElementUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: PatternElementUncheckedUpdateManyWithoutParentNestedInput
  }

  export type PatternElementUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patternId?: StringFieldUpdateOperationsInput | string
    elementType?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    role?: NullableEnumElementRoleFieldUpdateOperationsInput | $Enums.ElementRole | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    assumption?: NullableStringFieldUpdateOperationsInput | string | null
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    isPlaceholder?: BoolFieldUpdateOperationsInput | boolean
    placeholderHint?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseSnapshotCreateManyReleaseInput = {
    id?: string
    versionNumber: number
    versionLabel?: string | null
    content: JsonNullValueInput | InputJsonValue
    snapshotTakenAt: Date | string
    snapshotTakenById: string
    reason: $Enums.SnapshotReason
    createdAt?: Date | string
  }

  export type ReleaseCommentCreateManyReleaseInput = {
    id?: string
    elementId?: string | null
    parentCommentId?: string | null
    content: string
    authorId: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseSnapshotUpdateWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    snapshotTakenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotTakenById?: StringFieldUpdateOperationsInput | string
    reason?: EnumSnapshotReasonFieldUpdateOperationsInput | $Enums.SnapshotReason
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseSnapshotUncheckedUpdateWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    snapshotTakenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotTakenById?: StringFieldUpdateOperationsInput | string
    reason?: EnumSnapshotReasonFieldUpdateOperationsInput | $Enums.SnapshotReason
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseSnapshotUncheckedUpdateManyWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    versionNumber?: IntFieldUpdateOperationsInput | number
    versionLabel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    snapshotTakenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotTakenById?: StringFieldUpdateOperationsInput | string
    reason?: EnumSnapshotReasonFieldUpdateOperationsInput | $Enums.SnapshotReason
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseCommentUpdateWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: AssuranceElementUpdateOneWithoutReleaseCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutReleaseCommentsNestedInput
    parentComment?: ReleaseCommentUpdateOneWithoutRepliesNestedInput
    replies?: ReleaseCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentUncheckedUpdateWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReleaseCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentUncheckedUpdateManyWithoutReleaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReleaseCommentCreateManyParentCommentInput = {
    id?: string
    releaseId: string
    elementId?: string | null
    content: string
    authorId: string
    status?: $Enums.CommentStatus
    hiddenById?: string | null
    hiddenAt?: Date | string | null
    hiddenReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReleaseCommentUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    release?: ReleaseUpdateOneRequiredWithoutCommentsNestedInput
    element?: AssuranceElementUpdateOneWithoutReleaseCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutReleaseCommentsNestedInput
    replies?: ReleaseCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentUncheckedUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ReleaseCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type ReleaseCommentUncheckedUpdateManyWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    releaseId?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    status?: EnumCommentStatusFieldUpdateOperationsInput | $Enums.CommentStatus
    hiddenById?: NullableStringFieldUpdateOperationsInput | string | null
    hiddenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hiddenReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentCommentInput = {
    id?: string
    caseId?: string | null
    elementId?: string | null
    content: string
    authorId: string
    resolved?: boolean
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneWithoutCommentsNestedInput
    element?: AssuranceElementUpdateOneWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutAuthoredCommentsNestedInput
    resolvedBy?: UserUpdateOneWithoutResolvedCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: NullableStringFieldUpdateOperationsInput | string | null
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTypeAssignmentCreateManyCaseTypeInput = {
    id?: string
    caseId: string
    assignedById: string
    assignedAt?: Date | string
  }

  export type CaseTypeAssignmentUpdateWithoutCaseTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    case?: AssuranceCaseUpdateOneRequiredWithoutCaseTypesNestedInput
  }

  export type CaseTypeAssignmentUncheckedUpdateWithoutCaseTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseTypeAssignmentUncheckedUpdateManyWithoutCaseTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    caseId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CaseStudyPublishedCaseCreateManyCaseStudyInput = {
    id?: bigint | number
    publishedAssuranceCaseId: string
  }

  export type CaseStudyPublishedCaseUpdateWithoutCaseStudyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publishedAssuranceCase?: PublishedAssuranceCaseUpdateOneRequiredWithoutCaseStudyLinksNestedInput
  }

  export type CaseStudyPublishedCaseUncheckedUpdateWithoutCaseStudyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publishedAssuranceCaseId?: StringFieldUpdateOperationsInput | string
  }

  export type CaseStudyPublishedCaseUncheckedUpdateManyWithoutCaseStudyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    publishedAssuranceCaseId?: StringFieldUpdateOperationsInput | string
  }

  export type CaseStudyPublishedCaseCreateManyPublishedAssuranceCaseInput = {
    id?: bigint | number
    caseStudyId: number
  }

  export type CaseStudyPublishedCaseUpdateWithoutPublishedAssuranceCaseInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    caseStudy?: CaseStudyUpdateOneRequiredWithoutPublishedCasesNestedInput
  }

  export type CaseStudyPublishedCaseUncheckedUpdateWithoutPublishedAssuranceCaseInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    caseStudyId?: IntFieldUpdateOperationsInput | number
  }

  export type CaseStudyPublishedCaseUncheckedUpdateManyWithoutPublishedAssuranceCaseInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    caseStudyId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
