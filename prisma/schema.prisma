// TEA Platform Schema

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

generator dbml {
  provider            = "prisma-dbml-generator"
  output              = "../docs/database"
  outputName          = "schema.dbml"
  projectName         = "TEA Platform"
  projectDatabaseType = "PostgreSQL"
  manyToMany          = false // Disabled: prevents spurious CommentThread join table from self-referential relations
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USERS & AUTHENTICATION
// ============================================

/// Platform user account. Supports local (email/password) and GitHub OAuth authentication.
model User {
  id                   String       @id @default(uuid())
  email                String       @unique /// Primary email address, used for login and notifications
  username             String       @unique /// Unique display name shown throughout the platform
  passwordHash         String?      @map("password_hash") /// Hashed password (null for OAuth-only users)
  passwordAlgorithm    String       @default("django_pbkdf2") @map("password_algorithm") /// Hash algorithm: 'argon2id' (new) or 'django_pbkdf2' (legacy)

  // Profile
  firstName            String?      @map("first_name") /// User's first name for display
  lastName             String?      @map("last_name") /// User's last name for display
  avatarUrl            String?      @map("avatar_url") /// Profile picture URL (from GitHub or uploaded)

  // Authentication
  authProvider         AuthProvider @default(LOCAL) @map("auth_provider")
  githubId             String?      @unique @map("github_id")
  githubUsername       String?      @map("github_username")
  githubAccessToken    String?      @map("github_access_token") /// Encrypted GitHub OAuth access token for API calls
  githubTokenExpiresAt DateTime?    @map("github_token_expires_at") /// Expiry timestamp for the GitHub token

  // Google OAuth
  googleId             String?      @unique @map("google_id") /// Google account ID for OAuth
  googleEmail          String?      @map("google_email") /// Google email address
  googleAccessToken    String?      @map("google_access_token") /// Google OAuth access token for Drive API calls
  googleRefreshToken   String?      @map("google_refresh_token") /// Google OAuth refresh token (tokens expire after 1 hour)
  googleTokenExpiresAt DateTime?    @map("google_token_expires_at") /// Expiry timestamp for the Google access token

  emailVerified        Boolean      @default(false) @map("email_verified") /// Whether email has been verified (for email-based signup)

  // Password reset
  passwordResetToken   String?      @map("password_reset_token")
  passwordResetExpires DateTime?    @map("password_reset_expires")

  // Preferences
  defaultCaseMode      CaseMode     @default(STANDARD) @map("default_case_mode") /// Default view mode for new cases: STANDARD (simplified) or ADVANCED (full GSN notation)

  // Migration notice tracking
  hasSeenMigrationNotice Boolean    @default(false) @map("has_seen_migration_notice") /// Whether user has dismissed the Django-to-Next.js migration notice

  // System flag
  isSystemUser         Boolean      @default(false) @map("is_system_user") /// True for system/bot accounts (e.g., automated imports)

  // Timestamps
  createdAt            DateTime     @default(now()) @map("created_at")
  updatedAt            DateTime     @updatedAt @map("updated_at")
  lastLoginAt          DateTime?    @map("last_login_at") /// Most recent login timestamp for audit purposes

  // Relations
  teamMemberships      TeamMember[]
  createdTeams         Team[]             @relation("TeamCreator")
  createdCases         AssuranceCase[]    @relation("CaseCreator")
  casePermissions      CasePermission[]   @relation("PermissionHolder")
  grantedPermissions   CasePermission[]   @relation("PermissionGranter")
  createdElements      AssuranceElement[] @relation("ElementCreator")
  authoredComments     Comment[]          @relation("CommentAuthor")
  resolvedComments     Comment[]          @relation("CommentResolver")
  releaseComments      ReleaseComment[]
  githubRepositories   GitHubRepository[]
  caseStudies          CaseStudy[]
  markedReadyCases     AssuranceCase[]    @relation("CaseMarkedReady")
  deletedCases         AssuranceCase[]    @relation("CaseDeleter")

  @@map("users")
}

enum AuthProvider {
  LOCAL
  GITHUB
  GOOGLE
  SYSTEM
}

enum CaseMode {
  STANDARD
  ADVANCED
}

enum PublishStatus {
  DRAFT
  READY_TO_PUBLISH
  PUBLISHED
}

// ============================================
// PASSWORD RESET & SECURITY AUDIT
// ============================================

/// Tracks password reset attempts for rate limiting and security monitoring.
model PasswordResetAttempt {
  id          String   @id @default(uuid())
  email       String
  ipAddress   String   @map("ip_address")
  attemptedAt DateTime @default(now()) @map("attempted_at")
  successful  Boolean  @default(false)

  @@index([email, attemptedAt])
  @@index([ipAddress, attemptedAt])
  @@map("password_reset_attempts")
}

/// Security event log for auditing authentication and authorization events.
model SecurityAuditLog {
  id        String   @id @default(uuid())
  userId    String?  @map("user_id")
  eventType String   @map("event_type") /// Event type: login_success, login_failed, password_change, etc.
  ipAddress String?  @map("ip_address")
  userAgent String?  @map("user_agent")
  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
  @@map("security_audit_logs")
}

/// Tracks API endpoint access for rate limiting. Used to prevent abuse of sensitive endpoints.
model RateLimitAttempt {
  id             String   @id @default(uuid())
  endpoint       String   /// Endpoint identifier, e.g., "register", "invite_accept", "password_reset"
  identifier     String   /// The rate-limited identifier (IP address, email, or user ID)
  identifierType String   @map("identifier_type") /// Type of identifier: "ip", "email", or "user_id"
  attemptedAt    DateTime @default(now()) @map("attempted_at")
  blocked        Boolean  @default(false) /// True if this attempt was rate-limited/rejected
  metadata       Json?    /// Additional context (request details, etc.)

  @@index([endpoint, identifier, attemptedAt])
  @@index([endpoint, identifierType, attemptedAt])
  @@index([attemptedAt]) // For cleanup queries
  @@map("rate_limit_attempts")
}

// ============================================
// TEAMS
// ============================================

/// Team for collaborative work with role-based access (OWNER, ADMIN, MEMBER). Replaces legacy Django "Group".
model Team {
  id                 String                  @id @default(uuid())
  name               String                  /// Display name of the team
  slug               String                  @unique /// URL-safe identifier for the team
  description        String?

  // Future: Organisation support
  organisationId     String?                 @map("organisation_id")

  // Timestamps
  createdAt          DateTime                @default(now()) @map("created_at")
  updatedAt          DateTime                @updatedAt @map("updated_at")
  createdById        String                  @map("created_by_id")

  // Relations
  createdBy          User                    @relation("TeamCreator", fields: [createdById], references: [id])
  members            TeamMember[]
  casePermissions    CaseTeamPermission[]
  patternPermissions PatternTeamPermission[]

  @@map("teams")
}

/// Junction table linking users to teams with role-based access.
model TeamMember {
  id          String   @id @default(uuid())
  teamId      String   @map("team_id")
  userId      String   @map("user_id")
  role        TeamRole @default(MEMBER) /// OWNER can delete team, ADMIN can manage members, MEMBER has basic access

  invitedById String?  @map("invited_by_id")
  joinedAt    DateTime @default(now()) @map("joined_at")

  // Relations
  team        Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([teamId, userId])
  @@map("team_members")
}

enum TeamRole {
  OWNER
  ADMIN
  MEMBER
}

// ============================================
// ASSURANCE CASES
// ============================================

/// Structured argument with goals, strategies, property claims, and evidence demonstrating system trustworthiness.
// Key features: 3-state publish workflow, permission-based access, element comments, snapshots.
model AssuranceCase {
  id              String                @id @default(uuid())
  name            String                /// Title of the assurance case
  description     String                /// Summary describing the case's purpose and scope

  // Creator (for audit, NOT ownership)
  createdById     String                @map("created_by_id") /// User who created the case (for audit trail)

  // Mode
  mode            CaseMode              @default(STANDARD) /// STANDARD (simplified UI) or ADVANCED (full GSN notation)

  // Visual settings
  colorProfile    String                @default("default") @map("color_profile") /// Colour scheme for the case diagram

  // Pattern tracking
  sourcePatternId String?               @map("source_pattern_id") /// If created from a pattern, the source pattern ID

  // Timestamps
  createdAt       DateTime              @default(now()) @map("created_at")
  updatedAt       DateTime              @updatedAt @map("updated_at")

  // Publishing (legacy boolean kept for backward compatibility)
  published       Boolean               @default(false)
  publishedAt     DateTime?             @map("published_at")

  // Publishing - 3-state workflow
  publishStatus     PublishStatus         @default(DRAFT) @map("publish_status") /// DRAFT, READY_TO_PUBLISH, or PUBLISHED
  markedReadyAt     DateTime?             @map("marked_ready_at") /// When owner marked case as ready to publish
  markedReadyById   String?               @map("marked_ready_by_id") /// Who marked the case as ready

  // Soft delete (recycle bin)
  deletedAt         DateTime?             @map("deleted_at") /// When the case was moved to trash (null = not deleted)
  deletedBy         String?               @map("deleted_by_id") /// User ID who deleted the case

  // Relations
  createdBy       User                  @relation("CaseCreator", fields: [createdById], references: [id])
  markedReadyBy   User?                 @relation("CaseMarkedReady", fields: [markedReadyById], references: [id])
  deletedByUser   User?                 @relation("CaseDeleter", fields: [deletedBy], references: [id])
  sourcePattern   ArgumentPattern?      @relation(fields: [sourcePatternId], references: [id])
  elements        AssuranceElement[]
  userPermissions CasePermission[]
  teamPermissions CaseTeamPermission[]
  invites         CaseInvite[]
  comments        Comment[]
  caseImage       CaseImage?
  caseTypes       CaseTypeAssignment[]

  // Release relations
  sourceReleases    Release[] @relation("SourceCase")
  publishedReleases Release[] @relation("PublishedCase")

  // Published versions (legacy model for case study integration)
  publishedVersions PublishedAssuranceCase[]

  // Module references (cases that embed this one)
  embeddedIn        AssuranceElement[] @relation("ModuleReference")

  @@index([publishStatus], map: "assurance_cases_publish_status_idx")
  @@index([createdById, publishStatus], map: "assurance_cases_created_by_status_idx")
  @@index([deletedAt], map: "assurance_cases_deleted_at_idx")
  @@index([createdById, deletedAt], map: "assurance_cases_owner_deleted_idx")
  @@map("assurance_cases")
}

/// Grants a user permission to access a specific assurance case.
model CasePermission {
  id          String          @id @default(uuid())
  caseId      String          @map("case_id")
  userId      String          @map("user_id")
  permission  PermissionLevel /// VIEW, COMMENT, EDIT, or ADMIN

  grantedById String          @map("granted_by_id")
  grantedAt   DateTime        @default(now()) @map("granted_at")

  // Relations
  case        AssuranceCase   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  user        User            @relation("PermissionHolder", fields: [userId], references: [id], onDelete: Cascade)
  grantedBy   User            @relation("PermissionGranter", fields: [grantedById], references: [id])

  @@unique([caseId, userId])
  @@map("case_permissions")
}

/// Grants a team permission to access a specific assurance case. All team members inherit this permission.
model CaseTeamPermission {
  id          String          @id @default(uuid())
  caseId      String          @map("case_id")
  teamId      String          @map("team_id")
  permission  PermissionLevel /// VIEW, COMMENT, EDIT, or ADMIN

  grantedById String          @map("granted_by_id")
  grantedAt   DateTime        @default(now()) @map("granted_at")

  // Relations
  case        AssuranceCase   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  team        Team            @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([caseId, teamId])
  @@map("case_team_permissions")
}

enum PermissionLevel {
  VIEW
  COMMENT
  EDIT
  ADMIN
}

/// Pending invitation to collaborate on a case. Sent via email with a unique token link.
model CaseInvite {
  id              String    @id @default(uuid())
  caseId          String    @map("case_id")
  email           String    /// Email address of the invitee
  permission      PermissionLevel /// Permission level granted when accepted

  inviteToken     String    @unique @map("invite_token") /// Unique token for the invite URL
  inviteExpiresAt DateTime  @map("invite_expires_at") /// Invitation expiry timestamp
  acceptedAt      DateTime? @map("accepted_at") /// When the invite was accepted (null if pending)
  acceptedById    String?   @map("accepted_by_id") /// User who accepted (may differ from email if account existed)

  invitedById     String    @map("invited_by_id")
  createdAt       DateTime  @default(now()) @map("created_at")

  // Relations
  case            AssuranceCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@map("case_invites")
}

// ============================================
// ASSURANCE ELEMENTS (CONSOLIDATED)
// ============================================

/// Node in the assurance case hierarchy: GOAL, STRATEGY, PROPERTY_CLAIM, EVIDENCE, CONTEXT, MODULE, etc.
// Hierarchy: GOAL → STRATEGY → PROPERTY_CLAIM. Evidence linked via EvidenceLink (many-to-many).
// CONTEXT as element type is legacy - prefer context[] field. parentId=null for roots, role=TOP_LEVEL/SUPPORTING.
model AssuranceElement {
  id                  String           @id @default(uuid())
  caseId              String           @map("case_id")

  // Element classification
  elementType         ElementType      @map("element_type") /// Type of element: GOAL, STRATEGY, PROPERTY_CLAIM, EVIDENCE, CONTEXT, MODULE, etc.
  role                ElementRole?     /// TOP_LEVEL (root elements) or SUPPORTING (child elements)

  // Hierarchy
  parentId            String?          @map("parent_id") /// Parent element ID (null for root elements)

  // Common fields
  name                String?          /// Short identifier/title for the element
  description         String           /// Main content/description of the element

  // GSN-specific fields (applicable to GOAL, STRATEGY, PROPERTY_CLAIM only)
  assumption          String?          /// Assumptions upon which this element depends
  justification       String?          /// Rationale for strategies explaining the decomposition approach
  context             String[]         @default([]) /// Contextual information strings (replaces legacy CONTEXT element type)

  // Evidence-specific (EVIDENCE elements only)
  url                 String?          /// Primary URL (legacy). Auto-synced: when urls[] is set, url = urls[0]
  urls                String[]         @default([]) /// Multiple evidence URLs. Must be valid http/https URLs

  // Module-specific
  moduleReferenceId   String?          @map("module_reference_id") /// For MODULE type: the referenced case ID
  moduleEmbedType     ModuleEmbedType? @map("module_embed_type") /// COPY (snapshot) or REFERENCE (live link)
  modulePublicSummary String?          @map("module_public_summary") /// Public summary when module is not viewable

  // Pattern tracking
  fromPattern         Boolean          @default(false) @map("from_pattern") /// True if element came from a pattern template
  modifiedFromPattern Boolean          @default(false) @map("modified_from_pattern") /// True if element was modified after pattern application

  // Sandbox/draft status
  inSandbox           Boolean          @default(false) @map("in_sandbox") /// True if element is in draft/sandbox mode

  // Dialogical reasoning (defeaters)
  isDefeater          Boolean          @default(false) @map("is_defeater") /// True if element is a counter-argument
  defeatsElementId    String?          @map("defeats_element_id") /// Element this defeater challenges

  // Level (calculated, for property claims)
  level               Int?             /// Hierarchy depth level for property claims

  // Timestamps
  createdAt           DateTime         @default(now()) @map("created_at")
  updatedAt           DateTime         @updatedAt @map("updated_at")
  createdById         String           @map("created_by_id")

  // Relations
  case                AssuranceCase    @relation(fields: [caseId], references: [id], onDelete: Cascade)
  createdBy           User             @relation("ElementCreator", fields: [createdById], references: [id])
  parent              AssuranceElement? @relation("ElementHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children            AssuranceElement[] @relation("ElementHierarchy")
  defeatsElement      AssuranceElement? @relation("Defeater", fields: [defeatsElementId], references: [id])
  defeatedBy          AssuranceElement[] @relation("Defeater")
  moduleReference     AssuranceCase?   @relation("ModuleReference", fields: [moduleReferenceId], references: [id])

  // Evidence many-to-many
  evidenceLinksFrom   EvidenceLink[]   @relation("EvidenceSource")
  evidenceLinksTo     EvidenceLink[]   @relation("EvidenceTarget")

  comments            Comment[]
  releaseComments     ReleaseComment[]

  @@index([caseId])
  @@index([caseId, elementType])
  @@index([parentId])
  @@map("assurance_elements")
}

enum ElementType {
  GOAL
  CONTEXT
  STRATEGY
  PROPERTY_CLAIM
  EVIDENCE
  JUSTIFICATION
  ASSUMPTION
  MODULE
  AWAY_GOAL
  CONTRACT
}

enum ElementRole {
  TOP_LEVEL
  SUPPORTING
}

enum ModuleEmbedType {
  COPY
  REFERENCE
}

/// Links evidence elements to claims (many-to-many). One piece of evidence can support multiple claims.
model EvidenceLink {
  id         String           @id @default(uuid())
  evidenceId String           @map("evidence_id") /// The evidence element
  claimId    String           @map("claim_id") /// The claim being supported

  createdAt  DateTime         @default(now()) @map("created_at")

  // Relations
  evidence   AssuranceElement @relation("EvidenceSource", fields: [evidenceId], references: [id], onDelete: Cascade)
  claim      AssuranceElement @relation("EvidenceTarget", fields: [claimId], references: [id], onDelete: Cascade)

  @@unique([evidenceId, claimId])
  @@map("evidence_links")
}

// ============================================
// ARGUMENT PATTERNS
// ============================================

/// Reusable template for creating assurance cases with optional placeholder elements for customisation.
model ArgumentPattern {
  id              String                  @id @default(uuid())
  name            String                  /// Pattern title
  description     String                  /// Description of what this pattern covers
  version         String                  /// Version string (e.g., "1.0", "2.1")

  // Categorisation
  category        String?
  tags            String[]

  // Publishing
  published       Boolean                 @default(false)
  publishedAt     DateTime?               @map("published_at")

  // Creator
  createdById     String                  @map("created_by_id")

  // Timestamps
  createdAt       DateTime                @default(now()) @map("created_at")
  updatedAt       DateTime                @updatedAt @map("updated_at")

  // Relations
  elements        PatternElement[]
  userPermissions PatternPermission[]
  teamPermissions PatternTeamPermission[]
  derivedCases    AssuranceCase[]

  @@map("argument_patterns")
}

/// Element within an argument pattern. Includes placeholder support for customisation on instantiation.
model PatternElement {
  id              String         @id @default(uuid())
  patternId       String         @map("pattern_id")

  // Same structure as AssuranceElement
  elementType     ElementType    @map("element_type")
  role            ElementRole?
  parentId        String?        @map("parent_id")
  name            String?
  description     String

  // GSN-specific fields (same as AssuranceElement)
  assumption      String?
  justification   String?
  context         String[]       @default([])

  // Evidence-specific
  url             String?

  // Placeholder support (pattern-specific)
  isPlaceholder   Boolean        @default(false) @map("is_placeholder") /// True if this element should be filled in when pattern is used
  placeholderHint String?        @map("placeholder_hint") /// Guidance text for filling in placeholder

  // Ordering
  displayOrder    Int            @default(0) @map("display_order")

  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")

  // Relations
  pattern         ArgumentPattern @relation(fields: [patternId], references: [id], onDelete: Cascade)
  parent          PatternElement? @relation("PatternHierarchy", fields: [parentId], references: [id], onDelete: Cascade)
  children        PatternElement[] @relation("PatternHierarchy")

  @@map("pattern_elements")
}

model PatternPermission {
  id          String          @id @default(uuid())
  patternId   String          @map("pattern_id")
  userId      String          @map("user_id")
  permission  PermissionLevel

  grantedById String          @map("granted_by_id")
  grantedAt   DateTime        @default(now()) @map("granted_at")

  pattern     ArgumentPattern @relation(fields: [patternId], references: [id], onDelete: Cascade)

  @@unique([patternId, userId])
  @@map("pattern_permissions")
}

model PatternTeamPermission {
  id          String          @id @default(uuid())
  patternId   String          @map("pattern_id")
  teamId      String          @map("team_id")
  permission  PermissionLevel

  grantedById String          @map("granted_by_id")
  grantedAt   DateTime        @default(now()) @map("granted_at")

  pattern     ArgumentPattern @relation(fields: [patternId], references: [id], onDelete: Cascade)
  team        Team            @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([patternId, teamId])
  @@map("pattern_team_permissions")
}

// ============================================
// RELEASES (PUBLISHING)
// ============================================

/// Published release of an assurance case for community viewing with version history and comments.
model Release {
  id               String        @id @default(uuid())

  // Source case (user's private version)
  sourceCaseId     String        @map("source_case_id") /// Original case this release was created from

  // Published case (community-visible fork)
  publishedCaseId  String?       @map("published_case_id") /// Read-only community copy of the case

  // Metadata
  title            String        /// Published title (may differ from source case)
  description      String        /// Public description of the release
  currentVersion   Int           @default(0) @map("current_version") /// Current version number

  // Authors
  authors          String
  contactEmail     String?       @map("contact_email")

  // Categorisation
  category         String?
  sector           String?
  tags             String[]

  // Status
  status           ReleaseStatus @default(DRAFT)
  firstPublishedAt DateTime?     @map("first_published_at")
  lastUpdatedAt    DateTime?     @map("last_updated_at")

  // Community settings
  allowComments    Boolean       @default(true) @map("allow_comments")

  // Creator
  createdById      String        @map("created_by_id")

  // Timestamps
  createdAt        DateTime      @default(now()) @map("created_at")
  updatedAt        DateTime      @updatedAt @map("updated_at")

  // Relations
  sourceCase       AssuranceCase     @relation("SourceCase", fields: [sourceCaseId], references: [id])
  publishedCase    AssuranceCase?    @relation("PublishedCase", fields: [publishedCaseId], references: [id])
  snapshots        ReleaseSnapshot[]
  comments         ReleaseComment[]
  image            ReleaseImage?

  @@map("releases")
}

enum ReleaseStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

/// Point-in-time snapshot of a release. Captures the full case content as JSON for version history.
model ReleaseSnapshot {
  id                String         @id @default(uuid())
  releaseId         String         @map("release_id")

  // Version tracking
  versionNumber     Int            @map("version_number") /// Sequential version number
  versionLabel      String?        @map("version_label") /// Optional human-readable label (e.g., "v2.0-beta")

  // Full case data as JSON
  content           Json           /// Complete case content serialised as JSON

  // Metadata
  snapshotTakenAt   DateTime       @map("snapshot_taken_at")
  snapshotTakenById String         @map("snapshot_taken_by_id")
  reason            SnapshotReason

  createdAt         DateTime       @default(now()) @map("created_at")

  // Relations
  release           Release        @relation(fields: [releaseId], references: [id], onDelete: Cascade)

  @@map("release_snapshots")
}

enum SnapshotReason {
  INITIAL_PUBLISH
  UPDATE
  ARCHIVE
}

/// Community comment on a published release. Supports threading and moderation.
model ReleaseComment {
  id              String           @id @default(uuid())
  releaseId       String           @map("release_id")
  elementId       String?          @map("element_id") /// If set, comment is on a specific element

  parentCommentId String?          @map("parent_comment_id") /// For threaded replies
  content         String           /// Comment text (supports markdown)

  authorId        String           @map("author_id")

  // Moderation
  status          CommentStatus    @default(VISIBLE) /// VISIBLE, HIDDEN, or DELETED
  hiddenById      String?          @map("hidden_by_id")
  hiddenAt        DateTime?        @map("hidden_at")
  hiddenReason    String?          @map("hidden_reason")

  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")

  // Relations
  release         Release          @relation(fields: [releaseId], references: [id], onDelete: Cascade)
  element         AssuranceElement? @relation(fields: [elementId], references: [id])
  author          User             @relation(fields: [authorId], references: [id])
  parentComment   ReleaseComment?  @relation("CommentThread", fields: [parentCommentId], references: [id])
  replies         ReleaseComment[] @relation("CommentThread")

  @@map("release_comments")
}

enum CommentStatus {
  VISIBLE
  HIDDEN
  DELETED
}

model ReleaseImage {
  id           String   @id @default(uuid())
  releaseId    String   @unique @map("release_id")
  imageUrl     String   @map("image_url")
  altText      String?  @map("alt_text")
  uploadedAt   DateTime @map("uploaded_at")
  uploadedById String   @map("uploaded_by_id")

  release      Release  @relation(fields: [releaseId], references: [id], onDelete: Cascade)

  @@map("release_images")
}

// ============================================
// COMMENTS (INTERNAL)
// ============================================

/// Internal comment for collaboration between case editors. Distinct from ReleaseComment (public).
model Comment {
  id              String           @id @default(uuid())

  // Polymorphic attachment
  caseId          String?          @map("case_id") /// Case-level comment if set
  elementId       String?          @map("element_id") /// Element-level comment if set

  // Threading
  parentCommentId String?          @map("parent_comment_id") /// For threaded replies

  content         String           /// Comment text
  authorId        String           @map("author_id")

  // Status
  resolved        Boolean          @default(false) /// True when the feedback has been addressed
  resolvedById    String?          @map("resolved_by_id") /// Who marked it resolved
  resolvedAt      DateTime?        @map("resolved_at") /// When it was resolved

  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")

  // Relations
  case            AssuranceCase?   @relation(fields: [caseId], references: [id], onDelete: Cascade)
  element         AssuranceElement? @relation(fields: [elementId], references: [id], onDelete: Cascade)
  author          User             @relation("CommentAuthor", fields: [authorId], references: [id])
  resolvedBy      User?            @relation("CommentResolver", fields: [resolvedById], references: [id])
  parentComment   Comment?         @relation("CommentThread", fields: [parentCommentId], references: [id])
  replies         Comment[]        @relation("CommentThread")

  @@map("comments")
}

// ============================================
// SUPPORTING ENTITIES
// ============================================

/// Cover/thumbnail image for an assurance case. One image per case.
model CaseImage {
  id           String        @id @default(uuid())
  caseId       String        @unique @map("case_id")
  imageUrl     String        @map("image_url") /// URL or path to the image file
  uploadedAt   DateTime      @map("uploaded_at")
  uploadedById String        @map("uploaded_by_id")

  case         AssuranceCase @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@map("case_images")
}

/// Classification type for assurance cases: DOMAIN (healthcare), TECHNIQUE (ML safety), STANDARD (ISO 26262).
model CaseType {
  id          String               @id @default(uuid())
  name        String               @unique /// Display name of the type
  description String?              /// Description of what this type covers
  category    CaseTypeCategory     /// DOMAIN, TECHNIQUE, or STANDARD
  externalUrl String?              @map("external_url") /// Link to external standard/reference
  createdAt   DateTime             @default(now()) @map("created_at")

  assignments CaseTypeAssignment[]

  @@map("case_types")
}

enum CaseTypeCategory {
  DOMAIN
  TECHNIQUE
  STANDARD
}

/// Junction table assigning case types to assurance cases. Allows multiple types per case.
model CaseTypeAssignment {
  id           String        @id @default(uuid())
  caseId       String        @map("case_id")
  caseTypeId   String        @map("case_type_id")
  assignedById String        @map("assigned_by_id")
  assignedAt   DateTime      @default(now()) @map("assigned_at")

  case         AssuranceCase @relation(fields: [caseId], references: [id], onDelete: Cascade)
  caseType     CaseType      @relation(fields: [caseTypeId], references: [id], onDelete: Cascade)

  @@unique([caseId, caseTypeId])
  @@map("case_type_assignments")
}

/// GitHub repository linked to a user account. Used for evidence gathering and repository integration.
model GitHubRepository {
  id            String   @id @default(uuid())
  name          String   /// Repository name
  url           String   /// Full GitHub URL
  description   String?  /// Repository description

  githubId      String?  @map("github_id") /// GitHub's internal repository ID
  defaultBranch String   @default("main") @map("default_branch") /// Default branch name

  userId        String   @map("user_id") /// Owner of this repository link

  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("github_repositories")
}

// ============================================
// CASE STUDIES
// ============================================

/// Public community document showcasing published assurance cases with narrative context.
// Distinct from AssuranceCase (the structured argument). Links to PublishedAssuranceCase snapshots.
// When creating, READY_TO_PUBLISH cases are automatically published and linked.
model CaseStudy {
  id             Int       @id @default(autoincrement()) @map("id")
  title          String    @db.VarChar(255) /// Case study title
  description    String?   /// Full description/narrative
  authors        String?   @db.VarChar(255) /// Author names
  category       String?   @db.VarChar(100) /// Category (e.g., "Healthcare", "Automotive")
  publishedDate  DateTime? @map("published_date") @db.Timestamptz(6) /// When first published
  lastModifiedOn DateTime  @map("last_modified_on") @db.Timestamptz(6)
  createdOn      DateTime  @map("created_on") @db.Timestamptz(6)
  sector         String?   @db.VarChar(100) /// Industry sector
  contact        String?   @db.VarChar(254) /// Contact email
  image          String?   @db.VarChar(200) /// Legacy image path
  published      Boolean   /// Whether the case study is publicly visible
  ownerId        String?   @map("owner_id") /// Creator/owner of the case study
  type           String?   @db.VarChar(100) /// Case study type classification

  // Relations
  owner          User?                    @relation(fields: [ownerId], references: [id])
  publishedCases CaseStudyPublishedCase[]
  featureImage   CaseStudyImage?

  @@index([ownerId], map: "case_studies_owner_id_idx")
  @@map("case_studies")
}

/// Junction table linking case studies to published assurance case snapshots.
// Auto-publishes READY_TO_PUBLISH cases, creates links, migrates when published case is updated.
model CaseStudyPublishedCase {
  id                      BigInt                @id @default(autoincrement())
  caseStudyId             Int                   @map("casestudy_id") /// The case study
  publishedAssuranceCaseId String               @map("publishedassurancecase_id") @db.Uuid /// The published case

  // Relations
  caseStudy               CaseStudy             @relation(fields: [caseStudyId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  publishedAssuranceCase  PublishedAssuranceCase @relation(fields: [publishedAssuranceCaseId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([caseStudyId, publishedAssuranceCaseId], map: "case_study_published_cases_unique")
  @@index([caseStudyId], map: "case_study_published_cases_case_study_id_idx")
  @@index([publishedAssuranceCaseId], map: "case_study_published_cases_published_case_id_idx")
  @@map("case_study_published_cases")
}

/// Feature image for a case study. One image per case study.
model CaseStudyImage {
  id          BigInt    @id @default(autoincrement())
  image       String    @db.VarChar(500) /// Image URL or path
  uploadedAt  DateTime  @map("uploaded_at") @db.Timestamptz(6)
  caseStudyId Int       @unique @map("case_study_id")

  // Relations
  caseStudy   CaseStudy @relation(fields: [caseStudyId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@map("case_study_images")
}

/// Snapshot of an assurance case for case study integration. Content stored as JSON.
// Multiple versions per case (history). Distinct from Release model (for community releases).
model PublishedAssuranceCase {
  id              String   @id @default(uuid()) @db.Uuid
  title           String   @db.VarChar(255) /// Title at time of publishing
  content         Json     /// Full case content as JSON snapshot
  createdAt       DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  assuranceCaseId String   @map("assurance_case_id") /// Source case this was published from
  description     String?  @db.VarChar(1000) /// Description at time of publishing

  // Relations
  assuranceCase   AssuranceCase            @relation(fields: [assuranceCaseId], references: [id])
  caseStudyLinks  CaseStudyPublishedCase[]

  @@index([assuranceCaseId], map: "published_assurance_cases_assurance_case_id_idx")
  @@map("published_assurance_cases")
}

// ============================================
// LEGACY MAPPING (for migration tracking)
// ============================================

/// Django-to-Prisma ID mappings from Dec 2025 migration. See issue AssurancePlatform-ogq for cleanup.
model LegacyMapping {
  id          String   @id @default(uuid())
  entityType  String   @map("entity_type") /// Entity type: 'user', 'case', 'element', 'team', etc.
  legacyId    BigInt   @map("legacy_id") /// Old Django integer ID
  newId       String   @map("new_id") /// New Prisma UUID
  createdAt   DateTime @default(now()) @map("created_at")

  @@unique([entityType, legacyId])
  @@index([entityType, newId])
  @@map("legacy_mappings")
}
