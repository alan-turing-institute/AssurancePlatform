/**
 * Evidence List template preset.
 *
 * Focused list of all evidence items with URLs and descriptions.
 * Useful for creating an evidence register or checklist.
 */

import type { CaseExportNested, TreeNode } from "@/lib/schemas/case-export";
import type { BrandingConfig } from "../../schemas/branding-config";
import { DEFAULT_SECTIONS_EVIDENCE_LIST } from "../../schemas/section-config";
import type { TemplateConfig } from "../../schemas/template-config";
import type { ContentBlock, DiagramImage, RenderedSection } from "../../types";
import { ELEMENT_TYPE_LABELS } from "../../types";
import { truncateText } from "../../utils/content-helpers";
import { BaseTemplate } from "../base-template";
import { collectElementsByType } from "../renderers/tree-renderer";

/**
 * Evidence List configuration
 */
export const EVIDENCE_LIST_CONFIG: TemplateConfig = {
	name: "Evidence List",
	description: "Focused list of all evidence items with URLs and descriptions",
	preset: "evidence-list",
	sections: DEFAULT_SECTIONS_EVIDENCE_LIST,
	elementFilter: {
		includeTypes: ["EVIDENCE"],
	},
};

/**
 * Evidence List template implementation
 */
export class EvidenceListTemplate extends BaseTemplate {
	constructor(branding?: Partial<BrandingConfig>) {
		super(EVIDENCE_LIST_CONFIG, branding);
	}

	protected renderSections(
		caseData: CaseExportNested,
		_diagramImage?: DiagramImage
	): RenderedSection[] {
		const sections: RenderedSection[] = [];
		const tree = caseData.tree;

		if (this.isSectionEnabled("titlePage")) {
			sections.push(this.renderTitlePage(caseData));
		}

		if (this.isSectionEnabled("evidence")) {
			sections.push(this.renderEvidenceSection(tree));
		}

		if (this.isSectionEnabled("metadata")) {
			sections.push(this.renderMetadataSection(caseData));
		}

		return sections;
	}

	private renderTitlePage(caseData: CaseExportNested): RenderedSection {
		const blocks: ContentBlock[] = [
			this.heading(1, `${caseData.case.name} - Evidence Register`),
			this.paragraph(caseData.case.description),
			this.divider(),
			this.metadata("Export Date", new Date().toLocaleDateString("en-GB")),
		];

		if (this.branding.organisationName) {
			blocks.push(
				this.metadata("Organisation", this.branding.organisationName)
			);
		}

		return {
			type: "title-page",
			title: `${caseData.case.name} - Evidence Register`,
			blocks,
		};
	}

	private renderEvidenceSection(tree: TreeNode): RenderedSection {
		const evidence = collectElementsByType(tree, "EVIDENCE", 0, {
			includeSandbox: this.elementFilter?.includeSandbox,
		});

		const sectionTitle = this.getSectionTitle("evidence", "Evidence Register");
		const blocks: ContentBlock[] = [this.heading(2, sectionTitle)];

		const includeUrls = this.sections.evidence?.options?.includeUrls !== false;

		// Create a table of all evidence
		if (evidence.length > 0) {
			const headers = includeUrls
				? ["#", "Name", "Description", "URL"]
				: ["#", "Name", "Description"];

			const rows: string[][] = evidence.map(({ node }, index) => {
				const name = node.name ?? ELEMENT_TYPE_LABELS[node.type];
				const description = truncateText(node.description, 100);
				const row = [String(index + 1), name, description];

				if (includeUrls) {
					row.push(node.url ?? "-");
				}

				return row;
			});

			blocks.push(this.table(headers, rows));
		} else {
			blocks.push(this.paragraph("No evidence items found in this case."));
		}

		// Also list each evidence item with full details
		blocks.push(this.divider());
		blocks.push(this.heading(3, "Evidence Details"));

		for (const { node } of evidence) {
			blocks.push(...this.renderEvidenceItem(node, includeUrls));
		}

		return {
			type: "evidence",
			title: sectionTitle,
			blocks,
		};
	}

	private renderEvidenceItem(
		node: TreeNode,
		includeUrls: boolean
	): ContentBlock[] {
		const blocks: ContentBlock[] = [];
		const typeLabel = ELEMENT_TYPE_LABELS[node.type];
		const title = node.name ? `${typeLabel}: ${node.name}` : typeLabel;

		blocks.push(this.heading(4, title));

		if (node.description) {
			blocks.push(this.paragraph(node.description));
		}

		if (includeUrls && node.url) {
			blocks.push(this.metadata("URL", node.url));
		}

		return blocks;
	}

	private renderMetadataSection(caseData: CaseExportNested): RenderedSection {
		return {
			type: "metadata",
			title: this.getSectionTitle("metadata", "Document Information"),
			blocks: [
				this.heading(2, "Document Information"),
				this.metadata("Case Name", caseData.case.name),
				this.metadata("Export Version", caseData.version),
				this.metadata("Exported At", caseData.exportedAt),
				this.metadata(
					"Generated By",
					this.branding.footerText ?? "TEA Platform"
				),
			],
		};
	}
}
